# Nilcoinâ€¯Coreâ€¯vâ€¯2.0 (â€œqâ‚â€)

### Cryptographicâ€¯Primitives &â€¯Proofâ€¯System Specification

*Publication dateâ€¯â–¢2025â€‘XXâ€‘XX â€“ Council resolutionâ€¯#:â€¯â–¢NCâ€‘2025â€‘07*

---

## AbstractÂ (normative)

Nilcoinâ€¯Core vâ€¯2.0 defines the complete cryptographic foundation for the Nilcoin storageâ€‘based consensus network.â€¯**This Core spec is KZGâ€‘only**: any lattice/sealedâ€‘replica research is archived separately and **does not apply to mainnet.**

It specifies, in a fully reproducible manner:

1. **Field & transform algebra** over the CRT-friendly primes (`qâ‚`, `qâ‚‚`) used by **Derive**.
2. **Plaintext possession proofs** â€” **PoUD** using **KZG polynomial commitments** to DU plaintext, and **PoDE** timed window derivations (normative liveness path).
3. **BLSâ€¯VRF** and BATMAN aggregation for unbiased beacons.
4. **Dial policy** and governance process for safe parameter evolution.
5. **Security rationale** and Knownâ€‘Answer Tests for all normative components.

All constants are generated by an auditable Python script (Annexâ€¯C), and every algorithm is accompanied by deterministic Knownâ€‘Answer Tests (Annexâ€¯Aâ€“B).Â 
Versionâ€¯2.0 supersedes vâ€¯1.0 and vâ€¯1.0â€‘rcâ€¯series; it MUST be implemented verbatim by mainâ€‘network clients targeting activation heightâ€¯â–¢H\_ACT.

---

## Â§â€¯0â€ƒNotation, Dial Systemâ€¯&â€¯VersioningÂ (â€¯Baselineâ€¯Profileâ€¯â€œSâ€‘512â€â€¯)

\###â€¯0.1â€ƒSymbols, Typography, and Conventions

| Markup                    | Meaning                                               | Example         |
| ------------------------- | ----------------------------------------------------- | --------------- |
| `u8`, `u16`, `u32`, `u64` | Littleâ€‘endian unsigned integers of the stated width   | `0x0100 â†’ 256`  |
| `â‰¡`                       | Congruence *modâ€¯q* unless another modulus is explicit | `aâ€¯â‰¡â€¯bâ€¯(modâ€¯q)` |
| `â€–`                       | Concatenation of byte strings                         | `xâ€–y`           |
| `Î£`, `Î `                  | Fieldâ€‘sum / product in ğ”½\_q (wrap at *q*)            | `Î£_i x_iÂ modâ€¯q` |
| `NTT_k`                   | Lengthâ€‘*k* forward Numberâ€‘Theoretic Transform         | `ntt64()`       |

All integers, vectors, and matrices are interpreted **littleâ€‘endian** unless indicated otherwise.

\###â€¯0.2â€ƒDial Parameters

A **dial profile** is an ordered 8â€‘tuple
`(m, k, r, Î», H, Î³, q, Nonce)`:

| Symbol | Description                                | Baseline "Sâ€‘512"                |
| ------ | ------------------------------------------ | ------------------------------- |
| `q`    | Prime field modulus                        | **CRT (Mandatory):** $q_1$=**998â€¯244â€¯353** and $q_2$=**1â€¯004â€¯535â€¯809**. Effective modulus $Q = q_1 \times q_2 \approx 2^{60}$. |
| `Nonce`| Profile Nonce (high-entropy)               | 0x1A2B3C4D5E6F7890AABBCCDDEEFF0011 (example) |
| `k`    | NTT block size (radixâ€‘k)                   | 128                             |
| `r`    | Passes of dataâ€‘dependent permutation       | 3                               |
| `Î»`    | Gaussian noise Ïƒ (compression)             | 350 (fixed-point Ã—100)          |
| `H`    | Argon2â€‘drizzle passes                      | 2                               |
| `Î³`    | Interleave fragment size (MiB)             | 0 (sequential)                  |

Dial parameters are **frozen** per profile string (e.g., `"S-512"`).  Changes introduce a new profile ID (see Â§â€¯6).

\###â€¯0.3â€ƒVersion Triple

Every onâ€‘chain 32â€‘byte digest begins with a **version triple**

```
Version = {major : u8 = 0x02, minor : u8 = 0x00, patch : u8 = 0x00}
digest  = Blake2sâ€‘256( Version â€– DomainID â€– payload )
```

* **minor** increments when tuning `k, r, Î», H, Î³`.
* **patch** increments for nonâ€‘semantic errata (typos, clarifications).

\###â€¯0.4â€ƒDomain Identifiers

`DomainID : u16` partitions digests by purpose.  Reserved values:

| ID (hex)  | Domain                             | Source section |
| --------- | ---------------------------------- | -------------- |
| Â `0x0000` | Internal primitives                | Â§â€¯2â€“5          |
| Â `0x0200` | PoDE/Derive digest (windowâ€‘local)  | Â§â€¯4            |
| Â `0x0300` | Nilâ€‘VRF transcripts                | Â§â€¯5            |

Further IDs are allocated by Nilcoin governance (informative Appendixâ€¯D).

\####â€¯0.4.1â€ƒString Domain Tags (Blake2s separators)

For transparency and auditability, Core defines the following fixed ASCII domain strings used with Blake2sâ€‘256 across modules:

| Tag                  | Purpose                                  | Section    |
| -------------------- | ---------------------------------------- | ---------- |
| `"NIL_VRF_OUT"`     | VRF output compression                    | Â§â€¯5.2      |
| `"NIL_VRF_H2G"`     | VRF hash_to_G2 DST                        | Â§â€¯5.2      |
| `"NIL_BEACON"`      | Epoch beacon derivation from VRF output   | Â§â€¯5.3      |
| `"NilStore-Sample"` | Retrievalâ€‘sampling seed from epoch beacon | Â§â€¯5.7 (new) |
| `"SAMPLE-EXP"`      | PRF expansion for sampling indices        | Â§â€¯5.7 (new) |
| `"DERIVE_SALT_EXP"` | Salt expansion XOF for kâ€‘limbs          | Â§â€¯3.3      |
| `"BATMAN-SHARE"`    | Deterministic shareâ€‘selection label       | Â§â€¯5.4.3    |

\###â€¯0.5â€ƒChangeâ€‘Control and Notice

* Parameter changes follow Â§â€¯6 governance rules.
* Implementations **must** reject digests whose version triple or DomainID is unknown at compileâ€‘time.

\###â€¯0.6â€ƒReproducibility & Deterministic Build CharterÂ (normative)

* **Public transcripts:** Any claim in Â§Â§â€¯2â€“5,â€¯7 that depends on concrete parameters MUST have a reproducible transcript (JSON/CSV) in the release package (`_artifacts/`), accompanied by `SHA256SUMS`.
* **Pinned inputs:** All randomness derives from fixed domain tags (see Â§â€¯0.4.1) and explicit inputs; scripts MUST use integerâ€‘only operations for consensusâ€‘sensitive calculations.
* **Make target:** Reference repos MUST provide `make publish` that regenerates `_artifacts/*` and `SHA256SUMS` from a clean checkout.


---

## Â§â€¯1â€ƒFieldâ€¯&â€¯NTT ModuleÂ (`nilfield`)

\###â€¯1.1â€ƒConstants â€“ Primeâ€¯*qâ‚*â€¯=â€¯998â€¯244â€¯353

| Name     |            Value (decimal) | Hex                | Comment                  |
| -------- | -------------------------: | ------------------ | ------------------------ |
| `Q`      |                998â€¯244â€¯353 | 0x3B800001         | NTT-friendly primeÂ (â‰ˆ2Â³â°)|
| `R`      |                932â€¯051â€¯910 | 0x378DFBC6         | 2â¶â´Â modâ€¯Q                |
| `RÂ²`     |                299â€¯560â€¯064 | 0x11DAEC80         | *RÂ²*Â modâ€¯Q               |
| `Q_INV`  | 17â€¯450â€¯252â€¯288â€¯407â€¯896â€¯063 | 0xF22BC0003B7FFFFF | âˆ’Qâ»Â¹Â modâ€¯2â¶â´             |
| `g`      |                          3 | â€”                  | Generator of ğ”½\*\_Q     |
| `Ïˆ_64`   |                922â€¯799â€¯308 | 0x3700CCCC         | Primitive 64â€‘th root     |
| `Ïˆ_128`  |                781â€¯712â€¯469 | 0x2E97FC55         | Primitive 128â€‘th root    |
| `Ïˆ_256`  |                476â€¯477â€¯967 | 0x1C667A0F         | Primitive 256â€‘th root    |
| `Ïˆ_1024` |                258â€¯648â€¯936 | 0x0F6AAB68         | Primitive 1â€¯024â€‘th root  |
| `Ïˆ_2048` |                584â€¯193â€¯783 | 0x22D216F7         | Primitive 2â€¯048â€‘th root  |
| `64â»Â¹`   |                982â€¯646â€¯785 | 0x3A920001         | For INTT scaling         |
| `128â»Â¹`  |                990â€¯445â€¯569 | 0x3B090001         | â€”                        |
| `256â»Â¹`  |                994â€¯344â€¯961 | 0x3B448001         | â€”                        |
| `1024â»Â¹` |                997â€¯269â€¯505 | 0x3B712001         | â€”                        |
| `2048â»Â¹` |                997â€¯756â€¯929 | 0x3B789001         | â€”                        |

*Origin:* generated verbatim by the normative script in **Annexâ€¯C**.
All reference implementations embed these literals exactly.

\###â€¯1.1.1â€ƒMandatory CRT prime qâ‚‚ = 1â€¯004â€¯535â€¯809  (NTTâ€‘friendly)

Constants (Ïˆâ‚–, kâ»Â¹, Montgomery params) for qâ‚‚ are generated by Annexâ€¯C with:

```
python3 appendix_c_constants.py 1004535809 3 > constants_q2.txt
```

Implementations MUST embed the qâ‚‚ constants exactly as emitted and run the KATs in Annexâ€¯A for both primes.

\###â€¯1.2â€ƒAPI Definition (Rust signature, normative)

```rust
pub mod nilfield {
    /* ---------- modulus & Montgomery ---------- */
    pub const Q:      u32 = 998_244_353;
    pub const R:      u32 = 932_051_910;
    pub const R2:     u32 = 299_560_064;
    pub const Q_INV:  u64 = 0xF22BC0003B7FFFFF;

    /* ---------- field ops (constantâ€‘time) ----- */
    pub fn add(a: u32, b: u32) -> u32;   // (a + b) mod Q
    pub fn sub(a: u32, b: u32) -> u32;   // (a âˆ’ b) mod Q
    pub fn mul(a: u32, b: u32) -> u32;   // Montgomery product
    pub fn inv(a: u32) -> u32;           // aâ»Â¹ mod Q (Fermat)

    /* ---------- radixâ€‘k NTT ------------------- */
    pub fn ntt64(f: &mut [u32; 64]);     // forward DIF, inâ€‘place
    pub fn intt64(f: &mut [u32; 64]);    // inverse DIT, scaled 1/64
}
```

Implementations **shall** provide equivalent APIs in other languages.

\###â€¯1.3â€ƒConstantâ€‘Time Requirement (normative, microâ€‘arch aware)

All `nilfield` functions operating on secret data **must** execute in time independent of their inputs and **must not** perform secretâ€‘dependent memory accesses or controlâ€‘flow.

**Rules (normative):**
1) **No secretâ€‘dependent branches** (including early returns), **no secretâ€‘dependent table lookups**, **no secretâ€‘dependent memory addresses**.
2) **Fixed operation counts**: loops and iteration counts must be independent of secret values.
3) **Instruction selection**: avoid variableâ€‘latency divisions; inversion `inv(a)` **must** use a fixedâ€‘window addition chain or slidingâ€‘window exponentiation with constantâ€‘time selection (no dataâ€‘dependent table indices).
   **Normative (Inversion):** Inversion of secret values MUST use Fermat's Little Theorem (a^(q-2) mod q) with a fixed, optimized addition chain.
4) **Montgomery core**: `mul`/`REDC` must use only integer ops; final conditional subtraction must be implemented with constantâ€‘time bitâ€‘masking (no branches).
   **Instruction Latency (Normative):** Implementations MUST use instructions guaranteed to be constant-time (e.g., widening multiplies with fixed cycles, `mulx` on x86-64) and verify this via assembly inspection.
5) **Tooling gates (required)**:
   â€¢ **ctgrind**: zero findings;  
   â€¢ **dudect**: Welchâ€™s *t*â€‘test |t| â‰¤â€¯4.5 on â‰¥â€¯2Â²â° traces at 3â€¯GHz equivalent;  
   â€¢ **llvmâ€‘mca (or objdump review)**: verify no dataâ€‘dependent instructions (DIV/MOD) in secretâ€‘handling code paths;  
   â€¢ **cacheâ€‘flow audit**: static check that all memory indices in secret code are public.
   â€¢ **Formal Verification (Required):** Use formal methods tools (e.g., EasyCrypt, Jasmin) to provide a machine-checked proof that the reference implementation of `inv(a)` and `mul` is constant-time.
6) **Build flags**: enable constantâ€‘time codegen (e.g., `-fno-builtin-memcmp` or constantâ€‘time intrinsics) and pin target CPU features in CI.

**Formal Auditing Process (Normative):** Reference implementations MUST undergo a formal audit including manual review of generated assembly on target architectures and explicit threat modeling for cache-timing attacks (e.g., Flush+Reload, Prime+Probe).

**CRT (Normative):** With the mandatory CRT profile:
1) **Reconstruction:** The reconstruction algorithm (e.g., Garner's method) MUST be implemented in constant time.

**NTT (Normative):** Memory access patterns during the NTT MUST be data-independent. Twiddle factor tables MUST be accessed using only public indices.

**Documentation**: Reference implementations MUST include a short writeâ€‘up explaining how each rule is met in `nilfield`, especially for `inv(a)`.

\###â€¯1.4â€ƒRadixâ€‘*k* NTT Specification

* The forward transform `ntt_k` is a breadthâ€‘first DIF algorithm using `Ïˆ_k` twiddles; input and output are in natural order.
* The inverse transform `intt_k` is DIT with twiddles `Ïˆ_kâ»Â¹`.
* Postâ€‘inverse scaling multiplies every coefficient by `kâ»Â¹Â modâ€¯Q`.
* For `kâ€¯âˆˆâ€¯{64,128,256,1024,2048}` the corresponding `Ïˆ_k` **must** be used; extending to higher powers of two requires governance approval (Â§â€¯6).

**Memory layout:** vectors are contiguous arrays of `u32` littleâ€‘endian limbs.  No bitâ€‘reversal copy is permitted outside the NTT kernels.

**Knownâ€‘Answer Tests:** Annexâ€¯A.1 & A.2 contain roundâ€‘trip vectors
`[1,0,â€¦]Â â†’Â NTTÂ â†’Â INTTÂ â†’Â [1,0,â€¦]` for every supportedÂ *k*.

\###â€¯1.5â€ƒImplementation Guidance (with constantâ€‘time WASM/MCU profile)

* Preferred: 32Ã—32â†’64 **Montgomery** multiply + `REDC` using only integer ops. On 32â€‘bit targets, use twoâ€‘limb decomposition to synthesize 64â€‘bit products in constant time.
* **WASM (wasm32):** require native `i64` support; **asm.js** fallbacks or FP must not be used. Constantâ€‘time **Barrett** is permitted with Î¼ = âŒŠ2â¶â´/qâŒ‹ and all reductions implemented without division and without secretâ€‘dependent branches. Implementations MUST ship KATs demonstrating equality with Montgomery on the same inputs.
* **Environment probes (normative):** at startup, assert (a) twoâ€™sâ€‘complement integers, (b) 32â€‘ and 64â€‘bit widths as specified, (c) native 64â€‘bit integer ops available. Otherwise, **fail fast** and expose a conformance error.
* Inline `kâ»Â¹` scaling into the last butterfly stage to save one loop **only** if the fused code path preserves constantâ€‘time guarantees above.

---

---

 

\###â€¯2.0â€ƒScope


---

\###â€¯2.1â€ƒMessageâ€¯â†’â€¯Vector Injection (â€œSVTâ€¯orderâ€)

\####â€¯2.1.1â€ƒPadding

```
msg' = |len_u64|_LE  â€–  msg  â€–  0x80  â€–  0x00 â€¦           // pad to multiple of 3 bytes
```

* `|len_u64|` is the original message length in **bytes**.
* Append `0x80`, then zeroâ€‘bytes until `len(msg')` is a multiple of 3 (â‰¥â€¯8â€¯+â€¯|msg|â€¯+â€¯1).
  *(ISO/IECâ€¯9797â€‘1 schemeâ€¯1 adapted to 12â€‘bit limbs.)*

\####â€¯2.1.2â€ƒLimb parsing

`x_raw`Â =Â `msg'` parsed as packed littleâ€‘endian 12â€‘bit limbs.
For 3 bytes (bâ‚€, bâ‚, bâ‚‚), unpack two limbs: 
  xáµ¢ = bâ‚€ | (bâ‚ & 0x0F) << 8; 
  xáµ¢â‚Šâ‚ = (bâ‚ >> 4) | bâ‚‚ << 4.
`x_rawÂ =Â [xâ‚€,Â xâ‚,Â â€¦,Â x_{Lâˆ’1}]` with `LÂ =Â (len(msg')/3) * 2`.

If `Lâ€¯>â€¯m`â€ƒâ†’â€ƒ**reject** (â€œmessage too long for profileâ€).
If `Lâ€¯<â€¯m` pad the tail with zeros.

\####â€¯2.1.3â€ƒSVT order (strideâ€‘vectorâ€‘transpose)

Let `B = m / k` blocks (baseline `kÂ =Â 64`, `BÂ =Â 16`).
Conceptually arrange the limb array as a **kâ€¯Ã—â€¯B** rowâ€‘major matrix

```
Row r (0 â€¦ k-1) :  x_raw[rÂ·BÂ +Â c] ,  c = 0 â€¦ B-1
```

**SVT order** is the **columnâ€‘major readâ€‘out** of this matrix:

```
SVT(x_raw)[ i ] = x_raw[ (i mod k) Â· B  +  âŒŠi / kâŒ‹ ] ,  0 â‰¤ i < m.
```

Intuition: every NTT block (row) receives one limb from each stride column, maximising interâ€‘block diffusion.

---
\###â€¯2.2â€ƒAlgorithmsÂ (revised)

> **Public parameters** (fixed per dial profile, derived in Annexâ€¯C)
>
> * **Hash Function H (Normative):** All parameter generation MUST use SHAKE128 as an Extendable Output Function (XOF).
> * **Uniform Sampling (Normative):** All sampling modulo q MUST use uniform rejection sampling (no moduloâ€‘bias), with statistical distance from uniform < 2^-128.
> * **Seed mixing (Normative, strengthened):** All perâ€‘object seeds for parameter generation MUST be drawn from a master XOF stream


>   with the following requirements:
>   1) `GovProposalHash` = Blake2sâ€‘256 of the governance proposal object that introduces the dial/profile change (hashâ€‘pinned onâ€‘chain at proposal open);
>   2) `CRS_commit` / `CRS_reveal`: a *threshold* (â‰¥â€¯tâ€‘ofâ€‘n) commitâ€‘reveal from independent parties posted on L1.
>   3) **Stalling Prevention (Normative):** `vrf_beacon_paramgen` MUST be derived from a VRF transcript at a block height determined **after** the commit phase closes. Any missing reveals (for Nonce or CRS) MUST be replaced by `vrf_beacon_paramgen`.
>   3) All subâ€‘seeds MUST include **explicit domain strings** unique per artifact:
>
>      `H("A-seed"â€–Versionâ€–DIDâ€–Nonceâ€–GovProposalHashâ€–CRS_commitâ€–CRS_reveal)`,  
>      `H("B-spectrum"â€–Versionâ€–DIDâ€–Nonceâ€–GovProposalHashâ€–CRS_commitâ€–CRS_revealâ€–j)`,  
>      `H("twist"â€–Versionâ€–DIDâ€–Nonceâ€–GovProposalHashâ€–CRS_commitâ€–CRS_revealâ€–j)`.
>
>   Reâ€‘using `Nonce` or `GovProposalHash` across major/minor versions is forbidden. Implementations MUST serialize and store the full paramgen transcript for audit.
>   **Grinding prohibition:** the ceremony and transcript MUST ensure no single party can bias `A`, `B`, or the perâ€‘domain twist values.
> * Circulant matrix **A** generated from first row `Î±` (derived via H("A-seed"â€–Versionâ€–DIDâ€–Nonce)).
> * Independent circulant matrix **B**: sample $\widehat b_j$ uniformly from ğ”½_q using H("B-spectrum"â€–Versionâ€–DIDâ€–Nonceâ€–j) until nonâ€‘zero; set **b_vec = INTT( \widehat b )**.   // renamed to avoid collision with the râ€‘bound Î²
> * **Spectral Checks (Normative):**
>   1) **B invertibility:** every NTT coefficient of $\widehat b$ MUST be nonâ€‘zero (det(B) â‰  0) **and** the minimal polynomial of $\widehat b$ over ğ”½_q MUST have no factors of order â‰¤ 2Â¹â¶. Reâ€‘sample on failure.
>   2) **A robustness:** the NTT of the first row of A, $\widehat Î±$, MUST pass the same minimalâ€‘polynomial filter (no smallâ€‘order factors); additionally, every coefficient of $\widehat Î±$ MUST be nonâ€‘zero.
>   3) **Coâ€‘primeness:** for all indices j, **gcd**$(\widehat Î±_j, \widehat b_j, q)=1$ (i.e., $(A,B)$ have no shared lowâ€‘order spectral factors). Reâ€‘sample on failure.
> * Perâ€‘domain **spectral twist** **D^(DID)**: sample $d_j$ uniformly from ğ”½_q using H("twist"â€–Versionâ€–DIDâ€–Nonceâ€–j), reâ€‘draw zeros. Apply as a diagonal in NTT space on the AÂ·x path.

| Function      | Signature                                                                  | Definition |
| ------------- | ---------------------------------------------------------------------------- | ---------- |
| **commit**    | `fn commit(DID, msg, rng) â†’ h: [u32; m]{Ã—CRT}`                                | Prover samples `r â† D_Ïƒ` with `||r||_âˆ â‰¤ Î²` (constantâ€‘time), computes `h = (A_twistedÂ·x) + (BÂ·r)`, and retains `(r, Ï€)` privately. |
| **open**      | `fn open(msg, r, Ï€) â†’ (msg, r, Ï€)`                                          | Output the original message, blinding vector `r`, and its boundâ€‘proof `Ï€`. The sampling of `r` MUST be constantâ€‘time. |
| **verify**    | `fn verify(h, msg, r, Ï€) â†’ bool`                                             | Recompute `x` and twist; check `h == A_twistedÂ·x + BÂ·r` per prime; verify `Ï€`. |
| **update**    | *unchanged* (requires reâ€‘commit)                                            | Any change to `msg` or `r` requires a fresh `commit`. |
| **aggregate** | `Î£_field`                                                                    | Componentâ€‘wise addition of commitment vectors. |

*Complexity* â€“ Commit/Verify: unchanged NTT count (perâ€‘prime); proof adds O(logâ€¯m) time and ~2â€¯kB to the opening object.

**Sampling (Normative):** The sampling of `r` MUST use a specified constant-time algorithm (e.g., constant-time discrete Gaussian or centered binomial) with published bounds on the statistical distance from the target distribution.

> **Note:** Attributeâ€‘selective openings will appear in vâ€¯2.1 using a zeroâ€‘knowledge innerâ€‘product argument.  For vâ€¯2.0 all openings disclose the entire message.

\####â€¯2.2.1â€¯Â KAT impact

Note: Knownâ€‘Answer Tests updated in Annexâ€¯A.3.


---

\###â€¯2.3â€ƒOnâ€‘Chain Digest Format

```
commit_digest =
    Blake2sâ€‘256( Version â€– DomainID â€– h^{(1)} â€– h^{(2)} )   // 32â€¯bytes
    // CRT is mandatory. **Both** vectors MUST be included in the digest input and in every `verify` computation; openings MUST satisfy the relation in **each** prime separately. The primes qâ‚ and qâ‚‚ MUST be coâ€‘prime. No perâ€‘prime truncation or mixing is permitted.

where  Version  = {0x02,0x00,0x00}
       DomainID = 0x0000  (internal primitive namespace)
```

The entire vectorÂ `h` (2â€¯KiB baseline) **must** be supplied in calldata when `Version.major` increases; otherwise the 32â€‘byte digest is sufficient.

---

\###â€¯2.4â€ƒWorked Example (Baseline â€œSâ€‘512â€)

Input: empty string `""`, `DID = 0x0000`.

| Step              | Result (hex, littleâ€‘endian)       |
| ----------------- | --------------------------------- |
| `h` (1â€¯024 limbs) | `f170â€¯75ceâ€¯9788â€¯65d7 â€¦ c386â€¯7881` |
| `commit_digest`   | `af01â€¯c186â€¯â€¦â€¯e3d9â€¯990d` (32â€¯B)    |


Note (CRT mode): The mandatory CRT prime `qâ‚‚` requires an additional vector `h^{(2)}` computed identically over `qâ‚‚`, and `commit_digest` hashes the concatenation `h^{(1)} â€– h^{(2)}` (see Â§â€¯2.3).

---

\###â€¯2.5â€ƒParameterisation & Extensibility

* Increasing `m` or changing `q`Â â†’ **major** version bump (Â§â€¯0.3).
* Tuning `k` or replacing `Î±` with a higherâ€‘order root (e.g., `Ïˆ_128`)
  â†’ **minor** bump; implementers must regenerate the *A* row using Annexâ€¯C.

---

\###â€¯2.6â€ƒImplementation Notes (informative)

* **Vectorised FFT:** two 64â€‘point NTTs fit in AVXâ€‘2 registers; unroll eight butterflies per stage for maximum ILP.
* **Memoryâ€‘hard variants:** set `kâ€¯=â€¯256` and keep `Bâ€¯=â€¯m/k` fixed to quadruple cache footprint.
* **Open/verify kernels:** the circulant property lets one reuse a single 64â€‘point NTT per dotâ€‘product.

---


---

 

 

\###â€¯3.0â€ƒScopeâ€¯&â€¯ThreatÂ Model

`Sâ€¯=â€¯2^n`â€¯bytes, *nâ€¯â‰¥â€¯26* (â‰¥â€¯64â€¯MiB)â€”into a **replica** that:

1. **Binds storage**â€ƒReproducing the replica from the clear sector and secret key takes â‰¥â€¯`t_recreate_replica` seconds (Â§â€¯6).
2. **Hides data**â€ƒThe replica is computationally indistinguishable from uniform given only public parameters and the minerâ€™s address.

Adversary capabilities: unbounded offline preâ€‘computation, full control of public parameters, but cannot learn the minerâ€™s VRF secret key `sk`.

\###â€¯3.1â€ƒSymbolÂ Glossary (dial profile â€œSâ€‘512â€)

| Symbol   | Type / default | Definition                                |
| -------- | -------------- | ----------------------------------------- |
| `S`      | 32â€¯GiB         | Sector size (benchmark)                   |
| `row_i`  | `u32`          | `BLAKE2s-32(sector_idâ€–sector_digest) mod rows`, where `sector_id = BLAKE2s-256(miner_addrâ€–sector_number)` |
| `salt`   | `[u8;32]`      | `vrf(sk, row_i)`                          |
| `chunk`  | `[u32;k]`      | Radixâ€‘*k* NTT buffer (*kÂ =Â 64*)           |
| `pass`   | `0 â€¦ râˆ’1`      | Permutation round (*rÂ =Â 3*)               |
| `Î¶_pass` | `u32`          | Round offset (dataâ€‘dependent)             |
| `Î»`      | 280            | Gaussian Ïƒ (noise compression, fixedâ€‘point Ã—100) |
| `Î³`      | 0              | MiB interleave fragment size              |

\###â€¯3.2â€ƒPreâ€‘Processing â€“ Argon2 â€œDrizzleâ€

If `HÂ =Â 0`â€ƒâ†’â€ƒskip.
Else perform `H` inâ€‘place passes of **Argon2id** on the sector:

```
argon2id(
    pwd   = sector_bytes,          // streaming mode
    salt  = salt,                  // 32 B
    mem   = âŒˆS / 1â€¯MiBâŒ‰  Kib,
    iters = 1,
    lanes = 4,
    paral = 2
)
```

Each 1â€¯MiB Argon2 block XORs back into its original offset.  This yields a *memoryâ€‘hard* whitening keyed by the miner.

\###â€¯3.3â€ƒRadixâ€‘k Transform Loop

Let `N_chunks = S / (2Â·k)` littleâ€‘endian 16â€‘bit chunks.

For `pass = 0 â€¦ râˆ’1` (baselineÂ `rÂ =Â 3`):

1. **Chunk iteration order** â€“ determined by the **dataâ€‘dependent PRP permutation** (3.4).

2. **NTT pipeline**

   ```
   NTT_k(chunk)                    // forward DIF
   // Derive perâ€‘pass salt limbs (deterministic, domainâ€‘separated)
   salt_k = SHAKE128("DERIVE_SALT_EXP" â€– salt â€– u8(pass))[0 .. 4k) as k littleâ€‘endian u32 limbs mod Q
   for j in 0..k-1:
       chunk[j] = chunk[j] + salt_k[j]   mod Q
   INTT_k(chunk)                   // inverse DIT, scaled kâ»Â¹
   ```
**Rationale:** Salt is added in the frequency domain (after the NTT) to ensure its influence is uniformly diffused across all output limbs following the inverse transform, rather than being localized.

3. **Interleaved write**

   *If* `Î³ = 0`â€ƒâ†’â€ƒwrite back to original offset.
   *Else* compute `stride = Î³â€¯MiB / (2Â·k)` and write chunk to
   `offset = (logical_index â‹… stride)Â modÂ N_chunks`.

\####â€¯3.3.1â€ƒMicroâ€‘Seal Derive (windowâ€‘scoped, normative for PoDE)

Purpose: Provide a deterministic, beaconâ€‘salted local transform on a `W`â€‘byte window (default `W = 8â€¯MiB`) that can be recomputed directly from **plaintext** during PoDE; it MUST be domainâ€‘separated from full sealing and MUST NOT require a sealed replica.

Definition:

```
Derive(clear_window, beacon_salt, row_id):
  1) Partition clear_window into kâ€‘limb chunks (k per dial profile; baseline k = 64).
  2) For pass = 0..râˆ’1:
        NTT_k(chunk);
        salt_k = SHAKE128("DERIVE_SALT_EXP" â€– beacon_salt â€– u8(pass) â€– u32_le(row_id))[0 .. 4k) as k littleâ€‘endian u32 limbs mod Q;
        for j in 0..kâˆ’1: chunk[j] = (chunk[j] + salt_k[j]) mod Q;
        INTT_k(chunk);
  3) Output:
        leaf64 := first 64 bytes of the window postâ€‘transform;
        Î”_W := Blake2sâ€‘256(window postâ€‘transform).
```

Constraints:
- `salt_k` MUST be domainâ€‘separated from fullâ€‘replica sealing salts (Â§â€¯3.3).
- No crossâ€‘window state is permitted; `Derive` is local to the window bytes.
- Implementations MUST provide KATs in Annexâ€¯B for `Derive`.
**Domain separation (normative):** For PoUD/PoDE usage, salt derivation MUST include `epoch_id` and `du_id` in addition to `beacon_salt` and `row_id`, to prevent crossâ€‘deal replay of derived windows within the same epoch.

\###â€¯3.4â€ƒDataâ€‘Dependent PermutationÂ (normative)

\####â€¯3.4.1â€ƒPermutation map (PRP) â€” normative

Index chunks by linear index `i âˆˆ [0, N_chunks)`. The PRP MUST be a **20â€‘round Feistel network** keyed by `Î¶_p` over the domain `M = N_chunks`. Because `S = 2^n` and chunk size is fixed, `N_chunks` is a power of two; thus `M` is exact and **no cycleâ€‘walk is performed**. Round function:

```
Derive the round key `K_round` (using the full 256-bit Î¶_p, see Â§ 3.4.2):

F(round, halfword, Î¶_p) :=
    BLAKE2s-256(
        msg = u32_le(halfword),
        key = K_round
    )[0..4) as littleâ€‘endian u32, then masked to halfâ€‘width
```

Operate on `w = ceil_log2(M)` bits split into equal halves; mask outputs to the halfâ€‘width each round. Let `Feistel_M(x)` be the 20â€‘round Feistel permutation on `[0, M)`.


\####â€¯3.4.2â€ƒRoundâ€‘offset Î¶<sub>pass</sub>

For `p = 0`, define:

After finishing pass `pâˆ’1`, compute a digest of the entire pass's data that is sensitive to chunk order.

`ChunkHashes_{p-1} = [Blake2sâ€‘256(chunk_0^{p-1}), Blake2sâ€‘256(chunk_1^{p-1}), ...]`
`ChunkDigest_{p-1} = IteratedHash(ChunkHashes_{p-1})`


**Normative (Data Integrity):** `ChunkHashes_{pâˆ’1}` MUST commit to the exact byte sequence of pass `pâˆ’1`; the method of obtaining those bytes (disk, cache, or RAM) is implementationâ€‘defined and outside consensus.

 


 

**Canonical sector identifier:** Replace filesystem `path` in all salts and indices with a canonical `sector_id = Blake2s-256(miner_addr â€– sector_number)` to prevent minerâ€‘chosen paths from influencing Î¶ derivation.



**Rationale:** Using an IteratedHash ensures that `ChunkDigest` depends on the precise ordering of all chunks and enforces strict sequential computation.

RoundÂ `p` traverses chunks in the order determined by the PRP defined in Â§â€¯3.4.1 using the computed `Î¶_p`.

*Security intuition* â€“ Î¶<sub>p</sub> is **unknowable** until all writes of
passâ€¯`pâˆ’1` complete, enforcing sequential work (Â§â€¯7.4.1).

\####â€¯3.4.3â€ƒMicroâ€‘seal profile (derivation mode, normative dial)

Dial `micro_seal` controls localized sealing for derivation challenges. When `micro_seal = off` (baseline Sâ€‘512), the permutation and Î¶â€‘derivation operate over the entire sector as specified in Â§â€¯3.4.1â€“Â§â€¯3.4.2.

When `micro_seal = row` (optional profile for PoDE enablement), the sealing transform is localized per 2â€¯MiB row tile:

- Domain separation: All Blake2s invocations used to derive PRP keys and Î¶ include the row index `i` as an explicit littleâ€‘endian field.
- PRP scope: The Feistel permutation in Â§â€¯3.4.1 is applied over the set of chunk indices belonging to row `i` only; no cycleâ€‘walk is introduced.

This dial is intended solely to enable fast, rowâ€‘local derivations required by Â§â€¯4.2.2 without altering baseline Sâ€‘512 behavior. Profiles enabling `micro_seal = row` MUST publish Annex A/B KATs showing identical digest roots to baseline for `micro_seal = off` when Â§â€¯4 is not in linking/derivation mode.

\###â€¯3.5â€ƒGaussianâ€¯Noise Compression

For every 2â€¯KiB window **W** (postâ€‘transform):

```
Ïƒ_Q_100 = âŒŠ100 Â· Q / âˆš12âŒ‹             // stdâ€‘dev of uniform limb (fixedâ€‘point approximation)
W' = Quantize( W + N(0, (Î»Â·Ïƒ_Q_100 / 10000)Â²) )
```

*Quantize* rounds to the nearest valid limb modâ€¯`Q`. Noise MUST be generated by a deterministic, constantâ€‘time sampler (e.g., Knuthâ€‘Yao or fixedâ€‘point Ziggurat) using only integer arithmetic to ensure crossâ€‘platform consensus.
**Normative (RNG Secrecy):** The sampler inputs MUST include the miner-secret `salt` to prevent reversibility by adversaries with knowledge of the original data.
**Integerâ€‘only & UBâ€‘free:** Implementations MUST use twoâ€™sâ€‘complement integers with fixed widths, no floating point, no signed overflow (use widening 64â€‘bit intermediates), and no implementationâ€‘defined shifts.
**Constantâ€‘time:** Samplers MUST NOT branch on secret values and MUST consume the full stream (masking) even if rejection occurs.
**Normative (Quantize tieâ€‘break):** When rounding halfway cases, implementations MUST use tiesâ€‘toâ€‘even on the integer preimage before reduction mod `Q` to avoid platform drift. Provide a reference integer pseudocode and KATs to ensure crossâ€‘platform agreement.
**Sampler conformance (Normative):** Implementations MUST use a tableâ€‘driven constantâ€‘time method (aliasâ€‘table, Knuthâ€“Yao, or fixedâ€‘point Ziggurat) with precomputed CDF tables baked into KATs. Include KATs for: (i) first 4 CTR blocks of the XOF stream per `(row,window,pass)`; (ii) histogram Ï‡Â² bounds over 2Â²â° samples; (iii) endâ€‘toâ€‘end determinism across bigâ€‘endian/littleâ€‘endian targets.



\###â€¯3.7â€ƒDeltaâ€‘Row Accumulator

During compression the encoder computes a digest for each 2â€¯MiB row. For rowâ€¯*i* (two windows):

```
Î”_row[i] = Blake2s-256( W_{2i} â€– W_{2i+1} )
```


\###â€¯3.7.1â€ƒOrigin Map (rowâ†’DU binding, normative)

For each row `i` the encoder MUST record an `OriginEntry`:

```
OriginEntry := { row_id = i, du_id, sliver_index, symbol_range, C_root }
```

where `C_root` is the DU KZG commitment recorded at deal creation and
`symbol_range` encodes the contiguous 1â€¯KiB RS symbols from the sliver that occupy row `i`.
All `OriginEntry` objects MUST be Poseidonâ€‘Merkleized into `origin_root`.

from `origin_root` for the challenged row (see Â§â€¯4.2.1).

\###â€¯3.8â€ƒReference EncoderÂ (pseudocode)

```rust
fn seal_sector(path, sector_bytes, miner_sk, params) {
    let sector_digest = blake2s256(sector_bytes);
    let sector_id = blake2s256(miner_addr || sector_number);
    let row_i = blake2s32(sector_id || sector_digest) % rows;
    let salt  = vrf(miner_sk, row_i);                 // 32 B

    argon2_drizzle_if(params.H, sector_bytes, salt);

    for pass in 0..params.r {
        let Î¶ = compute_offset(pass, salt, sector_bytes);
        for (idx, chunk) in iter_chunks(params.k, Î¶, sector_bytes) {
            ntt_k(chunk);
            add_salt(chunk, &salt, params.Q);
            intt_k(chunk);
            interleave_write(chunk, idx, params.Î³, sector_bytes);
        }
    }
    gaussian_compress(sector_bytes, params.Î», params.Q);
    build_merkle_and_rowcommit(sector_bytes, salt, path);
}
```

\###â€¯3.9â€ƒDial GuardrailsÂ (normative limits)

| Dial | Range         | Complexity effect | Guardâ€‘rail                            |
| ---- | ------------- | ----------------- | ------------------------------------- |
| `k`  | 64â€¯â†’â€¯256      | CPUâ€¯âˆâ€¯kâ€¯logâ€¯k     | `k â‰¤ 256` fits L3 cache               |
| `r`  | 2â€¯â†’â€¯5         | Timeâ€¯âˆâ€¯r          | Seal time â‰¤â€¯2Ã— network median         |
| `Î»`  | 280â€¯â†’â€¯500     | Diskâ€¯â†‘            | Î»â€¯>â€¯400 requires compressionâ€‘ratio vote |
| `m`  | 1â€¯024â€¯â†’â€¯2â€¯048 | CPUâ€¯âˆâ€¯mÂ²          | Proof size constant                   |
| `H`  | 0â€¯â†’â€¯2         | DRAMâ€¯Ã—â€¯H          | H â‰¤â€¯2                                 |
| `Î³`  | 0â€¯â†’â€¯4â€¯MiB     | Seeksâ€¯â†‘           | Î³â€¯>â€¯0 needs HDDâ€‘impact vote           |

Profiles violating a guardâ€‘rail are **invalid** until approved by governance (Â§â€¯6).

---

\###â€¯3.10â€ƒPerformance Targets (baseline hardware, informative)

| Task                   | 4Ã— SATA SSD | 8â€‘core 2025 CPU |
| ---------------------- | ----------- | --------------- |
| Seal 32â€¯GiB            | â‰¤â€¯8â€¯min     | â‰¤â€¯20â€¯min        |
| Reâ€‘seal from last leaf | â‰¤â€¯1â€¯min     | â‰¤â€¯3â€¯min         |

---

\###â€¯3.11â€ƒSecurity References

Detailed proofs for sequentialâ€‘work and indistinguishability appear in Â§â€¯7.4.

---



---

 
## Â§â€¯4â€ƒProofâ€‘ofâ€‘Usefulâ€‘Data (PoUD) & Proofâ€‘ofâ€‘Delayedâ€‘Encode (PoDE)  â€” Normative

\###â€¯4.0aâ€ƒDerive (windowâ€‘scoped, normative for PoDE) â€” moved from Â§â€¯3.3.1
Purpose: deterministic, beaconâ€‘salted local transform on a `W`â€‘byte window (default `W = 8â€¯MiB`) recomputable directly from **plaintext** during PoDE; domainâ€‘separated from full sealing; MUST NOT require a sealed replica.

```
Derive(clear_window, beacon_salt, row_id):

1. Partition clear_window into kâ€‘limb chunks (baseline k = 64).
2. For pass = 0..râˆ’1:
   NTT_k(chunk);
   salt_k = SHAKE128("DERIVE_SALT_EXP" â€– beacon_salt â€– u8(pass) â€– u32_le(row_id))[0 .. 4k) as k littleâ€‘endian u32 limbs mod Q;
   for j in 0..kâˆ’1: chunk[j] = (chunk[j] + salt_k[j]) mod Q;
   INTT_k(chunk);
3. Output:
   leaf64 := first 64 bytes postâ€‘transform;
   Î”_W := Blake2sâ€‘256(window postâ€‘transform).

```

**Domain separation (normative):** For PoUD/PoDE usage, salt derivation MUST include `epoch_id` and `du_id` in addition to `beacon_salt` and `row_id`, to prevent crossâ€‘deal replay within the same epoch.

\###â€¯4.0â€ƒObjective & Model

Attest, per epoch, that an SP (a) stores the **cleartext** bytes of their assigned DU intervals and (b) can perform **timed, beaconâ€‘salted derivations** over randomly selected windows quickly enough that fetching from elsewhere is infeasible within the proof window.

**Security anchors:** (i) DU **KZG commitment** `C_root` recorded at deal creation; (ii) BLSâ€‘VRF epoch beacon for unbiased challenges; (iii) onâ€‘chain **KZG multiâ€‘open** preâ€‘compiles; (iv) watcherâ€‘enforced timing digests.

\###â€¯4.1â€ƒDU Representation & Commitment

Let a DU be encoded with systematic RS(n,k) over GF(2â¸) and segmented into **1â€¯KiB symbols**. The client computes a **KZG commitment** `C_root` to the RSâ€‘symbol polynomial(s) at deal creation and posts `C_root` on L2; all subsequent storage proofs **must open against this original commitment**.

\###â€¯4.2â€ƒChallenge Derivation

For epoch `t` with beacon `beacon_t`, expand domainâ€‘separated randomness to pick `q` **distinct symbol indices** per DU interval and `R` **PoDE windows** of size `W = 8â€¯MiB`. Selection MUST be moduloâ€‘biasâ€‘free.

\###â€¯4.3â€ƒProver Obligations per DU Interval

1) **PoUD â€” KZGâ€‘PDP (content correctness):** Provide KZG **multiâ€‘open** at the chosen 1â€¯KiB symbol indices proving membership in `C_root`.
2) **PoDE â€” Timed derivation:** For each challenged window, compute `deriv = Derive(clear_window, beacon_salt, row_id)` and submit `H(deriv)` plus the **minimal** clear bytes for verifier recompute, all **within** the perâ€‘epoch `Î”_submit` window. Enforce **Î£ verified bytes â‰¥ B_min = 128â€¯MiB** over all windows and **R â‰¥ 16** subâ€‘challenges/window (defaults; DAOâ€‘tunable).
   **Normative (PoDE Linkage):** The prover MUST provide a KZG opening proof `Ï€_kzg` demonstrating that the `clear_window` input bytes correspond exactly to the data committed in `C_root`.

\###â€¯4.4â€ƒVerifier (Onâ€‘chain / Watchers)

* **Onâ€‘chain:** Verify **KZG multiâ€‘open** against `C_root`; check counters for `R` and `B_min`.
* **Onâ€‘chain (PoDE):** Verify `Ï€_kzg` against `C_root` for the `clear_window`.
* **Watchers:** Verify PoDE recomputations and timing (RTTâ€‘oracle transcripts). Aggregate pass/fail into an onâ€‘chain digest per SP.

\###â€¯4.5â€ƒCoverage & Parameters (Auditor math)

Let DU contain **M** symbols. With **q** fresh symbols per epoch over **T** epochs, the chance any symbol is never checked is `M Â· (1 âˆ’ q/M)^T`. Choose `qÂ·T` to push this below Î´ (e.g., 2â»Â¹Â²â¸) for the DU class. Governance publishes defaults and bounds.

\###â€¯4.6â€ƒOnâ€‘chain Interfaces (normative)

L1 **MUST** expose: `verify_kzg_multiopen(...)`, `verify_poseidon_merkle(...)`, `blake2s(bytes)`. Proof acceptance window: `T_epoch = 86â€¯400â€¯s`, `Î”_submit = 30â€¯s`. Perâ€‘replica work bound used by timing invariants: `Î”_work = 1â€¯s`.

---

 
