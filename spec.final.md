# Nilcoinâ€¯Coreâ€¯vâ€¯2.0 (â€œqâ‚â€)

### Cryptographicâ€¯Primitives &â€¯Proofâ€¯System Specification

---

## Abstract

Nilcoinâ€¯Core vâ€¯2.0 defines the complete cryptographic foundation for the Nilcoin storageâ€‘based consensus network. 

It specifies, in a fully reproducible manner:

1. **Field & transform algebra** over the CRT-friendly primes (`qâ‚`, `qâ‚‚`) used by **Derive**.
2. **Plaintext possession proofs** â€” **PoUD** using **KZG polynomial commitments** to DU plaintext, and **PoDE** timed window derivations (normative liveness path).
3. **BLSâ€¯VRF** and BATMAN aggregation for unbiased beacons.
4. **Dial policy** and governance process for safe parameter evolution.
5. **Security rationale** and Knownâ€‘Answer Tests for all normative components.

All constants are generated by an auditable Python script (Annexâ€¯C), and every algorithm is accompanied by deterministic Knownâ€‘Answer Tests (Annexâ€¯Aâ€“B).Â 
Versionâ€¯2.0 supersedes vâ€¯1.0 and vâ€¯1.0â€‘rcâ€¯series; it MUST be implemented verbatim by mainâ€‘network clients targeting activation heightâ€¯â–¢`H_ACT`.

---

## Â§â€¯0â€ƒNotation, Dial Systemâ€¯&â€¯VersioningÂ (â€¯Baselineâ€¯Profileâ€¯â€œSâ€‘512â€â€¯)

###â€¯0.1â€ƒSymbols, Typography, and Conventions

| Markup                    | Meaning                                               | Example         |
| ------------------------- | ----------------------------------------------------- | --------------- |
| `u8`, `u16`, `u32`, `u64` | Littleâ€‘endian unsigned integers of the stated width   | `0x0100 â†’ 256`  |
| `â‰¡`                       | Congruence *modâ€¯q* unless another modulus is explicit | `aâ€¯â‰¡â€¯bâ€¯(modâ€¯q)` |
| `â€–`                       | Concatenation of byte strings                         | `xâ€–y`           |
| `Î£`, `Î `                  | Fieldâ€‘sum / product in ğ”½\_q (wrap at *q*)            | `Î£_i x_iÂ modâ€¯q` |
| `NTT_k`                   | Lengthâ€‘*k* forward Numberâ€‘Theoretic Transform         | `ntt64()`       |

All integers, vectors, and matrices are interpreted **littleâ€‘endian** unless indicated otherwise.

###â€¯0.2â€ƒDial Parameters

A **dial profile** is an ordered 8â€‘tuple
`(m, k, r, Î», H, Î³, q, Nonce)`:

| Symbol | Description                                | Baseline "Sâ€‘512"                |
| ------ | ------------------------------------------ | ------------------------------- |
| `q`    | Prime field modulus                        | **CRT (Mandatory):** $q_1$=**998â€¯244â€¯353** and $q_2$=**1â€¯004â€¯535â€¯809**. Effective modulus $Q = q_1 \times q_2 \approx 2^{60}$. |
| `Nonce`| Profile Nonce (high-entropy)               | 0x1A2B3C4D5E6F7890AABBCCDDEEFF0011 (example) |
| `k`    | NTT block size (radixâ€‘k)                   | 128                             |
| `r`    | Passes of dataâ€‘dependent permutation       | 3                               |
| `Î»`    | Gaussian noise Ïƒ (compression)             | 350 (fixed-point Ã—100)          |
| `H`    | Argon2â€‘drizzle passes                      | 2                               |
| `Î³`    | Interleave fragment size (MiB)             | 0 (sequential)                  |

Dial parameters are **frozen** per profile string (e.g., `"S-512"`).  Changes introduce a new profile ID (see Â§â€¯6).

###â€¯0.3â€ƒVersion Triple

Every onâ€‘chain 32â€‘byte digest begins with a **version triple**

```
Version = {major : u8 = 0x02, minor : u8 = 0x00, patch : u8 = 0x00}
digest  = Blake2sâ€‘256( Version â€– DomainID â€– payload )
```

* **minor** increments when tuning `k, r, Î», H, Î³`.
* **patch** increments for nonâ€‘semantic errata (typos, clarifications).

###â€¯0.4â€ƒDomain Identifiers

`DomainID : u16` partitions digests by purpose.  Reserved values:

| ID (hex)  | Domain                             | Source section |
| --------- | ---------------------------------- | -------------- |
| Â `0x0000` | Internal primitives                | Â§â€¯2â€“5          |
| Â `0x0200` | PoDE/Derive digest (windowâ€‘local)  | Â§â€¯4            |
| Â `0x0300` | Nilâ€‘VRF transcripts                | Â§â€¯5            |

Further IDs are allocated by Nilcoin governance (informative Appendixâ€¯D).

####â€¯0.4.1â€ƒString Domain Tags (Blake2s separators)

For transparency and auditability, Core defines the following fixed ASCII domain strings used with Blake2sâ€‘256 across modules:

| Tag                  | Purpose                                  | Section    |
| -------------------- | ---------------------------------------- | ---------- |
| `"NIL_VRF_OUT"`     | VRF output compression                    | Â§â€¯5.2      |
| `"NIL_VRF_H2G"`     | VRF hash_to_G2 DST                        | Â§â€¯5.2      |
| `"NIL_BEACON"`      | Epoch beacon derivation from VRF output   | Â§â€¯5.3      |
| `"NilStore-Sample"` | Retrievalâ€‘sampling seed from epoch beacon | Â§â€¯5.7 (new) |
| `"SAMPLE-EXP"`      | PRF expansion for sampling indices        | Â§â€¯5.7 (new) |
| `"DERIVE_SALT_EXP"` | Salt expansion XOF for kâ€‘limbs          | Â§â€¯3.3      |
| `"BATMAN-SHARE"`    | Deterministic shareâ€‘selection label       | Â§â€¯5.4.3    |

###â€¯0.5â€ƒChangeâ€‘Control and Notice

* Parameter changes follow Â§â€¯6 governance rules.
* Implementations **must** reject digests whose version triple or DomainID is unknown at compileâ€‘time.

###â€¯0.6â€ƒReproducibility & Deterministic Build CharterÂ (normative)

* **Public transcripts:** Any claim in Â§Â§â€¯2â€“5,â€¯7 that depends on concrete parameters MUST have a reproducible transcript (JSON/CSV) in the release package (`_artifacts/`), accompanied by `SHA256SUMS`.
* **Pinned inputs:** All randomness derives from fixed domain tags (see Â§â€¯0.4.1) and explicit inputs; scripts MUST use integerâ€‘only operations for consensusâ€‘sensitive calculations.
* **Make target:** Reference repos MUST provide `make publish` that regenerates `_artifacts/*` and `SHA256SUMS` from a clean checkout.


---

## Â§â€¯4â€ƒProofâ€‘ofâ€‘Usefulâ€‘Data (PoUD) & Proofâ€‘ofâ€‘Delayedâ€‘Encode (PoDE)  â€” Normative

###â€¯4.0aâ€ƒDerive (windowâ€‘scoped, normative for PoDE) â€” moved from Â§â€¯3.3.1
Purpose: deterministic, beaconâ€‘salted local transform on a `W`â€‘byte window (default `W = 8â€¯MiB`) recomputable directly from **plaintext** during PoDE; domainâ€‘separated from full sealing; MUST NOT require a sealed replica.

```
Derive(clear_window, beacon_salt, row_id):

1. Partition clear_window into kâ€‘limb chunks (baseline k = 64).
2. For pass = 0..râˆ’1:
   NTT_k(chunk);
   salt_k = SHAKE128("DERIVE_SALT_EXP" â€– beacon_salt â€– u8(pass) â€– u32_le(row_id))[0 .. 4k) as k littleâ€‘endian u32 limbs mod Q;
   for j in 0..kâˆ’1: chunk[j] = (chunk[j] + salt_k[j]) mod Q;
   INTT_k(chunk);
3. Output:
   leaf64 := first 64 bytes postâ€‘transform;
   Î”_W := Blake2sâ€‘256(window postâ€‘transform).

```

**Domain separation (normative):** For PoUD/PoDE usage, salt derivation MUST include `epoch_id` and `du_id` in addition to `beacon_salt` and `row_id`, to prevent crossâ€‘deal replay within the same epoch.


**Definition (baseline):**

```
Derive(clear_window, beacon_salt, row_id, epoch_id, du_id):
  // Domain-separated, stateless transformation for PoDE
  // Implementations MUST publish KATs; reference uses Blake2s-256 only.
  tag = "PODE_DERIVE_V1"
  x = Blake2s-256(tag â€– beacon_salt â€– u32_le(row_id) â€– u64_le(epoch_id) â€– u128_le(du_id))
  // Mix the clear window bytes in fixed-size chunks without secret-dependent branching
  acc = Blake2s-256(tag â€– x â€– clear_window)
  leaf64 := acc[0..64)
  Î”_W := Blake2s-256(clear_window)
  return (leaf64, Î”_W)
```
###â€¯4.0â€ƒObjective & Model

Attest, per epoch, that an SP (a) stores the **cleartext** bytes of their assigned DU intervals and (b) can perform **timed, beaconâ€‘salted derivations** over randomly selected windows quickly enough that fetching from elsewhere is infeasible within the proof window.

**Security anchors:** (i) DU **KZG commitment** `C_root` recorded at deal creation; (ii) BLSâ€‘VRF epoch beacon for unbiased challenges; (iii) onâ€‘chain **KZG multiâ€‘open** preâ€‘compiles; (iv) watcherâ€‘enforced timing digests.

###â€¯4.1â€ƒDU Representation & Commitment

Let a DU be encoded with systematic RS(n,k) over GF(2â¸) and segmented into **1â€¯KiB symbols**. The client computes a **KZG commitment** `C_root` to the RSâ€‘symbol polynomial(s) at deal creation and posts `C_root` on L2; all subsequent storage proofs **must open against this original commitment**.

###â€¯4.2â€ƒChallenge Derivation

For epoch `t` with beacon `beacon_t`, expand domainâ€‘separated randomness to pick `q` **distinct symbol indices** per DU interval and `R` **PoDE windows** of size `W = 8â€¯MiB`. Selection MUST be moduloâ€‘biasâ€‘free.

###â€¯4.3â€ƒProver Obligations per DU Interval

1) **PoUD â€” KZGâ€‘PDP (content correctness):** Provide KZG **multiâ€‘open** at the chosen 1â€¯KiB symbol indices proving membership in `C_root`.
2) **PoDE â€” Timed derivation:** For each challenged window, compute `deriv = Derive(clear_window, beacon_salt, row_id)` and submit `H(deriv)` plus the **minimal** clear bytes for verifier recompute, all **within** the perâ€‘epoch `Î”_submit` window. Enforce **Î£ verified bytes â‰¥ B_min = 128â€¯MiB** over all windows and **R â‰¥ 16** subâ€‘challenges/window (defaults; DAOâ€‘tunable).
   **Normative (PoDE Linkage):** The prover MUST provide a KZG opening proof `Ï€_kzg` demonstrating that the `clear_window` input bytes correspond exactly to the data committed in `C_root`.

###â€¯4.4â€ƒVerifier (Onâ€‘chain / Watchers)

* **Onâ€‘chain:** Verify **KZG multiâ€‘open** against `C_root`; check counters for `R` and `B_min`.
* **Onâ€‘chain (PoDE):** Verify `Ï€_kzg` against `C_root` for the `clear_window`.
* **Watchers:** Verify PoDE recomputations and timing (RTTâ€‘oracle transcripts). Aggregate pass/fail into an onâ€‘chain digest per SP.

###â€¯4.5â€ƒCoverage & Parameters (Auditor math)

Let DU contain **M** symbols. With **q** fresh symbols per epoch over **T** epochs, the chance any symbol is never checked is `M Â· (1 âˆ’ q/M)^T`. Choose `qÂ·T` to push this below Î´ (e.g., 2â»Â¹Â²â¸) for the DU class. Governance publishes defaults and bounds.

###â€¯4.6â€ƒOnâ€‘chain Interfaces (normative)

L1 **MUST** expose: `verify_kzg_multiopen(...)`, `verify_poseidon_merkle(...)`, `blake2s(bytes)`. Proof acceptance window: `T_epoch = 86â€¯400â€¯s`, `Î”_submit = 30â€¯s`. Perâ€‘replica work bound used by timing invariants: `Î”_work = 1â€¯s`.

---

 
