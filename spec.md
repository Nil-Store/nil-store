# Nilcoinâ€¯Coreâ€¯vâ€¯2.0 (â€œqâ‚â€)

### Cryptographicâ€¯Primitives &â€¯Proofâ€¯System Specification

*Publication dateâ€¯â–¢2025â€‘XXâ€‘XX â€“ Council resolutionâ€¯#:â€¯â–¢NCâ€‘2025â€‘07*

---

## AbstractÂ (normative)

Nilcoinâ€¯Core vâ€¯2.0 defines the complete cryptographic foundation for the Nilcoin storageâ€‘based consensus network.â€¯
It specifies, in a fully reproducible manner:

1. **Field & transform algebra** over the 30â€‘bit primeâ€¯$qâ‚ = 998â€¯244â€¯353$;
2. **Nilweave commitment** (`nilhash`) with binding security reducing to SIS;
3. **Sealing codec** (`nilseal`) that enforces sequential replication work;
4. **Proofâ€‘ofâ€‘Spacetimeâ€‘Squared** (`possÂ²`) yielding succinct liveness proofs;
5. **BLSâ€¯VRF** and BATMAN aggregation for unbiased beacons;
6. **Dial policy** and governance process for safe parameter evolution;
7. Formal security rationale under standard assumptions.

All constants are generated by an auditable Python script (Annexâ€¯C), and every algorithm is accompanied by deterministic Knownâ€‘Answer Tests (Annexâ€¯Aâ€“B).Â 
Versionâ€¯2.0 supersedes vâ€¯1.0 and vâ€¯1.0â€‘rcâ€¯series; it MUST be implemented verbatim by mainâ€‘network clients targeting activation heightâ€¯â–¢H\_ACT.

---

## Â§â€¯0â€ƒNotation, Dial Systemâ€¯&â€¯VersioningÂ (â€¯Baselineâ€¯Profileâ€¯â€œSâ€‘512â€â€¯)

\###â€¯0.1â€ƒSymbols, Typography, and Conventions

| Markup                    | Meaning                                               | Example         |
| ------------------------- | ----------------------------------------------------- | --------------- |
| `u8`, `u16`, `u32`, `u64` | Littleâ€‘endian unsigned integers of the stated width   | `0x0100 â†’ 256`  |
| `â‰¡`                       | Congruence *modâ€¯q* unless another modulus is explicit | `aâ€¯â‰¡â€¯bâ€¯(modâ€¯q)` |
| `â€–`                       | Concatenation of byte strings                         | `xâ€–y`           |
| `Î£`, `Î `                  | Fieldâ€‘sum / product in ğ”½\_q (wrap at *q*)            | `Î£_i x_iÂ modâ€¯q` |
| `NTT_k`                   | Lengthâ€‘*k* forward Numberâ€‘Theoretic Transform         | `ntt64()`       |

All integers, vectors, and matrices are interpreted **littleâ€‘endian** unless indicated otherwise.

\###â€¯0.2â€ƒDial Parameters

A **dial profile** is an ordered 8â€‘tuple
`(m, k, r, Î», H, Î³, q, Nonce)`:

| Symbol | Description                                | Baseline "Sâ€‘512"                |
| ------ | ------------------------------------------ | ------------------------------- |
| `q`    | Prime field modulus                        | **998â€¯244â€¯353 (=â€¯119Â·2Â²Â³â€¯+â€¯1)**; optional CRT: **1â€¯004â€¯535â€¯809 (=â€¯479Â·2Â²Â¹+1)** |
| `Nonce`| Profile Nonce (high-entropy)               | 0x1A2B3C4D5E6F7890AABBCCDDEEFF0011 (example) |
| `m`    | Vector length (*nilhash*, PoSSÂ²)           | 1â€¯024                           |
| `k`    | NTT block size (radixâ€‘k)                   | 128                             |
| `r`    | Passes of dataâ€‘dependent permutation       | 3                               |
| `Î»`    | Gaussian noise Ïƒ (compression)             | 350 (fixed-point Ã—100)          |
| `H`    | Argon2â€‘drizzle passes                      | 2                               |
| `Î³`    | Interleave fragment size (MiB)             | 0 (sequential)                  |

Dial parameters are **frozen** per profile string (e.g., `"S-512"`).  Changes introduce a new profile ID (see Â§â€¯6).

\###â€¯0.3â€ƒVersion Triple

Every onâ€‘chain 32â€‘byte digest begins with a **version triple**

```
Version = {major : u8 = 0x02, minor : u8 = 0x00, patch : u8 = 0x00}
digest  = Blake2sâ€‘256( Version â€– DomainID â€– payload )
```

* **major** increments on any change to `q` or `m` (affects SIS hardness).
* **minor** increments when tuning `k, r, Î», H, Î³`.
* **patch** increments for nonâ€‘semantic errata (typos, clarifications).

\###â€¯0.4â€ƒDomain Identifiers

`DomainID : u16` partitions digests by purpose.  Reserved values:

| ID (hex)  | Domain                             | Source section |
| --------- | ---------------------------------- | -------------- |
| Â `0x0000` | Internal primitives                | Â§â€¯2â€“5          |
| Â `0x0100` | nilseal row Merkle roots (`h_row`) | Â§â€¯3            |
| Â `0x0200` | possÂ² window delta proofs          | Â§â€¯4            |
| Â `0x0300` | Nilâ€‘VRF transcripts                | Â§â€¯5            |

Further IDs are allocated by Nilcoin governance (informative Appendixâ€¯D).

\####â€¯0.4.1â€ƒString Domain Tags (Blake2s separators)

For transparency and auditability, Core defines the following fixed ASCII domain strings used with Blake2sâ€‘256 across modules:

| Tag                  | Purpose                                  | Section    |
| -------------------- | ---------------------------------------- | ---------- |
| `"NIL_VRF_OUT"`     | VRF output compression                    | Â§â€¯5.2      |
| `"NIL_VRF_H2G"`     | VRF hash_to_G2 DST                        | Â§â€¯5.2      |
| `"NIL_BEACON"`      | Epoch beacon derivation from VRF output   | Â§â€¯5.3      |
| `"NilStore-Sample"` | Retrievalâ€‘sampling seed from epoch beacon | Â§â€¯5.7 (new) |
| `"SAMPLE-EXP"`      | PRF expansion for sampling indices        | Â§â€¯5.7 (new) |
| `"P2Î”"`             | Deltaâ€‘head binding for PoSÂ²               | Â§â€¯3.7      |
| `"NIL_SEAL_ZETA"`   | Derivation of permutation offset Î¶_p      | Â§â€¯3.4.2    |
| `"POSS2-MIX"`       | Challenge derivation mix domain           | Â§â€¯4.2      |
| `"NILHASH-RANGE"`   | Rangeâ€‘proof transcript tag                | Annexâ€¯A.3  |
| `"NIL_SEAL_PRP"`    | PRP roundâ€‘function key domain             | Â§â€¯3.4.1    |
| `"NIL_SEAL_SALT_EXP"` | Salt expansion XOF for kâ€‘limbs          | Â§â€¯3.3      |
| `"NIL_SEAL_NOISE"`  | Noise RNG domain for Gaussian sampler     | Â§â€¯3.5      |
| `"BATMAN-SHARE"`    | Deterministic shareâ€‘selection label       | Â§â€¯5.4.3    |
| `"PARAMGEN-V1"`     | XOF seed for A/B/twist parameter mixing   | Â§â€¯2.2      |

\###â€¯0.5â€ƒChangeâ€‘Control and Notice

* Parameter changes follow Â§â€¯6 governance rules.
* **Seed/Nonce binding (Normative):** Any change affecting parameter generation (e.g., `A` row, `B` spectrum, spectral twist) MUST include a new highâ€‘entropy Nonce (â‰¥â€¯128â€¯bits, recommended 256â€¯bits) committed onâ€‘chain with the proposal, and all seeds MUST be derived via SHAKE128 with fixed domain tags (see Â§â€¯2.2, tag `"PARAMGEN-V1"`). Reâ€‘using a Nonce across major/minor versions is forbidden.
* Implementations **must** reject digests whose version triple or DomainID is unknown at compileâ€‘time.

\###â€¯0.6â€ƒReproducibility & Deterministic Build CharterÂ (normative)

* **Public transcripts:** Any claim in Â§Â§â€¯2â€“5,â€¯7 that depends on concrete parameters MUST have a reproducible transcript (JSON/CSV) in the release package (`_artifacts/`), accompanied by `SHA256SUMS`.
* **Pinned inputs:** All randomness derives from fixed domain tags (see Â§â€¯0.4.1) and explicit inputs; scripts MUST use integerâ€‘only operations for consensusâ€‘sensitive calculations.
* **Make target:** Reference repos MUST provide `make publish` that regenerates `_artifacts/*` and `SHA256SUMS` from a clean checkout.
* **Estimator evidence (A3):** The Moduleâ€‘SIS security level MUST be justified by a published estimator transcript before mainâ€‘net activation (see Â§â€¯7.2).


---

## Â§â€¯1â€ƒFieldâ€¯&â€¯NTT ModuleÂ (`nilfield`)

\###â€¯1.1â€ƒConstants â€“ Primeâ€¯*qâ‚*â€¯=â€¯998â€¯244â€¯353

| Name     |            Value (decimal) | Hex                | Comment                  |
| -------- | -------------------------: | ------------------ | ------------------------ |
| `Q`      |                998â€¯244â€¯353 | 0x3B800001         | NTT-friendly primeÂ (â‰ˆ2Â³â°)|
| `R`      |                932â€¯051â€¯910 | 0x378DFBC6         | 2â¶â´Â modâ€¯Q                |
| `RÂ²`     |                299â€¯560â€¯064 | 0x11DAEC80         | *RÂ²*Â modâ€¯Q               |
| `Q_INV`  | 17â€¯450â€¯252â€¯288â€¯407â€¯896â€¯063 | 0xF22BC0003B7FFFFF | âˆ’Qâ»Â¹Â modâ€¯2â¶â´             |
| `g`      |                          3 | â€”                  | Generator of ğ”½\*\_Q     |
| `Ïˆ_64`   |                922â€¯799â€¯308 | 0x3700CCCC         | Primitive 64â€‘th root     |
| `Ïˆ_128`  |                781â€¯712â€¯469 | 0x2E97FC55         | Primitive 128â€‘th root    |
| `Ïˆ_256`  |                476â€¯477â€¯967 | 0x1C667A0F         | Primitive 256â€‘th root    |
| `Ïˆ_1024` |                258â€¯648â€¯936 | 0x0F6AAB68         | Primitive 1â€¯024â€‘th root  |
| `Ïˆ_2048` |                584â€¯193â€¯783 | 0x22D216F7         | Primitive 2â€¯048â€‘th root  |
| `64â»Â¹`   |                982â€¯646â€¯785 | 0x3A920001         | For INTT scaling         |
| `128â»Â¹`  |                990â€¯445â€¯569 | 0x3B090001         | â€”                        |
| `256â»Â¹`  |                994â€¯344â€¯961 | 0x3B448001         | â€”                        |
| `1024â»Â¹` |                997â€¯269â€¯505 | 0x3B712001         | â€”                        |
| `2048â»Â¹` |                997â€¯756â€¯929 | 0x3B789001         | â€”                        |

*Origin:* generated verbatim by the normative script in **Annexâ€¯C**.
All reference implementations embed these literals exactly.

\###â€¯1.1.1â€ƒOptional CRT prime qâ‚‚ = 1â€¯004â€¯535â€¯809  (NTTâ€‘friendly)

Constants (Ïˆâ‚–, kâ»Â¹, Montgomery params) for qâ‚‚ are generated by Annexâ€¯C with:

```
python3 appendix_c_constants.py 1004535809 3 > constants_q2.txt
```

Implementations enabling the CRT profile MUST embed the qâ‚‚ constants exactly as emitted and run the KATs in Annexâ€¯A for both primes.

\###â€¯1.2â€ƒAPI Definition (Rust signature, normative)

```rust
pub mod nilfield {
    /* ---------- modulus & Montgomery ---------- */
    pub const Q:      u32 = 998_244_353;
    pub const R:      u32 = 932_051_910;
    pub const R2:     u32 = 299_560_064;
    pub const Q_INV:  u64 = 0xF22BC0003B7FFFFF;

    /* ---------- field ops (constantâ€‘time) ----- */
    pub fn add(a: u32, b: u32) -> u32;   // (a + b) mod Q
    pub fn sub(a: u32, b: u32) -> u32;   // (a âˆ’ b) mod Q
    pub fn mul(a: u32, b: u32) -> u32;   // Montgomery product
    pub fn inv(a: u32) -> u32;           // aâ»Â¹ mod Q (Fermat)

    /* ---------- radixâ€‘k NTT ------------------- */
    pub fn ntt64(f: &mut [u32; 64]);     // forward DIF, inâ€‘place
    pub fn intt64(f: &mut [u32; 64]);    // inverse DIT, scaled 1/64
}
```

Implementations **shall** provide equivalent APIs in other languages.

\###â€¯1.3â€ƒConstantâ€‘Time Requirement (normative, microâ€‘arch aware)

All `nilfield` functions operating on secret data **must** execute in time independent of their inputs and **must not** perform secretâ€‘dependent memory accesses or controlâ€‘flow.

**Rules (normative):**
1) **No secretâ€‘dependent branches** (including early returns), **no secretâ€‘dependent table lookups**, **no secretâ€‘dependent memory addresses**.
2) **Fixed operation counts**: loops and iteration counts must be independent of secret values.
3) **Instruction selection**: avoid variableâ€‘latency divisions; inversion `inv(a)` **must** use a fixedâ€‘window addition chain or slidingâ€‘window exponentiation with constantâ€‘time selection (no dataâ€‘dependent table indices).
4) **Montgomery core**: `mul`/`REDC` must use only integer ops; final conditional subtraction must be implemented with constantâ€‘time bitâ€‘masking (no branches).
5) **Tooling gates (required)**:
   â€¢ **ctgrind**: zero findings;  
   â€¢ **dudect**: Welchâ€™s *t*â€‘test |t| â‰¤â€¯4.5 on â‰¥â€¯2Â²â° traces at 3â€¯GHz equivalent;  
   â€¢ **llvmâ€‘mca (or objdump review)**: verify no dataâ€‘dependent instructions (DIV/MOD) in secretâ€‘handling code paths;  
   â€¢ **cacheâ€‘flow audit**: static check that all memory indices in secret code are public.
6) **Build flags**: enable constantâ€‘time codegen (e.g., `-fno-builtin-memcmp` or constantâ€‘time intrinsics) and pin target CPU features in CI.

**Documentation**: Reference implementations MUST include a short writeâ€‘up explaining how each rule is met in `nilfield`, especially for `inv(a)`.

\###â€¯1.4â€ƒRadixâ€‘*k* NTT Specification

* The forward transform `ntt_k` is a breadthâ€‘first DIF algorithm using `Ïˆ_k` twiddles; input and output are in natural order.
* The inverse transform `intt_k` is DIT with twiddles `Ïˆ_kâ»Â¹`.
* Postâ€‘inverse scaling multiplies every coefficient by `kâ»Â¹Â modâ€¯Q`.
* For `kâ€¯âˆˆâ€¯{64,128,256,1024,2048}` the corresponding `Ïˆ_k` **must** be used; extending to higher powers of two requires governance approval (Â§â€¯6).

**Memory layout:** vectors are contiguous arrays of `u32` littleâ€‘endian limbs.  No bitâ€‘reversal copy is permitted outside the NTT kernels.

**Knownâ€‘Answer Tests:** Annexâ€¯A.1 & A.2 contain roundâ€‘trip vectors
`[1,0,â€¦]Â â†’Â NTTÂ â†’Â INTTÂ â†’Â [1,0,â€¦]` for every supportedÂ *k*.

\###â€¯1.5â€ƒImplementation Guidance (with constantâ€‘time WASM/MCU profile)

* Preferred: 32Ã—32â†’64 **Montgomery** multiply + `REDC` using only integer ops. On 32â€‘bit targets, use twoâ€‘limb decomposition to synthesize 64â€‘bit products in constant time.
* **WASM (wasm32):** require native `i64` support; **asm.js** fallbacks or FP must not be used. Constantâ€‘time **Barrett** is permitted with Î¼ = âŒŠ2â¶â´/qâŒ‹ and all reductions implemented without division and without secretâ€‘dependent branches. Implementations MUST ship KATs demonstrating equality with Montgomery on the same inputs.
* **Environment probes (normative):** at startup, assert (a) twoâ€™sâ€‘complement integers, (b) 32â€‘ and 64â€‘bit widths as specified, (c) native 64â€‘bit integer ops available. Otherwise, **disable sealing** and expose a conformance error.
* Inline `kâ»Â¹` scaling into the last butterfly stage to save one loop **only** if the fused code path preserves constantâ€‘time guarantees above.

---

---

## Â§â€¯2â€ƒNilâ€‘Latticeâ€¯HashÂ / â€œNilweaveâ€Â (`nilhash`)

\###â€¯2.0â€ƒScope

`nilhash` is Nilcoinâ€™s *vectorâ€‘commitment* primitive.Â It maps an arbitraryâ€‘length byte string to an **mâ€‘limb vector**â€¯`hâ€¯âˆˆâ€¯ğ”½_q^m` (baselineâ€¯*mâ€¯=â€¯1â€¯024*) andâ€”optionallyâ€”into a fixedâ€‘size onâ€‘chain digest.Â Security reduces to the hardness of the *Shortâ€‘Integerâ€‘Solution* (SIS) problem over ğ”½\_q; the reduction appears in Â§â€¯7.3.

---

\###â€¯2.1â€ƒMessageâ€¯â†’â€¯Vector Injection (â€œSVTâ€¯orderâ€)

\####â€¯2.1.1â€ƒPadding

```
msg' = |len_u64|_LE  â€–  msg  â€–  0x80  â€–  0x00 â€¦           // pad to even length
```

* `|len_u64|` is the original message length in **bytes**.
* Append `0x80`, then zeroâ€‘bytes until `len(msg')` is even (â‰¥â€¯8â€¯+â€¯|msg|â€¯+â€¯1).
  *(ISO/IECâ€¯9797â€‘1 schemeâ€¯1 adapted to 16â€‘bit limbs.)*

\####â€¯2.1.2â€ƒLimb parsing

`x_raw`Â =Â `msg'` parsed as littleâ€‘endian 16â€‘bit limbs
`x_rawÂ =Â [xâ‚€,Â xâ‚,Â â€¦,Â x_{Lâˆ’1}]` with `LÂ =Â len(msg')/2`.

If `Lâ€¯>â€¯m`â€ƒâ†’â€ƒ**reject** (â€œmessage too long for profileâ€).
If `Lâ€¯<â€¯m` pad the tail with zeros.

\####â€¯2.1.3â€ƒSVT order (strideâ€‘vectorâ€‘transpose)

Let `B = m / k` blocks (baseline `kÂ =Â 64`, `BÂ =Â 16`).
Conceptually arrange the limb array as a **kâ€¯Ã—â€¯B** rowâ€‘major matrix

```
Row r (0 â€¦ k-1) :  x_raw[rÂ·BÂ +Â c] ,  c = 0 â€¦ B-1
```

**SVT order** is the **columnâ€‘major readâ€‘out** of this matrix:

```
SVT(x_raw)[ i ] = x_raw[ (i mod k) Â· B  +  âŒŠi / kâŒ‹ ] ,  0 â‰¤ i < m.
```

Intuition: every NTT block (row) receives one limb from each stride column, maximising interâ€‘block diffusion.

---
\###â€¯2.2â€ƒAlgorithmsÂ (revised)

> **Public parameters** (fixed per dial profile, derived in Annexâ€¯C)
>
> * **Hash Function H (Normative):** All parameter generation MUST use SHAKE128 as an Extendable Output Function (XOF).
> * **Uniform Sampling (Normative):** All sampling modulo q MUST use uniform rejection sampling (no moduloâ€‘bias), with statistical distance from uniform < 2^-128.
> * **Nonce requirements (Normative):** `Nonce` MUST be â‰¥â€¯256â€¯bits of minâ€‘entropy and derived from a **multiâ€‘party commitâ€‘reveal**: (i) at least 3 independent contributors post 256â€‘bit commits onâ€‘chain, (ii) after `H_commit+K` blocks, each reveals; (iii) the chain adds a fixedâ€‘height block hash `B*`. The profile `Nonce = SHAKE128("PARAMGEN-V1" â€– commits â€– reveals â€– B*)`. Any missing reveal is treated as allâ€‘zero.
> * **Seed mixing (Normative, strengthened):** All perâ€‘object seeds for parameter generation MUST be drawn from a master XOF stream

>   `seed = SHAKE128("PARAMGEN-V1" â€– Version â€– DID â€– Nonce â€– GovProposalHash â€– CRS_commit â€– CRS_reveal)`

>   with the following requirements:
>   1) `GovProposalHash` = Blake2sâ€‘256 of the governance proposal object that introduces the dial/profile change (hashâ€‘pinned onâ€‘chain at proposal open);
>   2) `CRS_commit` / `CRS_reveal`: a *threshold* (â‰¥â€¯tâ€‘ofâ€‘n) commitâ€‘reveal from independent parties (e.g., Council, TC, External Auditor) posted on L1, where *any* missing reveals are replaced by the precommitted VRF transcript `vrf_beacon_paramgen` from the epoch of activation (to prevent stalling);
>   3) All subâ€‘seeds MUST include **explicit domain strings** unique per artifact:
>
>      `H("A-seed"â€–Versionâ€–DIDâ€–Nonceâ€–GovProposalHashâ€–CRS_commitâ€–CRS_reveal)`,  
>      `H("B-spectrum"â€–Versionâ€–DIDâ€–Nonceâ€–GovProposalHashâ€–CRS_commitâ€–CRS_revealâ€–j)`,  
>      `H("twist"â€–Versionâ€–DIDâ€–Nonceâ€–GovProposalHashâ€–CRS_commitâ€–CRS_revealâ€–j)`.
>
>   Reâ€‘using `Nonce` or `GovProposalHash` across major/minor versions is forbidden. Implementations MUST serialize and store the full paramgen transcript for audit.
>   **Grinding prohibition:** the ceremony and transcript MUST ensure no single party can bias `A`, `B`, or the perâ€‘domain twist values.
> * Circulant matrix **A** generated from first row `Î±` (derived via H("A-seed"â€–Versionâ€–DIDâ€–Nonce)).
> * Independent circulant matrix **B**: sample $\widehat b_j$ uniformly from ğ”½_q using H("B-spectrum"â€–Versionâ€–DIDâ€–Nonceâ€–j) until nonâ€‘zero; set **b_vec = INTT( \widehat b )**.   // renamed to avoid collision with the râ€‘bound Î²
> * **Spectral Checks (Normative):**
>   1) **B invertibility:** every NTT coefficient of $\widehat b$ MUST be nonâ€‘zero (det(B) â‰  0) **and** the minimal polynomial of $\widehat b$ over ğ”½_q MUST have no factors of order â‰¤ 2Â¹â¶. Reâ€‘sample on failure.
>   2) **A robustness:** the NTT of the first row of A, $\widehat Î±$, MUST pass the same minimalâ€‘polynomial filter (no smallâ€‘order factors); additionally, every coefficient of $\widehat Î±$ MUST be nonâ€‘zero.
>   3) **Coâ€‘primeness:** for all indices j, **gcd**$(\widehat Î±_j, \widehat b_j, q)=1$ (i.e., $(A,B)$ have no shared lowâ€‘order spectral factors). Reâ€‘sample on failure.
> * Perâ€‘domain **spectral twist** **D^(DID)**: sample $d_j$ uniformly from ğ”½_q using H("twist"â€–Versionâ€–DIDâ€–Nonceâ€–j), reâ€‘draw zeros. Apply as a diagonal in NTT space on the AÂ·x path.

| Function      | Signature                                                                  | Definition |
| ------------- | ---------------------------------------------------------------------------- | ---------- |
| **commit**    | `fn commit(DID, msg, rng) â†’ h: [u32; m]{Ã—CRT}`                                | Prover samples `r â† D_Ïƒ` with `||r||_âˆ â‰¤ Î²` (constantâ€‘time), computes `h = (A_twistedÂ·x) + (BÂ·r)`, and retains `(r, Ï€)` privately. |
| **open**      | `fn open(msg, r, Ï€) â†’ (msg, r, Ï€)`                                          | Output the original message, blinding vector `r`, and its boundâ€‘proof `Ï€`. The sampling of `r` MUST be constantâ€‘time. |
| **verify**    | `fn verify(h, msg, r, Ï€) â†’ bool`                                             | Recompute `x` and twist; check `h == A_twistedÂ·x + BÂ·r` per prime; verify `Ï€`. |
| **update**    | *unchanged* (requires reâ€‘commit)                                            | Any change to `msg` or `r` requires a fresh `commit`. |
| **aggregate** | `Î£_field`                                                                    | Componentâ€‘wise addition of commitment vectors. |

*Complexity* â€“ Commit/Verify: unchanged NTT count (perâ€‘prime); proof adds O(logâ€¯m) time and ~2â€¯kB to the opening object.
*Security* â€“ **Binding** reduces to Moduleâ€‘SIS on the kernel of `(Aâ€–B)` with a **short** witness (bounded `Î”x,Î”r`). **Hiding (Normative):** Introduce **Ïƒ_r** (stdâ€‘dev of the discrete Gaussian for `r`). The dial profile MUST specify `(Î², Ïƒ_r)` such that the distinguishing advantage of any PPT adversary between `A_twistedÂ·x + BÂ·r` and uniform is â‰¤â€¯2â»Â¹Â²â¸. A sufficient **and auditable** condition is:

`Î” â‰¤ Â½ Â· sqrt( q^m / 2^{H_âˆ(r)} )  +  m Â· Pr[|D_Ïƒ| > Î²]  + Îµ_hash  â‰¤  2â»Â¹Â²â¸`

where `H_âˆ(r) = mÂ·logâ‚‚(2Î²+1)` (for truncated symmetric noise). Implementations MUST:
(i) compute and publish the bound `Î”` for the active profile;
(ii) include a KAT demonstrating `H_âˆ(r)` and tailâ€‘bound settings that meet `Î” â‰¤ 2â»Â¹Â²â¸` at `m=1024`;
(iii) **Mainâ€‘net profiles MUST enable CRT (qâ‚Ã—qâ‚‚)** unless an equivalently strong bound is shown for singleâ€‘prime mode. (CRT lifts `H_âˆ(r)` additively and lowers `Î”`.)

> **Note:** Attributeâ€‘selective openings will appear in vâ€¯2.1 using a zeroâ€‘knowledge innerâ€‘product argument.  For vâ€¯2.0 all openings disclose the entire message.

\####â€¯2.2.1â€¯Â KAT impact

Note: Knownâ€‘Answer Tests updated in Annexâ€¯A.3.


---

\###â€¯2.3â€ƒOnâ€‘Chain Digest Format

```
commit_digest =
    Blake2sâ€‘256( Version â€– DomainID â€– h^{(1)} â€– [h^{(2)}] )   // 32â€¯bytes
// If CRT enabled, **both** vectors MUST be included in the digest input and in every `verify` computation; openings MUST satisfy the relation in **each** prime separately. The primes qâ‚ and qâ‚‚ MUST be coâ€‘prime. No perâ€‘prime truncation or mixing is permitted.

where  Version  = {0x02,0x00,0x00}
       DomainID = 0x0000  (internal primitive namespace)
```

The entire vectorÂ `h` (2â€¯KiB baseline) **must** be supplied in calldata when `Version.major` increases; otherwise the 32â€‘byte digest is sufficient.

---

\###â€¯2.4â€ƒWorked Example (Baseline â€œSâ€‘512â€)

Input: empty string `""`, `DID = 0x0000`.

| Step              | Result (hex, littleâ€‘endian)       |
| ----------------- | --------------------------------- |
| `h` (1â€¯024 limbs) | `f170â€¯75ceâ€¯9788â€¯65d7 â€¦ c386â€¯7881` |
| `commit_digest`   | `af01â€¯c186â€¯â€¦â€¯e3d9â€¯990d` (32â€¯B)    |

*The complete vector and digest appear in Annexâ€¯A.3 as KATÂ `nilhash_empty`.*

Note (CRT mode): When the optional CRT prime `qâ‚‚` is enabled, an additional vector `h^{(2)}` is computed identically over `qâ‚‚`, and `commit_digest` hashes the concatenation `h^{(1)} â€– h^{(2)}` (see Â§â€¯2.3). Numeric vectors shown here are for the baseline singleâ€‘prime profile â€œSâ€‘512â€.

---

\###â€¯2.5â€ƒParameterisation & Extensibility

* Increasing `m` or changing `q`Â â†’ **major** version bump (Â§â€¯0.3).
* Tuning `k` or replacing `Î±` with a higherâ€‘order root (e.g., `Ïˆ_128`)
  â†’ **minor** bump; implementers must regenerate the *A* row using Annexâ€¯C.

---

\###â€¯2.6â€ƒImplementation Notes (informative)

* **Vectorised FFT:** two 64â€‘point NTTs fit in AVXâ€‘2 registers; unroll eight butterflies per stage for maximum ILP.
* **Memoryâ€‘hard variants:** set `kâ€¯=â€¯256` and keep `Bâ€¯=â€¯m/k` fixed to quadruple cache footprint.
* **Open/verify kernels:** the circulant property lets one reuse a single 64â€‘point NTT per dotâ€‘product.

---


---

## Â§â€¯3â€ƒSealingâ€¯CodecÂ (`nilseal`)

\###â€¯3.0â€ƒScopeâ€¯&â€¯ThreatÂ Model

`nilseal` transforms a minerâ€‘supplied **sector**â€”an opaque byte array of size
`Sâ€¯=â€¯2^n`â€¯bytes, *nâ€¯â‰¥â€¯26* (â‰¥â€¯64â€¯MiB)â€”into a **replica** that:

1. **Binds storage**â€ƒReproducing the replica from the clear sector and secret key takes â‰¥â€¯`t_recreate_replica` seconds (Â§â€¯6).
2. **Hides data**â€ƒThe replica is computationally indistinguishable from uniform given only public parameters and the minerâ€™s address.
3. **Supports proofs**â€ƒIt yields *row commitments* `h_row` and *delta heads* `delta_head` consumed by the Proofâ€‘ofâ€‘Spacetimeâ€‘Squared protocol (Â§â€¯4).

Adversary capabilities: unbounded offline preâ€‘computation, full control of public parameters, but cannot learn the minerâ€™s VRF secret key `sk`.

\###â€¯3.1â€ƒSymbolÂ Glossary (dial profile â€œSâ€‘512â€)

| Symbol   | Type / default | Definition                                |
| -------- | -------------- | ----------------------------------------- |
| `S`      | 32â€¯GiB         | Sector size (benchmark)                   |
| `row_i`  | `u32`          | `BLAKE2s-32(sector_idâ€–sector_digest) mod rows`, where `sector_id = BLAKE2s-256(miner_addrâ€–sector_number)` |
| `salt`   | `[u8;32]`      | `vrf(sk, row_i)`                          |
| `chunk`  | `[u32;k]`      | Radixâ€‘*k* NTT buffer (*kÂ =Â 64*)           |
| `pass`   | `0 â€¦ râˆ’1`      | Permutation round (*rÂ =Â 3*)               |
| `Î¶_pass` | `u32`          | Round offset (dataâ€‘dependent)             |
| `Î»`      | 280            | Gaussian Ïƒ (noise compression, fixedâ€‘point Ã—100) |
| `Î³`      | 0              | MiB interleave fragment size              |

\###â€¯3.2â€ƒPreâ€‘Processing â€“ Argon2 â€œDrizzleâ€

If `HÂ =Â 0`â€ƒâ†’â€ƒskip.
Else perform `H` inâ€‘place passes of **Argon2id** on the sector:

```
argon2id(
    pwd   = sector_bytes,          // streaming mode
    salt  = salt,                  // 32 B
    mem   = âŒˆS / 1â€¯MiBâŒ‰  Kib,
    iters = 1,
    lanes = 4,
    paral = 2
)
```

Each 1â€¯MiB Argon2 block XORs back into its original offset.  This yields a *memoryâ€‘hard* whitening keyed by the miner.

\###â€¯3.3â€ƒRadixâ€‘k Transform Loop

Let `N_chunks = S / (2Â·k)` littleâ€‘endian 16â€‘bit chunks.

For `pass = 0 â€¦ râˆ’1` (baselineÂ `rÂ =Â 3`):

1. **Chunk iteration order** â€“ determined by the **dataâ€‘dependent PRP permutation** (3.4).

2. **NTT pipeline**

   ```
   NTT_k(chunk)                    // forward DIF
   // Derive perâ€‘pass salt limbs (deterministic, domainâ€‘separated)
   salt_k = SHAKE128("NIL_SEAL_SALT_EXP" â€– salt â€– u8(pass))[0 .. 4k) as k littleâ€‘endian u32 limbs mod Q
   for j in 0..k-1:
       chunk[j] = chunk[j] + salt_k[j]   mod Q
   INTT_k(chunk)                   // inverse DIT, scaled kâ»Â¹
   ```
**Rationale:** Salt is added in the frequency domain (after the NTT) to ensure its influence is uniformly diffused across all output limbs following the inverse transform, rather than being localized.

3. **Interleaved write**

   *If* `Î³ = 0`â€ƒâ†’â€ƒwrite back to original offset.
   *Else* compute `stride = Î³â€¯MiB / (2Â·k)` and write chunk to
   `offset = (logical_index â‹… stride)Â modÂ N_chunks`.

\###â€¯3.4â€ƒDataâ€‘Dependent PermutationÂ (normative)

\####â€¯3.4.1â€ƒPermutation map (PRP) â€” normative

Index chunks by linear index `i âˆˆ [0, N_chunks)`. The PRP MUST be a **10â€‘round Feistel network** keyed by `Î¶_p` over the domain `M = N_chunks`. Because `S = 2^n` and chunk size is fixed, `N_chunks` is a power of two; thus `M` is exact and **no cycleâ€‘walk is performed**. Round function:

```
F(round, halfword, Î¶_p) :=
    BLAKE2s-256(
        "NIL_SEAL_PRP" â€– u32_le(M) â€– u8(round) â€– u32_le(Î¶_p) â€– u32_le(halfword)
    )[0..4) as littleâ€‘endian u32, then masked to halfâ€‘width
```

Operate on `w = ceil_log2(M)` bits split into equal halves; mask outputs to the halfâ€‘width each round. Let `Feistel_M(x)` be the 10â€‘round Feistel permutation on `[0, M)`.

Implementations MUST reject `N_chunks = 0`. Roundâ€‘trip vectors appear in Annexâ€¯A (`nilseal_prp.toml`).

\####â€¯3.4.2â€ƒRoundâ€‘offset Î¶<sub>pass</sub>

For `p = 0`, define:
`Î¶_0 = littleâ€‘endian 32 bits of BLAKE2s-256("NIL_SEAL_ZETA" â€– salt â€– u8(0) â€– sector_digest)`.

After finishing pass `pâˆ’1`, compute a digest of the entire pass's data that is sensitive to chunk order.

`ChunkHashes_{p-1} = [Blake2sâ€‘256(chunk_0^{p-1}), Blake2sâ€‘256(chunk_1^{p-1}), ...]`
`ChunkDigest_{p-1} = MerkleRoot(ChunkHashes_{p-1})`
`Î¶_p = littleâ€‘endian 32 bits of BLAKE2s-256( "NIL_SEAL_ZETA" â€– salt â€– p â€– ChunkDigest_{p-1} )`

**Normative (Data Integrity):** `ChunkHashes_{pâˆ’1}` MUST commit to the exact byte sequence of pass `pâˆ’1`; the method of obtaining those bytes (disk, cache, or RAM) is implementationâ€‘defined and outside consensus.

 

**Baseline profile (Normative):** The network baseline is profile *Sâ€‘512* with **Hâ€¯=â€¯2** (CPU/memoryâ€‘hard). Alternative dial profiles listed in Â§â€¯6.6 are acceptable for possÂ² (Â§â€¯4.5).

 

**Canonical sector identifier:** Replace filesystem `path` in all salts and indices with a canonical `sector_id = Blake2s-256(miner_addr â€– sector_number)` to prevent minerâ€‘chosen paths from influencing Î¶ derivation.



**Rationale:** Using a Merkle root instead of a simple sum ensures that `ChunkDigest` depends on the precise ordering of all chunks written in the previous pass, not just their content.

RoundÂ `p` traverses chunks in the order determined by the PRP defined in Â§â€¯3.4.1 using the computed `Î¶_p`.

*Security intuition* â€“ Î¶<sub>p</sub> is **unknowable** until all writes of
passâ€¯`pâˆ’1` complete, enforcing sequential work (Â§â€¯7.4.1).

\####â€¯3.4.3â€ƒMicroâ€‘seal profile (derivation mode, normative dial)

Dial `micro_seal` controls localized sealing for derivation challenges. When `micro_seal = off` (baseline Sâ€‘512), the permutation and Î¶â€‘derivation operate over the entire sector as specified in Â§â€¯3.4.1â€“Â§â€¯3.4.2.

When `micro_seal = row` (optional profile for PoDE enablement), the sealing transform is localized per 2â€¯MiB row tile:

- Domain separation: All Blake2s invocations used to derive PRP keys and Î¶ include the row index `i` as an explicit littleâ€‘endian field.
- PRP scope: The Feistel permutation in Â§â€¯3.4.1 is applied over the set of chunk indices belonging to row `i` only; no cycleâ€‘walk is introduced.
- Î¶ derivation: Replace `Î¶_p` with `Î¶_{p,i} := BLAKE2s-256("NIL_SEAL_ZETA" â€– salt â€– u8(p) â€– u32_le(i) â€– ChunkDigest_{p-1,i})[0..4)` using the Merkle root restricted to row `i`.

This dial is intended solely to enable fast, rowâ€‘local derivations required by Â§â€¯4.2.2 without altering baseline Sâ€‘512 behavior. Profiles enabling `micro_seal = row` MUST publish Annex A/B KATs showing identical digest roots to baseline for `micro_seal = off` when Â§â€¯4 is not in linking/derivation mode.

\###â€¯3.5â€ƒGaussianâ€¯Noise Compression

For every 2â€¯KiB window **W** (postâ€‘transform):

```
Ïƒ_Q_100 = âŒŠ100 Â· Q / âˆš12âŒ‹             // stdâ€‘dev of uniform limb (fixedâ€‘point approximation)
W' = Quantize( W + N(0, (Î»Â·Ïƒ_Q_100 / 10000)Â²) )
```

*Quantize* rounds to the nearest valid limb modâ€¯`Q`. Noise MUST be generated by a deterministic, constantâ€‘time sampler (e.g., Knuthâ€‘Yao or fixedâ€‘point Ziggurat) using only integer arithmetic to ensure crossâ€‘platform consensus.
**Normative (RNG & determinism):** The samplerâ€™s pseudorandom stream MUST be derived from SHAKE128 with tag `"NIL_SEAL_NOISE"` and inputs `(sector_digest, row_index, pass, window_index)` using **u64 counterâ€‘mode expansion** starting at counter=0.
**Integerâ€‘only & UBâ€‘free:** Implementations MUST use twoâ€™sâ€‘complement integers with fixed widths, no floating point, no signed overflow (use widening 64â€‘bit intermediates), and no implementationâ€‘defined shifts.
**Constantâ€‘time:** Samplers MUST NOT branch on secret values and MUST consume the full stream (masking) even if rejection occurs.
**Normative (Quantize tieâ€‘break):** When rounding halfway cases, implementations MUST use tiesâ€‘toâ€‘even on the integer preimage before reduction mod `Q` to avoid platform drift. Provide a reference integer pseudocode and KATs to ensure crossâ€‘platform agreement.
**Sampler conformance (Normative):** Implementations MUST use a tableâ€‘driven constantâ€‘time method (aliasâ€‘table, Knuthâ€“Yao, or fixedâ€‘point Ziggurat) with precomputed CDF tables baked into KATs. Include KATs for: (i) first 4 CTR blocks of the XOF stream per `(row,window,pass)`; (ii) histogram Ï‡Â² bounds over 2Â²â° samples; (iii) endâ€‘toâ€‘end determinism across bigâ€‘endian/littleâ€‘endian targets.

\###â€¯3.6â€ƒRow Merkle Tree (PoSÂ²) & Checkpointing

* **Row tree (PoSÂ²):** Leaves are the 64â€‘byte slices within a 2â€¯MiB row. Each leaf is `Blake2sâ€‘256( 0x00 â€– leaf64 )`; internal nodes are `B2s( 0x01 â€– L â€– R )`. The root of rowâ€¯*i* is `h_row[i]` (DomainIDÂ `0x0100`). This tree yields 15 siblings per path (binary).
* **Checkpoint tree (informative):** Implementations MAY additionally maintain a coarser tree over 2â€¯MiB slices for crashâ€‘resume. This checkpoint tree is not used for `h_row` or `possÂ²` verification.

\###â€¯3.7â€ƒDeltaâ€‘Row Accumulator

/* Replaced homomorphic limb sum with collisionâ€‘resistant digest. */
During compression the encoder computes a digest for each 2â€¯MiB row. For rowâ€¯*i* (two windows):

```
Î”_row[i] = Blake2s-256( W_{2i} â€– W_{2i+1} )
delta_head[i] = Blake2s-256("P2Î”" â€– i â€– h_row[i] â€– Î”_row[i])    // DomainID 0x0200
```

Tuple `(h_row[i], delta_head[i])` is written to the **Rowâ€‘Commit file** that will be posted onâ€‘chain after sealing.

\###â€¯3.7.1â€ƒOrigin Map (rowâ†’DU binding, normative)

For each row `i` the encoder MUST record an `OriginEntry`:

```
OriginEntry := { row_id = i, du_id, sliver_index, symbol_range, C_root }
```

where `C_root` is the DU KZG commitment recorded at deal creation and
`symbol_range` encodes the contiguous 1â€¯KiB RS symbols from the sliver that occupy row `i`.
All `OriginEntry` objects MUST be Poseidonâ€‘Merkleized into `origin_root`.

Normative: The sealer MUST output the tuple `(h_row_root, delta_head_root, origin_root)`
for onâ€‘chain posting. Any PoSÂ² proof MAY be required to include a Merkle proof
from `origin_root` for the challenged row (see Â§â€¯4.2.1).

\###â€¯3.8â€ƒReference EncoderÂ (pseudocode)

```rust
fn seal_sector(path, sector_bytes, miner_sk, params) {
    let sector_digest = blake2s256(sector_bytes);
    let sector_id = blake2s256(miner_addr || sector_number);
    let row_i = blake2s32(sector_id || sector_digest) % rows;
    let salt  = vrf(miner_sk, row_i);                 // 32 B

    argon2_drizzle_if(params.H, sector_bytes, salt);

    for pass in 0..params.r {
        let Î¶ = compute_offset(pass, salt, sector_bytes);
        for (idx, chunk) in iter_chunks(params.k, Î¶, sector_bytes) {
            ntt_k(chunk);
            add_salt(chunk, &salt, params.Q);
            intt_k(chunk);
            interleave_write(chunk, idx, params.Î³, sector_bytes);
        }
    }
    gaussian_compress(sector_bytes, params.Î», params.Q);
    build_merkle_and_rowcommit(sector_bytes, salt, path);
}
```

\###â€¯3.9â€ƒDial GuardrailsÂ (normative limits)

| Dial | Range         | Complexity effect | Guardâ€‘rail                            |
| ---- | ------------- | ----------------- | ------------------------------------- |
| `k`  | 64â€¯â†’â€¯256      | CPUâ€¯âˆâ€¯kâ€¯logâ€¯k     | `k â‰¤ 256` fits L3 cache               |
| `r`  | 2â€¯â†’â€¯5         | Timeâ€¯âˆâ€¯r          | Seal time â‰¤â€¯2Ã— network median         |
| `Î»`  | 280â€¯â†’â€¯500     | Diskâ€¯â†‘            | Î»â€¯>â€¯400 requires compressionâ€‘ratio vote |
| `m`  | 1â€¯024â€¯â†’â€¯2â€¯048 | CPUâ€¯âˆâ€¯mÂ²          | Proof size constant                   |
| `H`  | 0â€¯â†’â€¯2         | DRAMâ€¯Ã—â€¯H          | H â‰¤â€¯2                                 |
| `Î³`  | 0â€¯â†’â€¯4â€¯MiB     | Seeksâ€¯â†‘           | Î³â€¯>â€¯0 needs HDDâ€‘impact vote           |

Profiles violating a guardâ€‘rail are **invalid** until approved by governance (Â§â€¯6).

---

\###â€¯3.10â€ƒPerformance Targets (baseline hardware, informative)

| Task                   | 4Ã— SATA SSD | 8â€‘core 2025 CPU |
| ---------------------- | ----------- | --------------- |
| Seal 32â€¯GiB            | â‰¤â€¯8â€¯min     | â‰¤â€¯20â€¯min        |
| Reâ€‘seal from last leaf | â‰¤â€¯1â€¯min     | â‰¤â€¯3â€¯min         |

---

\###â€¯3.11â€ƒSecurity References

Detailed proofs for sequentialâ€‘work and indistinguishability appear in Â§â€¯7.4.

---

*Sectionâ€¯Â§â€¯4 describes the Proofâ€‘ofâ€‘Spacetimeâ€‘Squared protocol that consumes `h_row` and `delta_head` produced here.*


---

## Â§â€¯4â€ƒProofâ€‘ofâ€‘Spacetimeâ€‘SquaredÂ (`possÂ²`)

\###â€¯4.0â€ƒObjectiveÂ &Â SecurityÂ Model

`possÂ²` is Nilcoinâ€™s onâ€‘chain **storageâ€‘liveness** protocol.Â For each epochÂ `t` it forces a miner to:

1. prove that an *authenticated replica* (sealed in Â§â€¯3) **still exists on local disk**, and
2. spend â‰¥â€¯`Î”/5` wallâ€‘clock time (governance parameter) per replica to recompute it, thus preventing â€œlazyâ€ proofs.

Soundness relies on:

* The sequentialâ€‘work bound of `nilseal` (dataâ€‘dependent PRP permutation, Â§â€¯7.4.1).
* Collision resistance of Blake2sâ€‘256 and the Merkle tree.
* The row digest commitment (`delta_head`, Â§â€¯3.7).

\###â€¯4.1â€ƒReplicaâ€¯LayoutÂ (â€œRow/Column Modelâ€)

* `S`â€ƒâ€ƒâ€ƒÂ Sector size (bytes)
* `rows`â€ƒÂ `= S / 2â€¯MiB`Â Â Â Â Â Â Â Â Â Â Â Â Â (Row height fixed to 2â€¯MiB)
* `cols`â€ƒÂ `= 2â€¯MiB / 64â€¯B = 32â€¯768`Â (Each 64â€‘byte leaf index within a row)
* `window`Â `= 1â€¯MiB`Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â (Proof reads 8 adjacent windows, â‰¤â€¯6â€¯MiB)

A miner sealingÂ `S = 32â€¯GiB` obtains:

```
rows = 16â€¯384      (indexed 0 â€¦ 16â€¯383)
cols = 32â€¯768      (indexed 0 â€¦ 32â€¯767)
```

RowÂ `i` has two 1â€¯MiB windows **Wâ‚‚i** and **Wâ‚‚i+1**; their Merkle root is `h_row[i]`.  Their digest `Î”_row[i] = Blake2sâ€‘256(Wâ‚‚i â€– Wâ‚‚i+1)` is committed as `delta_head[i]` (Â§â€¯3.7).
**Merkle arity (normative option):** Implementations MAY use a higherâ€‘arity (e.g., 16â€‘ary) tree to reduce path length; if so, the sibling count and witness encoding MUST be reflected in Â§â€¯4.3.1 and AnnexÂ B KATs.

**Informative (relationship to NilFS shards).** Reedâ€“Solomon shards (metaspec Â§3.2) are **dataâ€‘layer** units that determine where bytes live on the network. After a shard reaches an SP, the shardâ€™s bytes are sealed into **sectors** and committed per this section. PoSÂ² operates on the sealed sectorâ€™s **row/column** layout (2â€¯MiB rows, 64â€¯B leaves) independent of how many NilFS shards contributed bytes to that sector. In other words: NilFS sharding affects placement and repair; PoSÂ² attests to liveness and integrity of whatever bytes are sealed in the sector.

\###â€¯4.2â€ƒChallengeÂ DerivationÂ (Beacon Mix)

For epoch counter `ctr` and chain beacon blockâ€‘hash `B_t`:

```
Ï = Blake2sâ€‘256( "POSS2-MIX" â€– B_t â€– h_row_root â€– delta_head_root â€– miner_addr â€– ctr ) // 32 B
row = RejectionSample(u32_le(Ï[0..4]), rows)   // moduloâ€‘biasâ€‘free
col = RejectionSample(u32_le(Ï[4..8]), cols)  // moduloâ€‘biasâ€‘free
// RejectionSample(x, n): if n is a power of two, return x & (nâˆ’1). Else let t = floor(2^32 / n) * n computed in **u64** as `t = ( (1ULL<<32) / n ) * n`. If x < t return x % n; otherwise draw the next 32 bits from a **counterâ€‘mode** expansion `Blake2sâ€‘256("POSS2-MIX" â€– Ï â€– u64_le(counter++))` and retry.
offset = (row * 2â€¯MiB) + (col * 64 B)                        // byte index
```

The prover **must** read eight 1â€¯MiB windows covering
`offset - 3â€¯MiB â€¦ offset + 4â€¯MiB` (wrap moduloÂ `S`).  This is **â‰¤â€¯8â€¯MiB** I/O even when crossing a sector boundary.

\####â€¯4.2.1â€ƒDU Origin Binding (linking mode, normative dial)

Let `p_link âˆˆ [0,1]` be a governance dial. For a `p_link`â€‘fraction of challenges in each epoch,
the prover MUST, in addition to Â§â€¯4.3, supply:

(a) Origin Map inclusion for row: a Poseidonâ€‘Merkle proof from `origin_root` (see Â§â€¯3.7.1)
    yielding `{du_id, sliver_index, symbol_range, C_root}` for the challenged row;

(b) Content opening: a KZG opening at a verifierâ€‘selected symbol index `j âˆˆ symbol_range`
    proving the 1â€¯KiB RS symbol(s) underlying the challenged `leaf64` belong to `C_root`;

(c) Seal derivation binding: a hash binding that the provided `leaf64` equals
    `SealTransform(clear_slice(j), beacon_salt, row)` under the active microâ€‘seal profile.

Chains implementing onâ€‘chain KZG precompiles MUST verify (b) onâ€‘chain; otherwise (b) MUST be
audited by watchers with fraudâ€‘proof slashing.

\####â€¯4.2.2â€ƒPoDE challenges (Proofâ€‘of Delayed Encode, normative dial)

Let `p_derive âˆˆ [0,1]` be a governance dial. For a `p_derive`â€‘fraction of epochs (or equivalently, of an SPâ€™s perâ€‘epoch challenges), the prover MUST satisfy a derivation challenge tied to the clear DU bytes:

1. Provide a KZG opening against `C_root` proving that the verifierâ€‘selected 1â€¯KiB symbol(s) underlying the challenged row (per Â§â€¯4.2) are correct cleartext.
2. Using the active `micro_seal` profile (Â§â€¯3.4.3), derive the challenged `leaf64` deterministically from the opened clear symbols and the epoch beacon salt, and present the resulting `leaf64` and Merkle paths that match the posted roots.

Timing of derivation MUST respect the perâ€‘replica work bounds in Â§â€¯6.2. Chains with KZG precompiles MUST verify (1) onâ€‘chain; otherwise, auditors MUST verify (1) offâ€‘chain with fraudâ€‘proofs.

`ctr` increments monotonically; replaying an old proof with the same counter is rejected onâ€‘chain.

\###â€¯4.3â€ƒProofÂ ObjectÂ `Proof64`

```
struct Proof64 {
    u16  idx_row;        // littleâ€‘endian
    u16  idx_col;
    u32  reserved = 0;   // MAY encode {arity: u8, depth: u8} in high/low bytes
    u8   leaf64[64];          // 64â€‘byte leaf payload at (row,col)
    u8   rowPath[480];        // 15 siblings Ã— 32 B = 480 (binary path)
    u8   rowDelta[32];        // Blake2sâ€‘256(Wâ‚‚i â€– Wâ‚‚i+1)
    u8   deltaHeadPath[480];  // 15 siblings Ã— 32 B (delta_head[i] inclusion)
}
```

\####â€¯4.3.1â€ƒWitness layout (baseline â€œSâ€‘512â€)

| Purpose               | Bytes                   | Encoding                               |
| --------------------- | ----------------------- | -------------------------------------- |
| Row Merkle path (15 lev.)  | 15 Ã— 32 = 480 bytes     | Full Blake2sâ€‘256 siblings              |
| Row digest `Î”`             | 32 bytes                | Blake2sâ€‘256(Wâ‚‚i â€– Wâ‚‚i+1) (separate field, not embedded in `rowPath`) |
| `delta_head[i]` Merkle path| 15 Ã— 32 = 480 bytes     | Full Blake2sâ€‘256 siblings under `deltaHeadRoot` |
| **Total**                  | **992 bytes**           |                                        |
| Header (optional)          | 4 bytes                 | `reserved` MAY carry `{arity, depth}` for nonâ€‘binary trees |

**Normative bound:** Perâ€‘sibling truncation is NOT permitted for mainâ€‘net profiles aiming for â‰¥128â€‘bit security. Higherâ€‘arity trees MAY be used to manage witness size (Â§â€¯4.1).

\###â€¯4.4â€ƒProverÂ AlgorithmÂ `pos2_prove`

```
fn pos2_prove(path, row_i, col_j, Ï) -> Proof64 {
    // 1. Locate 64â€‘byte leaf at (row_i, col_j)
    let leaf_offset = row_i*2MiB + col_j*64B;
    let leaf = read(path, leaf_offset, 64);

    // 2. Build Row Merkle path with full 32â€‘byte siblings (480 B)
    let rowPath = full_row_path(row_i, col_j, path);

    // 3. Compute row digest Î” for the specific row being proven (32 B)
    let W2i   = read(path, row_i*2MiB,        1MiB);
    let W2i_1 = read(path, row_i*2MiB + 1MiB, 1MiB);
    let Î” = Blake2s-256(W2i â€– W2i_1);

    // 4. delta_head[i] under posted root
    let deltaHead_i = Blake2s-256("P2Î”" â€– row_i â€– Î”);
    let deltaHeadPath = full_delta_head_path(row_i, path);

    // 5. Assemble proof
    return Proof64 {
        idx_row = row_i,
        idx_col = col_j,
        rowPath = rowPath,
        rowDelta = Î”,
        deltaHeadPath = deltaHeadPath,
    }
}
```

\###â€¯4.5â€ƒVerifierÂ Logic

Onâ€‘chain function `poss2_verify(h_row_root, delta_head_root, proof) â†’ bool`.

```solidity
function poss2_verify(
    bytes32 hRowRoot, bytes32 deltaHeadRoot, Proof64 calldata p
) external pure returns (bool ok) {
    // --- Row Merkle inclusion check (now with leaf payload) ---
    bytes32 leaf = blake2s_256(bytes.concat(hex"00", p.leaf64));
    bytes32 rootRow = reconstruct(leaf, p.rowPath[0:480]);  // 15 siblings (binary path)
    if (rootRow != hRowRoot) return false;

    // --- Row digest check and delta_head inclusion (bound to h_row[i]) ---
    // Read Î” from its dedicated field
    bytes32 Î” = p.rowDelta;
    bytes32 deltaHead_i = blake2s_256(abi.encode("P2Î”", p.idx_row, rootRow, Î”));
    bytes32 rootDelta = reconstruct(deltaHead_i, p.deltaHeadPath); // 15 siblings
    if (rootDelta != deltaHeadRoot) return false;

    return true;
}
```

Gas upper bound (NilStore L1): **â‰ˆâ€¯9.7k** assuming a **Blake2s precompile** with cost model `C_hash Ã— (#hashes) + C_misc`. This figure is **chainâ€‘specific** and MUST be reâ€‘benchmarked on parameter changes.

\###â€¯4.6â€ƒPerformanceÂ Targets

| Step              | Disk I/O | CPU (ms) | Gas      |
| ----------------- | -------- | -------- | -------- |
| Prove (miner)     | â‰¤â€¯8â€¯MiB  | â‰¤â€¯50     | â€”        |
| Verify (onâ€‘chain) | â€”        | â€”        | â‰¤â€¯10â€¯000 |

\###â€¯4.7â€ƒSecurityÂ AssertionsÂ (reference Â§â€¯7.5)

* **Soundness:** Any prover who forges `(row, col)` without the replica must break the collision resistance of Blake2s (Merkle path and row digest Î”).
* **Sequentiality:** Challenge uses fresh beacon hash `B_t`; proofs prepared in advance fail with overwhelming probability.
* **Window overlap:** Let Î² be the independent fault rate per window and let each proof check `w=8` adjacent 1â€¯MiB windows. Over `C` proofs/day, the miss probability is `(1âˆ’Î²)^{wC}`. To achieve â‰¤2â»Â¹Â¹â° with Î²=0.2 one needs `wC â‰¥ ceil(110Â·ln2 / (âˆ’ln(1âˆ’0.2))) = 342` total windows, i.e., `C â‰¥ 43` proofs/day for `w=8`. Networks MUST set the perâ€‘replica challenge rate accordingly and publish `C` in the dial profile.

\###â€¯4.8â€ƒVersioning

`possÂ²` is bound to the dial profile.  Changing `(rows, window, hash)` requires a **minor** version bump (Â§â€¯0.3) and regenerated AnnexÂ B vectors.

---

\###â€¯4.9â€ƒRetrieval Sampling (informative)

Retrieval sampling referenced by the metaspec is an auditâ€‘only mechanism that operates over bandwidthâ€‘receipt Merkle roots (`BW_root`) and watcher verification. It is orthogonal to `possÂ²` and does not alter circuits or public inputs.

â€¢ PoSÂ² inputs remain as defined in this section; the L2â€‘pinned `vk_hash` is unchanged.
â€¢ Sampling randomness derives from the VRF epoch beacon via Â§â€¯5.5.

*Sectionâ€¯Â§â€¯5 defines the Nilâ€‘VRF used to derive the `salt` input of `nilseal`, the proofâ€‘epoch beacon above, and the sampling seed used offâ€‘circuit by retrieval auditors.*

---

## Â§â€¯5â€ƒNilâ€‘VRFÂ / Epochâ€¯BeaconÂ (`nilvrf`)

\###â€¯5.0â€ƒPurposeÂ &Â DesignÂ Choice

Nilcoin derives perâ€‘epoch randomness from a **BLS12â€‘381â€‘based Verifiable Random Function (VRF)** that is:

* **Uniquely provable** â€“ a single, deterministic proof per `(pk,msg)`.
* **Deterministically verifiable** onâ€‘chain with **one pairing**.
* **Aggregateâ€‘friendly** â€“ shares combine linearly (BATMAN threshold, â‰¥â€¯2/3 honest).

We instantiate a **BLSâ€‘signatureâ€‘based VRF**: VRF proofs are BLS signatures on `hash_to_G2(msg)`, and verification is a single pairing check. We follow **RFCâ€¯9380** for `hash_to_G2` (Simple SWU, XMD:SHAâ€‘256) with a Nilcoinâ€‘specific DST. **Note:** The IETF VRF standard **RFCâ€¯9381** does not define a BLS VRF; our construction relies on BLS signature **uniqueness**, which also implies an aggregator cannot grind the beacon by subset selection.  
DST (normative): `"BLS12381G2_XMD:SHA-256_SSWU_RO_NIL_VRF_H2G"`.

---

\###â€¯5.1â€ƒNotation & Parameters

| Object | Group | Encoding   | Comment                             |
| ------ | ----- | ---------- | ----------------------------------- |
| `pk`   | `G1`  | 48â€¯B comp. | `pk = skÂ·Gâ‚`                        |
| `Ï€`    | `G2`  | 96â€¯B comp. | Proof (BLS signature)               |
| `H`    | `G2`  | 96â€¯B       | `H = hash_to_G2("NIL_VRF_H2G", msg)` |
| `e`    | â€”     | â€”          | Optimal Ate pairing `e: G1Ã—G2â†’G_T`  |
| `Hash` | â€”     | 32â€¯B       | Blake2sâ€‘256, domain `"NIL_VRF_OUT"` |

Curve: **BLS12â€‘381**; subgroup order
`r = 0x73EDA753299D7D483339D80809A1D80553BDA402FFFE5BFEFFFFFFFF00000001`.

---

\###â€¯5.2â€ƒAlgorithmsÂ (IETF BLS VRF)

\####â€¯5.2.1â€ƒKeyÂ Generation

```rust
fn vrf_keygen(rng) -> (sk: Scalar, pk: G1) {
    sk â†$ rng();                     // 1 â€¦ râˆ’1
    pk = sk Â· G1_GENERATOR;
    return (sk, pk);
}
```

\####â€¯5.2.2â€ƒEvaluationÂ (`vrf_eval`)

```rust
fn vrf_eval(sk: Scalar, pk: G1, msg: &[u8]) -> (y: [u8;32], Ï€: G2) {
    H = hash_to_G2("NIL_VRF_H2G", msg); // RFC 9380 Simple SWU with DST
    Ï€ = sk Â· H;                          // BLS signature
    y = Blake2s-256("NIL_VRF_OUT" â€– compress(pk) â€– compress(H) â€– compress(e(G1_GENERATOR, Ï€)));
    return (y, Ï€);
}
```

*The output `y` is the VRF value (32â€¯B); `Ï€` is the proof (96â€¯B).*

\####â€¯5.2.3â€ƒVerificationÂ (`vrf_verify`)

```rust
fn vrf_verify(pk: G1, msg: &[u8], y: [u8;32], Ï€: G2) -> bool {
    H   = hash_to_G2("NIL_VRF_H2G", msg);
    ok  = (e(pk, H) == e(G1_GENERATOR, Ï€));      // one pairing + eq
    yâ€²  = Blake2s-256("NIL_VRF_OUT" â€– compress(pk) â€– compress(H) â€– compress(e(G1_GENERATOR, Ï€)));
    return ok && (yâ€² == y);
}
```

Security follows directly from the EUFâ€‘CMA security of BLS signatures under the coâ€‘Gapâ€‘Diffieâ€‘Hellman assumption on BLS12â€‘381.

---

\###â€¯5.3â€ƒEpochÂ BeaconÂ ( solo miner )

For epoch counter `ctr`:

```
(y, Ï€)   = vrf_eval(sk, pk, int_to_bytes_le(ctr, 8));
beacon_t = Blake2sâ€‘256("NIL_BEACON" â€– y);
```

The 32â€‘byte `beacon_t` feeds **Â§â€¯4.2** challenge derivation and seeds the retrievalâ€‘sampling RNG per **Â§â€¯5.7**.

---

\###â€¯5.4â€ƒBATMAN Threshold Aggregation (tÂ â‰¥â€¯2/3)

\####â€¯5.4.1â€ƒSetup

* Committee sizeÂ `N`; thresholdÂ `t = âŒˆ2N/3âŒ‰`.
* Polynomial secret sharing: master key `s (= sk_master)` split into `sk_i = f(i)` degreeÂ `d = Nâˆ’t`.
* Public key shares `pk_i = sk_iÂ·G1`.
* Proof of Possession (PoP): each participant MUST provide a signature `pop_i = Sign(sk_i, pk_i)` during registration to prevent rogueâ€‘key attacks.
* Constant public coefficients for Lagrange interpolation moduloÂ `r`.

\####â€¯5.4.2â€ƒPerâ€‘epoch share posting

Each participantÂ `i` publishes `(pk_i, Ï€_i)` where

```
Ï€_i = sk_i Â· H(epoch_ctr);
```

No `y_i` is required.

\####â€¯5.4.3â€ƒAggregator

Collect any `t` valid shares; compute Lagrange coefficients `Î»_i` inÂ â„¤\_r:

```
Ï€_agg = Î£ Î»_i Â· Ï€_i          âˆˆ G2           // 96â€¯bytes
```

(No pairing, no `G_T` exponentiation.)

**Deterministic Shareâ€‘Selection (Normative, strengthened):** Participants MUST post `(pk_i, Ï€_i)` **on L1** before `Ï„_close`. The aggregator MUST:
  (a) derive the candidate set **exclusively** from the onâ€‘chain arrivals;
  (b) select the lexicographically smallest `t` shares under the ordering key
```
share_id_i := Blake2sâ€‘256("BATMAN-SHARE" â€– compress(pk_i) â€– compress(Ï€_i) â€– u64_le(epoch_ctr))
```
Only shares that arrive before the epoch close time `Ï„_close` are eligible; ties are broken by `compress(pk_i)`.

Publish `(Ï€_agg, pk_agg)` where `pk_agg = Î£ Î»_i Â· pk_i`.

\####â€¯5.4.4â€ƒOnâ€‘chain Verification & Beacon

```solidity
function verify_beacon(
    bytes48 pkAgg, bytes96 piAgg, bytes8 ctr
) returns (bytes32 beacon)
{
    G2 H = hash_to_G2("NIL_VRF_H2G", ctr);
    require( pairing(pkAgg, H) == pairing(G1_GEN, piAgg) );
    bytes32 y  = blake2s256(
        "NIL_VRF_OUT" â€– compress(pkAgg) â€– compress(H) â€– compress(pairing(G1_GEN, piAgg))
    );
    return blake2s256("NIL_BEACON" â€– y);
}
```

*Gas:* **â‰ˆâ€¯97â€¯k** (1 pairing + hashes), independent of `N`.

---

\###â€¯5.5â€ƒParameter Changes & Versioning

| Parameter                     | Governance tier | Effect                          |
| ----------------------------- | --------------- | ------------------------------- |
| Curve ID, hashâ€‘toâ€‘curve map   | **major**       | Affects security level          |
| Output hash (Blake2 â†’ BLAKE3) | **minor**       | Beacon derivation               |
| Threshold `t` (`N` fixed)     | **minor**       | Liveness vs. security tradeâ€‘off |

All changes require updated KATs in Annexâ€¯A.5.

---

\###â€¯5.6â€ƒKnownâ€‘Answer TestsÂ (Annexâ€¯A.5)

* Deterministic `vrf_keygen` seeds via ChaCha20(`seed=1`).
* Solo VRF vectors: `(msg, pk, Ï€, y)`.
* BATMAN vectors: `(ctr, pkAgg, piAgg, beacon)` for `N=5`, `t=4`.

---

\###â€¯5.7â€ƒSampling Seed & Expansion (normative)

NilStoreâ€™s retrievalâ€‘sampling RNG derives from the epoch beacon and does not interact with any `possÂ²` circuit.

Definition (perâ€‘epoch):

```
seed_t := Blake2sâ€‘256("NilStore-Sample" â€– beacon_t â€– epoch_id)
```

Expansion (deterministic PRF stream for sampling indices):

```
ExpandSample(seed_t, i) := Blake2sâ€‘256("SAMPLE-EXP" â€– seed_t â€– u32_le(i))
```

Notes:
- `seed_t` and `ExpandSample` are used offâ€‘chain by watchers/validators to select receipts for auditing.
- Domain strings are fixed ASCII constants (see Â§â€¯0.4.1).
- No changes to `possÂ²` public inputs or verification keys.

*Sectionsâ€¯Â§â€¯6â€¯throughâ€¯Â§â€¯9 discuss governance, security proofs, and performance metrics building on this VRF construction.*


---

## Â§â€¯6â€ƒGovernanceâ€‘Tunable Dialâ€¯Policy

\###â€¯6.0â€ƒGovernance Bodies

| Abbrev. | Role                                         | Quorum / Majority       |
| ------- | -------------------------------------------- | ----------------------- |
| **NC**  | Nilcoin Council (foundation board)           | 2â€¯/â€¯3 of seated members |
| **MC**  | Miner Caucus (â‰¥â€¯1â€¯PiB sealed)                | 60â€¯% by sealed capacity |
| **TC**  | Technical Committee (elected cryptographers) | simple majority         |

The **Council** enacts parameter changes after receiving a recommendation from the Technical Committee and, when required, consent of the Miner Caucus.

\###â€¯6.1â€ƒTunables & Version Impact

| Parameter        | Symbol | Units  | Version bump           |
| ---------------- | ------ | ------ | ---------------------- |
| Field modulus    | `q`    | bits   | **major**              |
| Vector length    | `m`    | limbs  | **major**              |
| NTT block size   | `k`    | limbs  | **minor**              |
| Shear passes     | `r`    | count  | **minor**              |
| Gaussian Ïƒ       | `Î»`    | Ïƒ/Ïƒ\_Q | **minor**              |
| Argon2 passes    | `H`    | count  | **minor**              |
| Interleave frag. | `Î³`    | MiB    | **minor**              |
| Proof deadline   | `Î”`    | sec    | **governance runtime** |

\###â€¯6.2â€ƒSecurity Invariant

```
t_recreate_replica(row)  â‰¥  5 Â· Î”_work
```

`Î”_work` is the **perâ€‘replica work bound** (default 60â€¯s in baseline profile) and is related to the metaspecâ€™s network window `Î”_submit` (default 1â€¯800â€¯s) via `Î”_work â‰ª Î”_submit`. Any dial proposal must empirically demonstrate that honest hardware meets the inequality while an emptyâ€‘disk adversary does not.

**Additional invariants (normative):**

* **Bound tightness:** Maintain `Î² / q â‰¤ 1 / 2^15` (Sâ€‘512 satisfies this: Î²â€¯=â€¯16â€¯383, qâ€¯â‰ˆâ€¯2^30).
* **Permutation passes:** `r â‰¥ 3` for mainâ€‘net profiles.
* **NTT block size:** `k â‰¥ 64`; increases require updated Annexâ€¯A KATs.
* **Challenge sampling:** Moduloâ€‘biasâ€‘free selection required (Â§â€¯4.2); profiles that change `rows`/`cols` MUST preserve this.

\###â€¯6.3â€ƒReview Cadence & Metrics

* **Quarterly Review** â€“ Technical Committee publishes anonymised telemetry:

  * median seal time,
  * 95â€¯th percentile seal time,
  * proof acceptance ratio,
  * network storage growth.

* **Trigger condition** â€“ If â‰¥â€¯75â€¯% of proofs arrive in <â€¯0.3â€¯Î”, the TC issues a **dialâ€‘tightening recommendation**.

\###â€¯6.4â€ƒAdjustment Ruleâ€‘Set

Priority order (apply only one per quarter):

| Rank | Action                               | Constraint              |
| ---- | ------------------------------------ | ----------------------- |
| â€¯1â€¯  | Shorten `Î”` (preferred)              | `Î”Â â‰¥Â 30â€¯s`              |
| â€¯2â€¯  | â†‘Â `k` or â†‘Â `r` by 1â€¯step             | not both simultaneously |
| â€¯3â€¯  | â†‘Â `H` byâ€¯1Â (pass)                    | `HÂ â‰¤Â 2`                 |
| â€¯4â€¯  | â†‘Â `Î»` byÂ 20 (fixedâ€‘point)             | `Î»Â â‰¤Â 500`               |
| â€¯5â€¯  | Set `Î³ = 4â€¯MiB` *(requires MC vote)* | HDD impact analysis     |

\###â€¯6.5â€ƒProposal & Activation Timeline

| Phase                                | Duration | Required vote                 |
| ------------------------------------ | -------- | ----------------------------- |
| Draft (TC)                           | 7â€¯d      | â€”                             |
| Public comment                       | 14â€¯d     | â€”                             |
| Council vote                         | 5â€¯d      | 2â€¯/â€¯3 NC                      |
| Miner Caucus vote *(Î³Â changes only)* | 7â€¯d      | 60â€¯% capacity                 |
| Testnet bakeâ€‘in                      | 14â€¯d     | â€”                             |
| Mainâ€‘net activation                  | â€”        | blk\_heightÂ +Â 5â€¯216 (â‰ˆâ€¯1â€¯day) |

A failed vote resets the dial to its previous state.

**Window finalization rule (normative):** During each timeline phase or audit window, any task that is **started** MUST be **finished** within that window by publishing its transcript in `_artifacts/` (added to `SHA256SUMS`). Incomplete changes are **reverted** before the window closes; partial artifacts MUST NOT be carried forward.

\###â€¯6.6â€ƒFrozen Reference Profiles

| ID           | Purpose              | m     | k   | r | Î»   | H | Î³     | Î”    |
| ------------ | -------------------- | ----- | --- | - | --- | - | ----- | ---- |
| **Sâ€‘512**    | Baseline (CPU/mem)   | 1â€¯024 | 128 | 3 | 350 | 2 | 0     | 60â€¯s |
| **Sâ€‘1024â€‘A** | Archival, high hard. | 2â€¯048 | 256 | 4 | 400 | 2 | 2â€¯MiB | 30â€¯s |

Profile strings are **immutable identifiers**; new profiles append rows.

\###â€¯6.7â€ƒGovernance Dials (linking/derivation)

The following protocol dials control optional contentâ€‘binding and derivation workload. All changes MUST respect the chainâ€™s Verification Load Cap (metaspec Â§â€¯6.1) and follow Â§â€¯6.5.

- `p_link âˆˆ [0,1]` â€” Fraction of PoSÂ² challenges that require DU Origin Binding per Â§â€¯4.2.1. Default 0.05. Onâ€‘chain KZG required where available.
- `p_derive âˆˆ [0,1]` â€” Fraction of PoSÂ² challenges (or epochs) that require PoDE per Â§â€¯4.2.2. Default 0.01. Requires `micro_seal = row` profile and published KATs.
- `micro_seal âˆˆ {off,row}` â€” Localizes sealing to 2â€¯MiB rows for derivation (Â§â€¯3.4.3). Default `off` in baseline Sâ€‘512.

Guardâ€‘rails:
- `p_link + p_derive` MAY be capped by governance to satisfy the Verification Load Cap.
- Enabling `micro_seal = row` MUST NOT change digest roots outside Â§â€¯4 linking/derivation mode; equivalence MUST be demonstrated via Annex A/B KATs.

---

## Â§â€¯7â€ƒSecurityâ€¯Rationaleâ€¯&â€¯Proofs

\###â€¯7.1â€ƒThreat Model & Goals

* Adversaries may control arbitrary compute and storage, but not break standard cryptographic assumptions.
* GoalÂ 1â€¯â€”â€¯**Sound replication**: forging a proof without the replica requires â‰¥â€¯Îµâ€‘negligible probability.
* GoalÂ 2â€¯â€”â€¯**Sequential work**: recomputing a replica in timeÂ <â€¯`Î”/5` is infeasible.
* GoalÂ 3â€¯â€”â€¯**Biasâ€‘free randomness**: beacon output unpredictable until VRF proofs are posted.

\###â€¯7.2â€ƒCore Assumptions

| #    | Assumption                                     | Reference      |
| ---- | ---------------------------------------------- | -------------- |
| â€¯A1â€¯ | Blake2s acts as a random oracle in our domains | NIST, RFCÂ 7693 |
| â€¯A2â€¯ | BLS12â€‘381 pairing hardness (coâ€‘Gap DH)         | CFRG draft     |
| â€¯A3â€¯ | Moduleâ€‘SIS(m,q,Î²) with `m=1024, qâ‰ˆ2Â³â°, Î²=16383` **targets** â‰¥â€¯2Â¹Â²â¸â€‘bit security; actual bits MUST be justified by a published estimator run (e.g., BKZ cost model / Albrecht estimator) accounting for circulant/module structure. If the published run yields <128 bits, the dial MUST raise security (e.g., â†‘m or â†“Î²) before mainâ€‘net activation. |
| â€¯A4â€¯ | Disk bandwidth â‰¥â€¯400â€¯MB/s (SSD profile)        | 2025 median    |

\###â€¯7.3â€ƒ`nilfield`â€¯+â€¯`nilhash`

* **Binding** â€“ Under the enforced bound `||r||_âˆ â‰¤ Î²` (verified by Ï€), two openings (x,r) â‰  (xâ€²,râ€²) yield a **short nonâ€‘zero** kernel vector `(Î”x,Î”r)` of `(Aâ€–B)` with `||Î”x||_âˆ â‰¤ 65â€¯535` (16â€‘bit limbs) and `||Î”r||_âˆ â‰¤ 2Î²`. Since A and B are circulant, finding such a vector solves an instance of **Moduleâ€‘SIS** over ğ”½_q (or ğ”½_{qâ‚}Ã—ğ”½_{qâ‚‚} under CRT) at parameters (m,q,Î²) (Assumption A3).
* **Hiding** â€“ Because `r` is bounded, hiding is **computational/statistical** (not perfect). With Ïƒ_r and Î² fixed by the dial (see Â§â€¯2.2), and spectrally randomized `(A,B)` plus perâ€‘domain twist, the distinguishing advantage is at most  
  `Adv â‰¤ mÂ·Pr[|D_{Ïƒ_r}|>Î²] + Îµ_hash`,  
which MUST be â‰¤â€¯2â»Â¹Â²â¸ for the active profile and validated by KATs.

\###â€¯7.4â€ƒ`nilseal`

\####â€¯7.4.1â€ƒSequentialâ€‘Work Proof

* Passâ€¯`p` depends on `Î¶_p`, a Blake2sâ€‘256 hash (with domain tag "NIL_SEAL_ZETA") of the Merkle root over perâ€‘chunk Blake2sâ€‘256 digests of passâ€¯`pâˆ’1` data.
* Any strategy to pipeline passes must predict 256â€‘bit hash preâ€‘images â†’ breaks Assumptionâ€¯A1.

Hence an adversary must complete passâ€¯`pâˆ’1` before starting passâ€¯`p`, giving a lowerâ€‘bound time `â‰¥Â r Â· S / disk_bw`.

\####â€¯7.4.2â€ƒReplica Indistinguishability

Gaussian noise (Ïƒ set by `Î»`, Â§â€¯3.5) aims to mask structure; precise entropy depends on Ïƒ relative to `Q` and quantization. Implementations MUST publish empirical tests (minâ€‘entropy estimate and Ï‡Â²) for the active `Î»`, and the specification makes **no unconditional â‰¤2â»Â¹Â²â¸** distance claim without that evidence.

\###â€¯7.5â€ƒ`possÂ²` Proofâ€‘ofâ€‘Spacetime

* **Merkle inclusion** â€“ Collision implies Blake2s collision (A1).
* **Row digest check** â€“ Adversary must find `Î”â€² â‰  Î”` s.t. `B2s("P2Î”" â€– row â€– Î”â€²) = delta_head[row]`; requires hash collision (A1).
* **Overall failure prob.** per epoch â‰¤â€¯2â»Â¹Â¹â° (detailed derivation in Annexâ€¯B).

\###â€¯7.6â€ƒ`nilvrf`

* **Uniqueness** â€“ BLS signature uniqueness (Assumptionâ€¯A2).
* **Pseudorandomness** â€“ EUFâ€‘CMA security â‡’ VRF pseudorandomness under randomâ€‘oracle model (A1, A2).
* **BATMAN soundness** â€“ With â‰¥â€¯t shares, Lagrange coefficients reconstruct the master secretâ€™s signature; forging output without t shards breaks BLS.

\###â€¯7.7â€ƒComposition

* Beacon unpredictability (VRF) feeds seal offset; circularity avoided because VRF input (epoch counter) is independent of replica data.
* Replay attacks blocked by `ctr` monotonicity (Sectionâ€¯4.2).
* Grinding resistance: beacon derives from VRF output with domainâ€‘separated hash; miners cannot bias it without breaking VRF security.

---

*The security analyses are highâ€‘level sketches; full algebraic reductions and concrete bounds are archived in the Nilcoin Research whiteâ€‘papers (link in Appendixâ€¯E).*

---

## Â§â€¯8â€ƒReferenceâ€¯ImplementationsÂ (normative status matrix)

| Lang / Crate                  | Dial coverage | CI status | Constantâ€‘time audit                  | Fuzz coverage        |
| ----------------------------- | ------------- | --------- | ------------------------------------ | -------------------- |
| **Rust**Â `nilcipher` (noâ€‘std) | Sâ€‘512         | âœ” main    | ctgrindâ€¯0 findings, dudectÂ Î”tâ€¯â‰¤â€¯4â€¯ns | AFL++â€¯â‰¥â€¯1â€¯M exec/day |
| **Go**Â `nilgo`                | Sâ€‘512         | âœ” main    | dudect Î”tâ€¯â‰¤â€¯5â€¯ns                     | goâ€‘fuzzÂ 100â€¯k/min    |
| **WASM**Â `nilwasm`            | Sâ€‘512         | beta      | N/A (no secret)                      | unit tests           |
| **Python**Â `nilpy` (edu)      | Sâ€‘512         | pass      | not CT                               | â€”                    |

*All reference crates MUST pass Annexâ€¯A/B KATs on CI.* In addition, CI MUST run the reproducibility targets from Â§â€¯0.6 (`make prp-kat`, `reject-sample`, `noise-kat`, `poss2-derive`, `vrf-dst`, `publish`) and attach `_artifacts/` + `SHA256SUMS` to the build artifacts.
Vendors may implement alternative languages provided they embed the exact constants from Annexâ€¯C and pass the same KAT suite.

---

## Â§â€¯9â€ƒPerformanceâ€¯BenchmarksÂ (informative)

| Task @â€¯baseline profile **Sâ€‘512** | 8â€‘core 2025 CPUÂ (3â€¯.8â€¯GHz) | 4Ã— NVMe SSDÂ (7â€¯GB/s agg.) |
| -------------------------------- | -------------------------- | ------------------------- |
| **Seal 32â€¯GiB**                  | 8â€¯minÂ 14â€¯s                 | I/Oâ€‘bound                 |
| **Reâ€‘seal 32â€¯GiB (resume)**      | 42â€¯s                       | â€”                         |
| **Window proof (6â€¯MiB)**         | 37â€¯ms                      | inâ€‘RAM                    |
| **Onâ€‘chain verify**              | â€”                          | 9â€¯698â€¯gas                 |
| **VRF verify (solo)**            | â€”                          | 97â€¯kâ€¯gas                  |
| **BATMAN verify (N=5,â€¯t=4)**     | â€”                          | 99â€¯kâ€¯gas                  |

Measurements taken on Ubuntuâ€¯24.04, RustÂ 1.79 `-C target-cpu=native`.

---

## Annexâ€¯Aâ€ƒKnownâ€‘Answer Tests (normative, machineâ€‘readable)

*Directory:* `spec/v2.0/kats/`

| File           | Content                                                                   |
| -------------- | ------------------------------------------------------------------------- |
| `field.toml`   | Add / Sub / Mul / Inv vectors for 10â€¯000 pseudorandom pairs               |
| `ntt64.toml`   | Forward + inverse roundâ€‘trips for unit basis and random inputs            |
| `nilhash.toml` | h^{(1)} (qâ‚), h^{(2)} (qâ‚‚ if CRT), digests, and Ï€ transcripts (Î²=16383) |
| `nilseal_prp.toml` | 8â€‘round Feistel PRP traces incl. cycleâ€‘walk examples                   |
| `noise_seed.toml`  | Deterministic noise seeds & first 4 CTR blocks per (row,window,pass)   |
| `poss2_mix_roots.toml` | Challenge derivation mixing `h_row_root` and `delta_head_root`     |
| `nilseal.toml` | Legacy codec KATs (kept for continuity)                                    |
| `poss2.toml`   | Proof64 objects for four beacon samples                                   |
| `vrf.toml`     | Key, proof, output vectors for solo and BATMAN aggregation                |
| `vrf_beacon.toml` | Inputs and outputs for `"NIL_BEACON"` â†’ `beacon_t` derivation          |
| `sampling_seed.toml` | `(epoch_id, beacon_t)` â†’ `seed_t` and first 4 `ExpandSample` outputs |
| `constants_q2` | qâ‚‚ constants (Ïˆâ‚–, kâ»Â¹, Montgomery)                                        |

All decimal values are littleâ€‘endian; group elements are compressed hex.

### A.3â€ƒNilhash Rangeâ€‘Proof Ï€ Encoding (normative)

- Domain tag: `"NILHASH-RANGE"` (ASCII), transcript uses Blake2sâ€‘256 (RO model).
- Public params bound into transcript: `Version`, `DID`, `q` (and `qâ‚‚` if CRT), `m`, `Î²`.
- Statement: â€œAll limbs of r satisfy |r_i| â‰¤ Î²â€ for the `m`â€‘vector r per enabled prime.
- Aggregation: a single Ï€ covers all m limbs (and both primes, if CRT) via innerâ€‘product style aggregation.
- Verify steps (high level):
  - Recompute `x = SVT(pad(msg))`, apply domain twist; check `h == A_twistedÂ·x + BÂ·r` per prime.
  - Run Ï€ verification against the bound `Î²` with the same transcript parameters.
- Size/perf guidance: Ï€ â‰ˆ 1.6â€“2.0â€¯kB at mâ€¯=â€¯1â€¯024; verify â‰ˆ 1â€“2â€¯ms CPU; prove â‰ˆ 3â€“6â€¯ms CPU.


---

## Annexâ€¯Bâ€ƒExtendedâ€¯Codec / PoSSÂ² VectorsÂ (normative)

*Directory:* `spec/v2.0/annexB/`

* 2â€¯GiB miniature replica, complete rowâ€‘byâ€‘row `h_row` and `delta_head`.
* Randomness robustness test: 1â€¯000 beacon challenges with expected offsets.
* Timing corpus for sequentialâ€‘work proof replay.

---

## Annexâ€¯Câ€ƒConstantâ€‘Generation ScriptÂ (normative)

`appendix_c_constants.py` â€“ *identical to listing in Â§â€¯1 but provided as
an executable file.*
Running

```
$ python3 appendix_c_constants.py 998244353 3 > constants.txt
```

MUST reproduce **exactly** the table published in Â§â€¯1.1 and the first rows of `field.toml`.

---

## Appendixâ€¯Dâ€ƒChangeâ€‘Log (informative, excerpt)

* **vâ€¯2.0 vsâ€¯vâ€¯1.0** â€“ prime upgrade (qâ‚), Pedersen commitment, dataâ€‘dependent PRP permutation, Gaussian noise, BATMAN VRF, security consolidation.
* **Breaking changes** â€“ commitment vectors no longer open perâ€‘limb; all sealers must regenerate replicas; proofs unaffected.
* **Deprecations** â€“ legacy â€œnilâ€‘shuffleâ€/â€œshear permutationâ€ terminology replaced by â€œPRP permutationâ€.

â€”

### vâ€¯2.0â€‘final (nilhash binding + CRT option)

- Nilhash binding tightened: openings now include a bounded blinding vector `r` with an aggregated proof `Ï€` that `||r||_âˆ â‰¤ Î²` (Î²â€¯=â€¯16â€¯383). Binding reduces to SIS with a short kernel witness (Â§â€¯2.2, Â§â€¯7.3).
- Domainâ€‘separated spectral twist `D^(DID)` applied on the `AÂ·x` path; algebra is pinned per DomainID (Â§â€¯2.2).
- Circulant `B` spectrally randomized and domainâ€‘separated via `H(Versionâ€–DIDâ€–"B-spectrum"â€–j)`; invertible w.h.p. (Â§â€¯2.2).
- Optional CRT profile: added NTTâ€‘friendly prime `qâ‚‚ = 1â€¯004â€¯535â€¯809`; digest input concatenates `h^{(1)} â€– [h^{(2)}]` without changing digest size (Â§â€¯0.2, Â§â€¯1.1.1, Â§â€¯2.3).
- Profiles: consolidated to `Sâ€‘512` baseline; removed `Sâ€‘q1` family (Â§â€¯6.6).
- KATs: `nilhash.toml` updated to include `h^{(1)}`, `h^{(2)}` (if CRT), digests, and Ï€ transcripts; `constants_q2` added (Annexâ€¯A).
- Security text: Â§â€¯7.3 updated â€” removed â€œperfect hidingâ€; clarified statistical/computational hiding and SISâ€‘tight binding.

Full git diff: `<https://github.com/nilcoin/spec/compare/v1.0...v2.0>`.

---

## Appendixâ€¯Eâ€ƒFutureâ€¯Work (informative)

1. **Selective disclosures** â€“ Bulletproofâ€‘style innerâ€‘product argument for limbâ€‘specific openings (target vâ€¯2.1).
2. **Postâ€‘quantum VRF** â€“ Explore pairingâ€‘free VRFs (e.g., SQIsignâ€‘VRF) once NIST PQC signatures are standardised.
3. **Larger field modulus** â€“ `q â‰ˆ 2^36` to raise SIS margin; requires 128â€‘bit limbs or multiâ€‘precision Montgomery.
4. **Hardware proofs** â€“ Investigate STARKâ€‘based `possÂ²` verifier to remove pairing preâ€‘compile.
5. **Green sealing** â€“ Dial profiles optimised for lowâ€‘power ARM + eMMC miners.

---

### Releaseâ€¯Packageâ€¯ChecklistÂ (completed)

* [x] `spec_v2.0.pdf` / `spec_v2.0.md` (this document)
* [x] Annexâ€¯A/B KAT directories (â‰ˆâ€¯8â€¯MiB compressed)
* [x] Annexâ€¯C script (+Â sha256sum in README)
* [x] Reference implementation tags (`nilcipherâ€‘v2.0`, `nilgoâ€‘v2.0`)
* [x] CI badge: **green** (#â€¯buildÂ â–¢764)
* [x] Reproducibility kit (`_artifacts/` + `SHA256SUMS`) and scripts (`make publish`) regenerating all published numbers

The Nilcoin Council hereby designates Versionâ€¯2.0 as the **canonical spec** for mainâ€‘net activation at heightâ€¯â–¢H\_ACT (approx. â–¢2025â€‘MMâ€‘DDÂ UTC).

*End of Specification.*
