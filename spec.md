# Nilcoinâ€¯Coreâ€¯vâ€¯2.0 (â€œqâ‚â€)

### Cryptographicâ€¯Primitives &â€¯Proofâ€¯System Specification

*Publication dateâ€¯â–¢2025â€‘XXâ€‘XX â€“ Council resolutionâ€¯#:â€¯â–¢NCâ€‘2025â€‘07*

---

## AbstractÂ (normative)

Nilcoinâ€¯Core vâ€¯2.0 defines the complete cryptographic foundation for the Nilcoin storageâ€‘based consensus network.â€¯
It specifies, in a fully reproducible manner:

1. **Field & transform algebra** over the 30â€‘bit primeâ€¯$qâ‚ = 998â€¯244â€¯353$;
2. **KZG commitments** to DU plaintext (polynomial commitments; canonical for content correctness in PoUD);
   
4. **Plaintext possession proofs**: **PoUD** (KZGâ€‘PDP over DU cleartext) and **PoDE** (timed window derivations) as the **normative** liveness path;
5. **BLSâ€¯VRF** and BATMAN aggregation for unbiased beacons;
6. **Dial policy** and governance process for safe parameter evolution;
7. Formal security rationale under standard assumptions.

All constants are generated by an auditable Python script (Annexâ€¯C), and every algorithm is accompanied by deterministic Knownâ€‘Answer Tests (Annexâ€¯Aâ€“B).Â 
Versionâ€¯2.0 supersedes vâ€¯1.0 and vâ€¯1.0â€‘rcâ€¯series; it MUST be implemented verbatim by mainâ€‘network clients targeting activation heightâ€¯â–¢H\_ACT.

---


####â€¯0.4.1â€ƒString Domain Tags (Blake2s separators)

For transparency and auditability, Core defines the following fixed ASCII domain strings used with Blake2sâ€‘256 across modules:

| Tag                  | Purpose                                  | Section    |
| -------------------- | ---------------------------------------- | ---------- |
| `"NIL_VRF_OUT"`     | VRF output compression                    | Â§â€¯5.2      |
| `"NIL_VRF_H2G"`     | VRF hash_to_G2 DST                        | Â§â€¯5.2      |
| `"NIL_BEACON"`      | Epoch beacon derivation from VRF output   | Â§â€¯5.3      |
| `"NilStore-Sample"` | Retrievalâ€‘sampling seed from epoch beacon | Â§â€¯5.7 (new) |
| `"SAMPLE-EXP"`      | PRF expansion for sampling indices        | Â§â€¯5.7 (new) |
| `"NIL_SEAL_SALT_EXP"` | Salt expansion XOF for kâ€‘limbs          | Â§â€¯3.3      |
| `"BATMAN-SHARE"`    | Deterministic shareâ€‘selection label       | Â§â€¯5.4.3    |
| `"PARAMGEN-V1"`     | XOF seed for A/B/twist parameter mixing   | Â§â€¯2.2      |

 

---
  
 
## Â§â€¯4â€ƒProofâ€‘ofâ€‘Usefulâ€‘Data (PoUD) & Proofâ€‘ofâ€‘Delayedâ€‘Encode (PoDE)  

###â€¯4.0aâ€ƒDerive (windowâ€‘scoped, normative for PoDE)  
Purpose: deterministic, beaconâ€‘salted local transform on a `W`â€‘byte window (default `W = 8â€¯MiB`) recomputable directly from **plaintext** during PoDE

```
Derive(clear_window, beacon_salt, row_id):

1. Partition clear_window into kâ€‘limb chunks (baseline k = 64).
2. For pass = 0..râˆ’1:
   NTT_k(chunk);
   salt_k = SHAKE128("NIL_SEAL_SALT_EXP" â€– beacon_salt â€– u8(pass) â€– u32_le(row_id))[0 .. 4k) as k littleâ€‘endian u32 limbs mod Q;
   for j in 0..kâˆ’1: chunk[j] = (chunk[j] + salt_k[j]) mod Q;
   INTT_k(chunk);
3. Output:
   leaf64 := first 64 bytes postâ€‘transform;
   Î”_W := Blake2sâ€‘256(window postâ€‘transform).

```

**Domain separation (normative):** For PoUD/PoDE usage, salt derivation MUST include `epoch_id` and `du_id` in addition to `beacon_salt` and `row_id`, to prevent crossâ€‘deal replay within the same epoch.

###â€¯4.0â€ƒObjective & Model

Attest, per epoch, that an SP (a) stores the **cleartext** bytes of their assigned DU intervals and (b) can perform **timed, beaconâ€‘salted derivations** over randomly selected windows quickly enough that fetching from elsewhere is infeasible within the proof window.

**Security anchors:** (i) DU **KZG commitment** `C_root` recorded at deal creation; (ii) BLSâ€‘VRF epoch beacon for unbiased challenges; (iii) onâ€‘chain **KZG multiâ€‘open** preâ€‘compiles; (iv) watcherâ€‘enforced timing digests.

###â€¯4.1â€ƒDU Representation & Commitment

Let a DU be encoded with systematic RS(n,k) over GF(2â¸) and segmented into **1â€¯KiB symbols**. The client computes a **KZG commitment** `C_root` to the RSâ€‘symbol polynomial(s) at deal creation and posts `C_root` on L2; all subsequent storage proofs **must open against this original commitment**.

###â€¯4.2â€ƒChallenge Derivation

For epoch `t` with beacon `beacon_t`, expand domainâ€‘separated randomness to pick `q` **distinct symbol indices** per DU interval and `R` **PoDE windows** of size `W = 8â€¯MiB`. Selection MUST be moduloâ€‘biasâ€‘free.

###â€¯4.3â€ƒProver Obligations per DU Interval

1) **PoUD â€” KZGâ€‘PDP (content correctness):** Provide KZG **multiâ€‘open** at the chosen 1â€¯KiB symbol indices proving membership in `C_root`.
2) **PoDE â€” Timed derivation:** For each challenged window, compute `deriv = Derive(clear_window, beacon_salt, row_id)` and submit `H(deriv)` plus the **minimal** clear bytes for verifier recompute, all **within** the perâ€‘epoch `Î”_submit` window. Enforce **Î£ verified bytes â‰¥ B_min = 128â€¯MiB** over all windows and **R â‰¥ 16** subâ€‘challenges/window (defaults; DAOâ€‘tunable).
   **Normative (PoDE Linkage):** The prover MUST provide a KZG opening proof `Ï€_kzg` demonstrating that the `clear_window` input bytes correspond exactly to the data committed in `C_root`.

###â€¯4.4â€ƒVerifier (Onâ€‘chain / Watchers)

* **Onâ€‘chain:** Verify **KZG multiâ€‘open** against `C_root`; check counters for `R` and `B_min`.
* **Onâ€‘chain (PoDE):** Verify `Ï€_kzg` against `C_root` for the `clear_window`.
* **Watchers:** Verify PoDE recomputations and timing (RTTâ€‘oracle transcripts). Aggregate pass/fail into an onâ€‘chain digest per SP.

###â€¯4.5â€ƒCoverage & Parameters (Auditor math)

Let DU contain **M** symbols. With **q** fresh symbols per epoch over **T** epochs, the chance any symbol is never checked is `M Â· (1 âˆ’ q/M)^T`. Choose `qÂ·T` to push this below Î´ (e.g., 2â»Â¹Â²â¸) for the DU class. Governance publishes defaults and bounds.

###â€¯4.6â€ƒOnâ€‘chain Interfaces (normative)

L1 **MUST** expose: `verify_kzg_multiopen(...)`, `verify_poseidon_merkle(...)`, `blake2s(bytes)`. Proof acceptance window: `T_epoch = 86â€¯400â€¯s`, `Î”_submit = 30â€¯s`. Perâ€‘replica work bound used by timing invariants: `Î”_work = 1â€¯s`.

---

###â€¯4.1â€ƒReplicaâ€¯LayoutÂ (â€œRow/Column Modelâ€)

* `S`â€ƒâ€ƒâ€ƒÂ Sector size (bytes)
* `rows`â€ƒÂ `= S / 2â€¯MiB`Â Â Â Â Â Â Â Â Â Â Â Â Â (Row height fixed to 2â€¯MiB)
* `cols`â€ƒÂ `= 2â€¯MiB / 64â€¯B = 32â€¯768`Â (Each 64â€‘byte leaf index within a row)
* `window`Â `= 1â€¯MiB`Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â (Proof reads 8 adjacent windows, â‰¤â€¯6â€¯MiB)

A miner sealingÂ `S = 32â€¯GiB` obtains:

```
rows = 16â€¯384      (indexed 0 â€¦ 16â€¯383)
cols = 32â€¯768      (indexed 0 â€¦ 32â€¯767)
```

RowÂ `i` has two 1â€¯MiB windows **Wâ‚‚i** and **Wâ‚‚i+1**; their Merkle root is `h_row[i]`.  Their digest `Î”_row[i] = Blake2sâ€‘256(Wâ‚‚i â€– Wâ‚‚i+1)` is committed as `delta_head[i]` (Â§â€¯3.7).
**Merkle arity (normative option):** Implementations MAY use a higherâ€‘arity (e.g., 16â€‘ary) tree to reduce path length; if so, the sibling count and witness encoding MUST be reflected in Â§â€¯4.3.1 and AnnexÂ B KATs.

####â€¯4.1.1â€ƒScaffold profile (optional, normative)

Let `Ï†_seal âˆˆ (0,1]` be the sealedâ€‘row fraction (default `Ï†_seal = 1/32`). Only rows `i` with `(i mod 1/Ï†_seal == 0)` are sealed and committed (`h_row`, `delta_head`). PoSÂ² challenges target the sealed subset. Unsealed rows are excluded from PoSÂ² and MUST be covered by PoDE (metaspec Â§â€¯6.0b).

**Informative (relationship to NilFS shards).** Reedâ€“Solomon shards (metaspec Â§3.2) are **dataâ€‘layer** units that determine where bytes live on the network. After a shard reaches an SP, the shardâ€™s bytes are sealed into **sectors** and committed per this section. PoSÂ² operates on the sealed sectorâ€™s **row/column** layout (2â€¯MiB rows, 64â€¯B leaves) independent of how many NilFS shards contributed bytes to that sector. In other words: NilFS sharding affects placement and repair; PoSÂ² attests to liveness and integrity of whatever bytes are sealed in the sector.

###â€¯4.2â€ƒChallengeÂ DerivationÂ (Beacon Mix)

For epoch counter `ctr` and chain beacon blockâ€‘hash `B_t`:

```
Ï = Blake2sâ€‘256( "POSS2-MIX" â€– B_t â€– h_row_root â€– delta_head_root â€– miner_addr â€– ctr ) // 32 B
row = RejectionSample(u32_le(Ï[0..4]), rows)   // moduloâ€‘biasâ€‘free
col = RejectionSample(u32_le(Ï[4..8]), cols)  // moduloâ€‘biasâ€‘free
// RejectionSample(x, n): if n is a power of two, return x & (nâˆ’1). Else let t = floor(2^32 / n) * n computed in **u64** as `t = ( (1ULL<<32) / n ) * n`. If x < t return x % n; otherwise draw the next 32 bits from a **counterâ€‘mode** expansion `Blake2sâ€‘256("POSS2-MIX" â€– Ï â€– u64_le(counter++))` and retry.
offset = (row * 2â€¯MiB) + (col * 64 B)                        // byte index
```

The prover **must** read eight 1â€¯MiB windows covering
`offset - 3â€¯MiB â€¦ offset + 4â€¯MiB` (wrap moduloÂ `S`).  This is **â‰¤â€¯8â€¯MiB** I/O even when crossing a sector boundary.

####â€¯4.2.1â€ƒDU Origin Binding (linking mode, normative dial)

Let `p_link âˆˆ [0,1]` be a governance dial. For a `p_link`â€‘fraction of challenges in each epoch,
the prover MUST, in addition to Â§â€¯4.3, supply:

(a) Origin Map inclusion for row: a Poseidonâ€‘Merkle proof from `origin_root` (see Â§â€¯3.7.1)
    yielding `{du_id, sliver_index, symbol_range, C_root}` for the challenged row;

(b) Content opening: a KZG opening at a verifierâ€‘selected symbol index `j âˆˆ symbol_range`
    proving the 1â€¯KiB RS symbol(s) underlying the challenged `leaf64` belong to `C_root`;

(c) Seal derivation binding: a hash binding that the provided `leaf64` equals
    `SealTransform(clear_slice(j), beacon_salt, row)` under the active microâ€‘seal profile.

Chains implementing onâ€‘chain KZG precompiles MUST verify (b) onâ€‘chain; otherwise (b) MUST be
audited by watchers with fraudâ€‘proof slashing.

####â€¯4.2.2â€ƒPoDE challenges (Proofâ€‘of Delayed Encode, normative dial)

Let `p_derive âˆˆ [0,1]` be a governance dial. For a `p_derive`â€‘fraction of epochs (or equivalently, of an SPâ€™s perâ€‘epoch challenges), the prover MUST satisfy a derivation challenge tied to the clear DU bytes:

1. Provide a KZG opening against `C_root` proving that the verifierâ€‘selected 1â€¯KiB symbol(s) underlying the challenged row (per Â§â€¯4.2) are correct cleartext.
2. Using the active `micro_seal` profile (Â§â€¯3.4.3), derive the challenged `leaf64` deterministically from the opened clear symbols and the epoch beacon salt, and present the resulting `leaf64` and Merkle paths that match the posted roots.

Timing of derivation MUST respect the perâ€‘replica work bounds in Â§â€¯6.2. Chains with KZG precompiles MUST verify (1) onâ€‘chain; otherwise, auditors MUST verify (1) offâ€‘chain with fraudâ€‘proofs.

`ctr` increments monotonically; replaying an old proof with the same counter is rejected onâ€‘chain.
 

## Â§â€¯4â€²â€ƒProofâ€‘ofâ€‘Usefulâ€‘Data (PoUD) â€” plaintext mode (normative)

###â€¯4â€².0â€ƒScope

PoUD proves (a) content correctness for DU plaintext via KZG openings against `C_root`, and (b) timed derivations (PoDE) over 8â€¯MiB windows to enforce onâ€‘disk locality. It is the PRIMARY proof in plaintext mode (metaspec Â§â€¯6.0a).

###â€¯4â€².1â€ƒPublic Inputs

`{ du_id, C_root, epoch_id, indices[], beacon_t, R, B_min }`

###â€¯4â€².2â€ƒProver Obligations

1) KZG multiâ€‘open for `indices[]` (1â€¯KiB RS symbols) under `C_root`.
2) For each scheduled 8â€¯MiB window, compute `Derive(clear_window, beacon_salt, row_id)` (Â§â€¯3.3.1) and return `(leaf64, Î”_W)`. Derivations MUST complete before `Î”_submit` (metaspec Â§â€¯7.3).
   **Normative (Cryptographic Timing):** The `Derive` output MUST be used as input to a Verifiable Delay Function (VDF). The proof object includes the VDF output and proof: $\pi_{vdf} = VDF\_Prove(beacon_t, T_{vdf}, \Delta\_W)$. The VDF delay $T_{vdf}$ is governance-tunable and MUST satisfy $T_{derive} + T_{vdf} < \Delta_{submit}$.
3) Sum of verified bytes â‰¥ `B_min` and number of completed windows â‰¥ `R`.

###â€¯4â€².3â€ƒVerify API (DA chain precompiles)

`verify_poud(C_root, indices[], opens[], bytes[], leaf64[], Î”_W[], \pi_{vdf}[], R, B_min) â†’ bool`

â€¢ Multiâ€‘open check passes for all `indices[]` under `C_root`.
â€¢ For each window: recompute `Derive` and check `(leaf64, Î”_W)`.
â€¢ Verify VDF proof: $VDF\_Verify(beacon_t, T_{vdf}, \Delta\_W, \pi_{vdf})$.
â€¢ Enforce `R`, `B_min`.

###â€¯4â€².4â€ƒSecurity Notes

â€¢ Correctness reduces to KZG soundness; timing is cryptographically enforced by the VDF, removing reliance on watcher honesty for PoDE timing.
â€¢ PDPâ€‘PLUS coverage SLO is enforced by scheduler and governance (metaspec Â§â€¯6.0c).

Gas upper bound (NilStore L1): **â‰ˆâ€¯9.7k** assuming a **Blake2s precompile** with cost model `C_hash Ã— (#hashes) + C_misc`. This figure is **chainâ€‘specific** and MUST be reâ€‘benchmarked on parameter changes.

###â€¯4.6â€ƒPerformanceÂ Targets

| Step              | Disk I/O | CPU (ms) | Gas      |
| ----------------- | -------- | -------- | -------- |
| Prove (miner)     | â‰¤â€¯8â€¯MiB  | â‰¤â€¯50     | â€”        |
| Verify (onâ€‘chain) | â€”        | â€”        | â‰¤â€¯10â€¯000 |

###â€¯4.7â€ƒSecurityÂ AssertionsÂ (reference Â§â€¯7.5)

* **Soundness:** Any prover who forges `(row, col)` without the replica must break the collision resistance of Blake2s (Merkle path and row digest Î”).
* **Sequentiality:** Challenge uses fresh beacon hash `B_t`; proofs prepared in advance fail with overwhelming probability.
* **Window overlap:** Let Î² be the independent fault rate per window and let each proof check `w=8` adjacent 1â€¯MiB windows. Over `C` proofs/day, the miss probability is `(1âˆ’Î²)^{wC}`. To achieve â‰¤2â»Â¹Â¹â° with Î²=0.2 one needs `wC â‰¥ ceil(110Â·ln2 / (âˆ’ln(1âˆ’0.2))) = 342` total windows, i.e., `C â‰¥ 43` proofs/day for `w=8`. Networks MUST set the perâ€‘replica challenge rate accordingly and publish `C` in the dial profile.

###â€¯4.8â€ƒVersioning

`possÂ²` is bound to the dial profile.  Changing `(rows, window, hash)` requires a **minor** version bump (Â§â€¯0.3) and regenerated AnnexÂ B vectors.

---

###â€¯4.9â€ƒRetrieval Sampling (informative)

Retrieval sampling referenced by the metaspec is an auditâ€‘only mechanism that operates over bandwidthâ€‘receipt Merkle roots (`BW_root`) and watcher verification. It is orthogonal to `possÂ²` and does not alter circuits or public inputs.

â€¢ PoSÂ² inputs remain as defined in this section; the L2â€‘pinned `vk_hash` is unchanged.
â€¢ Sampling randomness derives from the VRF epoch beacon via Â§â€¯5.5.

*Sectionâ€¯Â§â€¯5 defines the Nilâ€‘VRF used to derive the `salt` input of `nilseal`, the proofâ€‘epoch beacon above, and the sampling seed used offâ€‘circuit by retrieval auditors.*

---

 
## Â§â€¯5â€ƒNilâ€‘VRFÂ / Epochâ€¯BeaconÂ (`nilvrf`)

###â€¯5.0â€ƒPurposeÂ &Â DesignÂ Choice

Nilcoin derives perâ€‘epoch randomness from a **BLS12â€‘381â€‘based Verifiable Random Function (VRF)** that is:

* **Uniquely provable** â€“ a single, deterministic proof per `(pk,msg)`.
* **Deterministically verifiable** onâ€‘chain with **one pairing**.
* **Aggregateâ€‘friendly** â€“ shares combine linearly (BATMAN threshold, â‰¥â€¯2/3 honest).

We instantiate a **BLSâ€‘signatureâ€‘based VRF**: VRF proofs are BLS signatures on `hash_to_G2(msg)`, and verification is a single pairing check. We follow **RFCâ€¯9380** for `hash_to_G2` (Simple SWU, XMD:SHAâ€‘256) with a Nilcoinâ€‘specific DST. **Note:** The IETF VRF standard **RFCâ€¯9381** does not define a BLS VRF; our construction relies on BLS signature **uniqueness**, which also implies an aggregator cannot grind the beacon by subset selection.  
DST (normative): `"BLS12381G2_XMD:SHA-256_SSWU_RO_NIL_VRF_H2G"`.

---

###â€¯5.1â€ƒNotation & Parameters

| Object | Group | Encoding   | Comment                             |
| ------ | ----- | ---------- | ----------------------------------- |
| `pk`   | `G1`  | 48â€¯B comp. | `pk = skÂ·Gâ‚`                        |
| `Ï€`    | `G2`  | 96â€¯B comp. | Proof (BLS signature)               |
| `H`    | `G2`  | 96â€¯B       | `H = hash_to_G2("NIL_VRF_H2G", msg)` |
| `e`    | â€”     | â€”          | Optimal Ate pairing `e: G1Ã—G2â†’G_T`  |
| `Hash` | â€”     | 32â€¯B       | Blake2sâ€‘256, domain `"NIL_VRF_OUT"` |

Curve: **BLS12â€‘381**; subgroup order
`r = 0x73EDA753299D7D483339D80809A1D80553BDA402FFFE5BFEFFFFFFFF00000001`.

---

###â€¯5.2â€ƒAlgorithmsÂ (IETF BLS VRF)

####â€¯5.2.1â€ƒKeyÂ Generation

```rust
fn vrf_keygen(rng) -> (sk: Scalar, pk: G1) {
    sk â†$ rng();                     // 1 â€¦ râˆ’1
    pk = sk Â· G1_GENERATOR;
    return (sk, pk);
}
```

####â€¯5.2.2â€ƒEvaluationÂ (`vrf_eval`)

```rust
fn vrf_eval(sk: Scalar, pk: G1, msg: &[u8]) -> (y: [u8;32], Ï€: G2) {
    H = hash_to_G2("NIL_VRF_H2G", msg); // RFC 9380 Simple SWU with DST
    Ï€ = sk Â· H;                          // BLS signature
    y = Blake2s-256("NIL_VRF_OUT" â€– compress(pk) â€– compress(H) â€– compress(Ï€));
    return (y, Ï€);
}
```

*The output `y` is the VRF value (32â€¯B); `Ï€` is the proof (96â€¯B).*

####â€¯5.2.3â€ƒVerificationÂ (`vrf_verify`)

```rust
fn vrf_verify(pk: G1, msg: &[u8], y: [u8;32], Ï€: G2) -> bool {
    H   = hash_to_G2("NIL_VRF_H2G", msg);
    ok  = (e(pk, H) == e(G1_GENERATOR, Ï€));      // one pairing + eq
    yâ€²  = Blake2s-256("NIL_VRF_OUT" â€– compress(pk) â€– compress(H) â€– compress(Ï€));
    return ok && (yâ€² == y);
}
```

Security follows directly from the EUFâ€‘CMA security of BLS signatures under the coâ€‘Gapâ€‘Diffieâ€‘Hellman assumption on BLS12â€‘381.

---

###â€¯5.3â€ƒEpochÂ BeaconÂ ( solo miner )

For epoch counter `ctr`:

```
(y, Ï€)   = vrf_eval(sk, pk, int_to_bytes_le(ctr, 8));
beacon_t = Blake2sâ€‘256("NIL_BEACON" â€– y);
```

The 32â€‘byte `beacon_t` feeds **Â§â€¯4.2** challenge derivation and seeds the retrievalâ€‘sampling RNG per **Â§â€¯5.7**.

---

###â€¯5.4â€ƒBATMAN Threshold Aggregation (tÂ â‰¥â€¯2/3)

####â€¯5.4.1â€ƒSetup

* Committee sizeÂ `N`; thresholdÂ `t = âŒˆ2N/3âŒ‰`.
* Polynomial secret sharing: master key `s (= sk_master)` split into `sk_i = f(i)` degreeÂ `d = Nâˆ’t`.
* Public key shares `pk_i = sk_iÂ·G1`.
* Proof of Possession (PoP): each participant MUST provide a signature `pop_i = Sign(sk_i, pk_i)` during registration to prevent rogueâ€‘key attacks.
* Constant public coefficients for Lagrange interpolation moduloÂ `r`.

####â€¯5.4.2â€ƒPerâ€‘epoch share posting

Each participantÂ `i` publishes `(pk_i, Ï€_i)` where

```
Ï€_i = sk_i Â· H(epoch_ctr);
```

No `y_i` is required.

####â€¯5.4.3â€ƒAggregator

Collect any `t` valid shares; compute Lagrange coefficients `Î»_i` inÂ â„¤\_r:

```
Ï€_agg = Î£ Î»_i Â· Ï€_i          âˆˆ G2           // 96â€¯bytes
```

(No pairing, no `G_T` exponentiation.)

**Deterministic Shareâ€‘Selection (Normative, strengthened):** Participants MUST post `(pk_i, Ï€_i)` **on L1** before `Ï„_close`. The aggregator MUST:
  (a) derive the candidate set **exclusively** from the onâ€‘chain arrivals;
  (b) select the lexicographically smallest `t` shares under the ordering key
```
share_id_i := Blake2sâ€‘256("BATMAN-SHARE" â€– compress(pk_i) â€– u64_le(epoch_ctr))
```
/* Grinding Mitigation (Normative):
1. Collect all valid shares posted on L1 before `Ï„_close`.
2. Let `Seed_select` be the VRF beacon of the block immediately following `Ï„_close`.
3. If > t shares are available, select the `t` shares that minimize `HMAC-SHA256(Seed_select, share_id_i)`.
*/

Publish `(Ï€_agg, pk_agg)` where `pk_agg = Î£ Î»_i Â· pk_i`.

####â€¯5.4.4â€ƒOnâ€‘chain Verification & Beacon

```solidity
function verify_beacon(
    bytes48 pkAgg, bytes96 piAgg, bytes8 ctr
) returns (bytes32 beacon)
{
    G2 H = hash_to_G2("NIL_VRF_H2G", ctr);
    require( pairing(pkAgg, H) == pairing(G1_GEN, piAgg) );
    bytes32 y  = blake2s256(
        "NIL_VRF_OUT" â€– compress(pkAgg) â€– compress(H) â€– compress(piAgg)
    );
    return blake2s256("NIL_BEACON" â€– y);
}
```

*Gas:* **â‰ˆâ€¯97â€¯k** (1 pairing + hashes), independent of `N`.

---

###â€¯5.5â€ƒParameter Changes & Versioning

| Parameter                     | Governance tier | Effect                          |
| ----------------------------- | --------------- | ------------------------------- |
| Curve ID, hashâ€‘toâ€‘curve map   | **major**       | Affects security level          |
| Output hash (Blake2 â†’ BLAKE3) | **minor**       | Beacon derivation               |
| Threshold `t` (`N` fixed)     | **minor**       | Liveness vs. security tradeâ€‘off |

All changes require updated KATs in Annexâ€¯A.5.

---

###â€¯5.6â€ƒKnownâ€‘Answer TestsÂ (Annexâ€¯A.5)

* Deterministic `vrf_keygen` seeds via ChaCha20(`seed=1`).
* Solo VRF vectors: `(msg, pk, Ï€, y)`.
* BATMAN vectors: `(ctr, pkAgg, piAgg, beacon)` for `N=5`, `t=4`.

---

###â€¯5.7â€ƒSampling Seed & Expansion (normative)

NilStoreâ€™s retrievalâ€‘sampling RNG derives from the epoch beacon and does not interact with any `possÂ²` circuit.

Definition (perâ€‘epoch):

```
seed_t := Blake2sâ€‘256("NilStore-Sample" â€– beacon_t â€– epoch_id)
```

Expansion (deterministic PRF stream for sampling indices):

```
ExpandSample(seed_t, i) := Blake2sâ€‘256("SAMPLE-EXP" â€– seed_t â€– u32_le(i))
```

Notes:
- `seed_t` and `ExpandSample` are used offâ€‘chain by watchers/validators to select receipts for auditing.
- Domain strings are fixed ASCII constants (see Â§â€¯0.4.1).
- No changes to `possÂ²` public inputs or verification keys.

*Sectionsâ€¯Â§â€¯6â€¯throughâ€¯Â§â€¯9 discuss governance, security proofs, and performance metrics building on this VRF construction.*


---

## Â§â€¯6â€ƒGovernanceâ€‘Tunable Dialâ€¯Policy

###â€¯6.0â€ƒGovernance Bodies

| Abbrev. | Role                                         | Quorum / Majority       |
| ------- | -------------------------------------------- | ----------------------- |
| **NC**  | Nilcoin Council (foundation board)           | 2â€¯/â€¯3 of seated members |
| **MC**  | Miner Caucus (â‰¥â€¯1â€¯PiB sealed)                | 60â€¯% by sealed capacity |
| **TC**  | Technical Committee (elected cryptographers) | simple majority         |

The **Council** enacts parameter changes after receiving a recommendation from the Technical Committee and, when required, consent of the Miner Caucus.

###â€¯6.1â€ƒTunables & Version Impact

| Parameter        | Symbol | Units  | Version bump           |
| ---------------- | ------ | ------ | ---------------------- |
| Field modulus    | `q`    | bits   | **major**              |
| Vector length    | `m`    | limbs  | **major**              |
| NTT block size   | `k`    | limbs  | **minor**              |
| Shear passes     | `r`    | count  | **minor**              |
| Gaussian Ïƒ       | `Î»`    | Ïƒ/Ïƒ\_Q | **minor**              |
| Argon2 passes    | `H`    | count  | **minor**              |
| Interleave frag. | `Î³`    | MiB    | **minor**              |
| Proof deadline   | `Î”`    | sec    | **governance runtime** |
| PoDE windows     | `W`    | bytes  | **governance runtime** |
| PoDE subâ€‘challs  | `R`    | count  | **governance runtime** |
| Verified bytes   | `B_min`| bytes  | **governance runtime** |

###â€¯6.2â€ƒSecurity Invariant

**Plaintext primacy:** All content checks and repairs **open against `C_root`** (cleartext).

When Annex A is enabled, additionally require:

```
t_recreate_replica(row)  â‰¥  5 Â· Î”_work
```

`Î”_work` is the **perâ€‘replica work bound** (default 1â€¯s in baseline profile) and is related to the metaspecâ€™s network window `Î”_submit` (default 30â€¯s) via `Î”_work â‰ª Î”_submit`. Any dial proposal must empirically demonstrate that honest hardware meets the inequality while an emptyâ€‘disk adversary does not.

**Additional invariants (normative):**

* **Bound tightness:** Use 12â€‘bit limbs and enforce `Î² = 4095` (Sâ€‘512). CRT is mandatory (`Q = qâ‚Â·qâ‚‚ â‰ˆ 2^60`).
* **Permutation passes:** `r â‰¥ 3` for mainâ€‘net profiles.
* **NTT block size:** `k â‰¥ 64`; increases require updated Annexâ€¯A KATs.
* **Challenge sampling:** Moduloâ€‘biasâ€‘free selection required (Â§â€¯4.2); profiles that change `rows`/`cols` MUST preserve this.

###â€¯6.3â€ƒReview Cadence & Metrics

* **Quarterly Review** â€“ Technical Committee publishes anonymised telemetry:

  * median seal time,
  * 95â€¯th percentile seal time,
  * proof acceptance ratio,
  * network storage growth.

* **Trigger condition** â€“ If â‰¥â€¯75â€¯% of proofs arrive in <â€¯0.3â€¯Î”, the TC issues a **dialâ€‘tightening recommendation**.

###â€¯6.4â€ƒAdjustment Ruleâ€‘Set

Priority order (apply only one per quarter):

| Rank | Action                               | Constraint              |
| ---- | ------------------------------------ | ----------------------- |
| â€¯1â€¯  | Shorten `Î”` (preferred)              | `Î”Â â‰¥Â 30â€¯s`              |
| â€¯2â€¯  | â†‘Â `k` or â†‘Â `r` by 1â€¯step             | not both simultaneously |
| â€¯3â€¯  | â†‘Â `H` byâ€¯1Â (pass)                    | `HÂ â‰¤Â 2`                 |
| â€¯4â€¯  | â†‘Â `Î»` byÂ 20 (fixedâ€‘point)             | `Î»Â â‰¤Â 500`               |
| â€¯5â€¯  | Set `Î³ = 4â€¯MiB` *(requires MC vote)* | HDD impact analysis     |

###â€¯6.5â€ƒProposal & Activation Timeline

| Phase                                | Duration | Required vote                 |
| ------------------------------------ | -------- | ----------------------------- |
| Draft (TC)                           | 7â€¯d      | â€”                             |
| Public comment                       | 14â€¯d     | â€”                             |
| Council vote                         | 5â€¯d      | 2â€¯/â€¯3 NC                      |
| Miner Caucus vote *(Î³Â changes only)* | 7â€¯d      | 60â€¯% capacity                 |
| Testnet bakeâ€‘in                      | 14â€¯d     | â€”                             |
| Mainâ€‘net activation                  | â€”        | blk\_heightÂ +Â 5â€¯216 (â‰ˆâ€¯1â€¯day) |

A failed vote resets the dial to its previous state.

**Window finalization rule (normative):** During each timeline phase or audit window, any task that is **started** MUST be **finished** within that window by publishing its transcript in `_artifacts/` (added to `SHA256SUMS`). Incomplete changes are **reverted** before the window closes; partial artifacts MUST NOT be carried forward.

###â€¯6.6â€ƒFrozen Reference Profiles

| ID           | Purpose              | m     | k   | r | Î»   | H | Î³     | Î”    |
| ------------ | -------------------- | ----- | --- | - | --- | - | ----- | ---- |
| **Sâ€‘512**    | Baseline (CPU/mem)   | 1â€¯024 | 128 | 3 | 350 | 2 | 0     | 60â€¯s |
| **Sâ€‘1024â€‘A** | Archival, high hard. | 2â€¯048 | 256 | 4 | 400 | 2 | 2â€¯MiB | 30â€¯s |

Profile strings are **immutable identifiers**; new profiles append rows.

###â€¯6.7â€ƒGovernance Dials (linking/derivation)

The following protocol dials control optional contentâ€‘binding and derivation workload. All changes MUST respect the chainâ€™s Verification Load Cap (metaspec Â§â€¯6.1) and follow Â§â€¯6.5.

- `p_link âˆˆ [0,1]` â€” Fraction of PoSÂ² challenges that require DU Origin Binding per Â§â€¯4.2.1. Default 0.05. Onâ€‘chain KZG required where available.
- `p_derive âˆˆ [0,1]` â€” Fraction of PoSÂ² challenges (or epochs) that require PoDE per Â§â€¯4.2.2. Default 0.01. Requires `micro_seal = row` profile and published KATs.
- `micro_seal âˆˆ {off,row}` â€” Localizes sealing to 2â€¯MiB rows for derivation (Â§â€¯3.4.3). Default `off` in baseline Sâ€‘512.

Defaults for plaintext mode (normative):
â€¢ `micro_seal = row` (REQUIRED)
â€¢ `p_link â‰¥ 0.05` (DU origin binding in a subset of challenges)
â€¢ `p_derive â‰¥ 0.01`; `R â‰¥ 16`; `B_min â‰¥ 128â€¯MiB`
â€¢ `p_kzg â‰¥ 0.05` (receiptâ€‘level content checks, metaspec Â§â€¯6.3.4)
â€¢ `CoverageTargetDays = 365` (metaspec Â§â€¯6.0c)

Guardâ€‘rails:
- `p_link + p_derive` MAY be capped by governance to satisfy the Verification Load Cap.
- Enabling `micro_seal = row` MUST NOT change digest roots outside Â§â€¯4 linking/derivation mode; equivalence MUST be demonstrated via Annex A/B KATs.

---

## Â§â€¯7â€ƒSecurityâ€¯Rationaleâ€¯&â€¯Proofs

###â€¯7.1â€ƒThreat Model & Goals

* Adversaries may control arbitrary compute and storage, but not break standard cryptographic assumptions.
* GoalÂ 1â€¯â€”â€¯**Sound replication**: forging a proof without the replica requires â‰¥â€¯Îµâ€‘negligible probability.
* GoalÂ 2â€¯â€”â€¯**Sequential work**: recomputing a replica in timeÂ <â€¯`Î”/5` is infeasible.
* GoalÂ 3â€¯â€”â€¯**Biasâ€‘free randomness**: beacon output unpredictable until VRF proofs are posted.

###â€¯7.2â€ƒCore Assumptions

| #    | Assumption                                     | Reference      |
| ---- | ---------------------------------------------- | -------------- |
| â€¯A1â€¯ | Blake2s acts as a random oracle in our domains | NIST, RFCÂ 7693 |
| â€¯A2â€¯ | BLS12â€‘381 pairing hardness (coâ€‘Gap DH)         | CFRG draft     |
| â€¯A3â€¯ | Moduleâ€‘SIS(m,Q,Î²) with `m=1024, Q=qâ‚Â·qâ‚‚â‰ˆ2â¶â°, Î²=4095` provides â‰¥â€¯2Â¹Â²â¸â€‘bit security. The witness bound (â‰ˆ8190) is significantly below the Gaussian Heuristic (â‰ˆ31595). Justification requires a published estimator run (e.g., Albrecht estimator) explicitly accounting for the circulant/module structure. |
| â€¯A4â€¯ | Disk bandwidth â‰¥â€¯400â€¯MB/s (SSD profile)        | 2025 median    |

 
###â€¯7.3â€ƒ`nilfield`â€¯+â€¯`nilhash`

* **Binding** â€“ Under the enforced bound `||r||_âˆ â‰¤ Î²` (verified by Ï€), two openings (x,r) â‰  (xâ€²,râ€²) yield a **short nonâ€‘zero** kernel vector `(Î”x,Î”r)` of `(Aâ€–B)` with `||Î”x||_âˆ â‰¤ 4095` (12â€‘bit limbs) and `||Î”r||_âˆ â‰¤ 2Î²` (=8190). Since A and B are circulant, finding such a vector solves an instance of **Moduleâ€‘SIS** over ğ”½_q (or ğ”½_{qâ‚}Ã—ğ”½_{qâ‚‚} under CRT) at parameters (m,q,Î²) (Assumption A3).
* **Hiding** â€“ The commitment is statistically revealing (see Â§ 2.2).

###â€¯7.4â€ƒ`nilseal`

####â€¯7.4.1â€ƒSequentialâ€‘Work Proof

* Passâ€¯`p` depends on `Î¶_p` (256-bit), a Blake2sâ€‘256 hash (with domain tag "NIL_SEAL_ZETA") of the IteratedHash over perâ€‘chunk Blake2sâ€‘256 digests of passâ€¯`pâˆ’1` data.
* Any strategy to pipeline passes must predict 256â€‘bit hash preâ€‘images â†’ breaks Assumptionâ€¯A1.

Hence an adversary must complete passâ€¯`pâˆ’1` before starting passâ€¯`p`, giving a lowerâ€‘bound time `â‰¥Â r Â· S / disk_bw`.

####â€¯7.4.2â€ƒReplica Indistinguishability

Gaussian noise (Ïƒ set by `Î»`, Â§â€¯3.5) aims to mask structure; precise entropy depends on Ïƒ relative to `Q` and quantization. Implementations MUST publish empirical tests (minâ€‘entropy estimate and Ï‡Â²) for the active `Î»`, and the specification makes **no unconditional â‰¤2â»Â¹Â²â¸** distance claim without that evidence.

###â€¯7.5â€ƒPoUD + PoDE (plaintext)

* **Soundness (PoUD):** Forging a membership opening without holding the symbol set breaks KZG binding.
* **Timing (PoDE):** Windowâ€‘local `Derive` is beaconâ€‘salted and reâ€‘computable from plaintext only; providing it within `Î”_submit` implies local possession given `Î”_work` vs network RTT and disk bandwidth assumptions.
* **Fullâ€‘file coverage:** With qÂ·T chosen per Â§â€¯4.5, the probability of any symbol escaping audit is â‰¤â€¯Î´ for the declared DU class.

###â€¯7.6â€ƒ(Annex A) PoSÂ²â€‘L
See Annex A for sealedâ€‘replica assertions; not active in the baseline mode.

 
###â€¯7.7â€ƒ`nilvrf`

* **Uniqueness** â€“ BLS signature uniqueness (Assumptionâ€¯A2).
* **Pseudorandomness** â€“ EUFâ€‘CMA security â‡’ VRF pseudorandomness under randomâ€‘oracle model (A1, A2).
* **BATMAN soundness** â€“ With â‰¥â€¯t shares, Lagrange coefficients reconstruct the master secretâ€™s signature; forging output without t shards breaks BLS.

###â€¯7.7â€ƒComposition

* Beacon unpredictability (VRF) feeds seal offset; circularity avoided because VRF input (epoch counter) is independent of replica data.
* Replay attacks blocked by `ctr` monotonicity (Sectionâ€¯4.2).
* Grinding resistance: beacon derives from VRF output with domainâ€‘separated hash; miners cannot bias it without breaking VRF security.

---

*The security analyses are highâ€‘level sketches; full algebraic reductions and concrete bounds are archived in the Nilcoin Research whiteâ€‘papers (link in Appendixâ€¯E).*

---

## Â§â€¯8â€ƒReferenceâ€¯ImplementationsÂ (normative status matrix)

| Lang / Crate                  | Dial coverage | CI status | Constantâ€‘time audit                  | Fuzz coverage        |
| ----------------------------- | ------------- | --------- | ------------------------------------ | -------------------- |
| **Rust**Â `nilcipher` (noâ€‘std) | Sâ€‘512         | âœ” main    | ctgrindâ€¯0 findings, dudectÂ Î”tâ€¯â‰¤â€¯4â€¯ns | AFL++â€¯â‰¥â€¯1â€¯M exec/day |
| **Go**Â `nilgo`                | Sâ€‘512         | âœ” main    | dudect Î”tâ€¯â‰¤â€¯5â€¯ns                     | goâ€‘fuzzÂ 100â€¯k/min    |
| **WASM**Â `nilwasm`            | Sâ€‘512         | beta      | N/A (no secret)                      | unit tests           |
| **Python**Â `nilpy` (edu)      | Sâ€‘512         | pass      | not CT                               | â€”                    |

*All reference crates MUST pass Annexâ€¯A/B KATs on CI.* In addition, CI MUST run the reproducibility targets from Â§â€¯0.6 (`make prp-kat`, `reject-sample`, `noise-kat`, `poss2-derive`, `vrf-dst`, `publish`) and attach `_artifacts/` + `SHA256SUMS` to the build artifacts.
Vendors may implement alternative languages provided they embed the exact constants from Annexâ€¯C and pass the same KAT suite.

---

## Â§â€¯9â€ƒPerformanceâ€¯BenchmarksÂ (informative)

| Task @â€¯baseline profile **Sâ€‘512** | 8â€‘core 2025 CPUÂ (3â€¯.8â€¯GHz) | 4Ã— NVMe SSDÂ (7â€¯GB/s agg.) |
| -------------------------------- | -------------------------- | ------------------------- |
| **Seal 32â€¯GiB**                  | 8â€¯minÂ 14â€¯s                 | I/Oâ€‘bound                 |
| **Reâ€‘seal 32â€¯GiB (resume)**      | 42â€¯s                       | â€”                         |
| **PoDE window (8â€¯MiB) derive**   | ~â€¯tens of ms               | inâ€‘RAM                    |
| **Onâ€‘chain verify**              | â€”                          | 9â€¯698â€¯gas                 |
| **VRF verify (solo)**            | â€”                          | 97â€¯kâ€¯gas                  |
| **BATMAN verify (N=5,â€¯t=4)**     | â€”                          | 99â€¯kâ€¯gas                  |

Measurements taken on Ubuntuâ€¯24.04, RustÂ 1.79 `-C target-cpu=native`.

---

## Annexâ€¯Aâ€ƒKnownâ€‘Answer Tests (normative, machineâ€‘readable)

*Directory:* `spec/v2.0/kats/`

| File           | Content                                                                   |
| -------------- | ------------------------------------------------------------------------- |
| `field.toml`   | Add / Sub / Mul / Inv vectors for 10â€¯000 pseudorandom pairs               |
| `ntt64.toml`   | Forward + inverse roundâ€‘trips for unit basis and random inputs            |
| `nilseal_prp.toml` | 20â€‘round Feistel PRP roundâ€‘trip vectors (keyed BLAKE2s, no cycleâ€‘walk) |
| `nilhash.toml` | h^{(1)} (qâ‚), h^{(2)} (qâ‚‚), digests, and Ï€ transcripts (Î²=4095) |
| `noise_seed.toml`  | Deterministic noise seeds & first 4 CTR blocks per (row,window,pass)   |
| `vrf.toml`     | Key, proof, output vectors for solo and BATMAN aggregation                |
| `vrf_beacon.toml` | Inputs and outputs for `"NIL_BEACON"` â†’ `beacon_t` derivation          |
| `sampling_seed.toml` | `(epoch_id, beacon_t)` â†’ `seed_t` and first 4 `ExpandSample` outputs |
| `constants_q2` | qâ‚‚ constants (Ïˆâ‚–, kâ»Â¹, Montgomery)                                        |

All decimal values are littleâ€‘endian; group elements are compressed hex.

### A.3â€ƒNilhash Rangeâ€‘Proof Ï€ Encoding (normative)

- Domain tag: `"NILHASH-RANGE"` (ASCII), transcript uses Blake2sâ€‘256 (RO model).
- Public params bound into transcript: `Version`, `DID`, `qâ‚`, `qâ‚‚`, `m`, `Î²`.
- Statement: â€œAll limbs of r satisfy |r_i| â‰¤ Î²â€ for the `m`â€‘vector r per enabled prime.
- Aggregation: a single Ï€ covers all m limbs (and both primes) via innerâ€‘product style aggregation.
- Verify steps (high level):
  - Recompute `x = SVT(pad(msg))`, apply domain twist; check `h == A_twistedÂ·x + BÂ·r` per prime.
  - Run Ï€ verification against the bound `Î²` with the same transcript parameters.
- Size/perf guidance: Ï€ â‰ˆ 1.6â€“2.0â€¯kB at mâ€¯=â€¯1â€¯024; verify â‰ˆ 1â€“2â€¯ms CPU; prove â‰ˆ 3â€“6â€¯ms CPU.


---

## Annexâ€¯Bâ€ƒExtendedâ€¯Codec / PoSSÂ² VectorsÂ (normative)

*Directory:* `spec/v2.0/annexB/`

* 2â€¯GiB miniature replica, complete rowâ€‘byâ€‘row `h_row` and `delta_head`.
* Randomness robustness test: 1â€¯000 beacon challenges with expected offsets.
* Timing corpus for sequentialâ€‘work proof replay.

---

## Annexâ€¯Câ€ƒConstantâ€‘Generation ScriptÂ (normative)

`appendix_c_constants.py` â€“ *identical to listing in Â§â€¯1 but provided as
an executable file.*
Running

```
$ python3 appendix_c_constants.py 998244353 3 > constants.txt
```

MUST reproduce **exactly** the table published in Â§â€¯1.1 and the first rows of `field.toml`.

---

## Appendixâ€¯Dâ€ƒChangeâ€‘Log (informative, excerpt)

* **vâ€¯2.0 vsâ€¯vâ€¯1.0** â€“ prime upgrade (qâ‚), Pedersen commitment, dataâ€‘dependent PRP permutation, Gaussian noise, BATMAN VRF, security consolidation.
* **Breaking changes** â€“ commitment vectors no longer open perâ€‘limb; all sealers must regenerate replicas; proofs unaffected.
* **Deprecations** â€“ legacy â€œnilâ€‘shuffleâ€/â€œshear permutationâ€ terminology replaced by â€œPRP permutationâ€.

â€”

### vâ€¯2.0â€‘final (nilhash binding + CRT mandatory)

- Core focuses on **KZG** contentâ€‘correctness (PoUD) and **PoDE** derivations; sealedâ€‘replica and nilâ€‘lattice commitments have been **archived** to rfcs/PoS2L_scaffold_v1.md for researchâ€‘only use.
- Profiles: consolidated to `Sâ€‘512` baseline; removed `Sâ€‘q1` family (Â§â€¯6.6).

Full git diff: `<https://github.com/nilcoin/spec/compare/v1.0...v2.0>`.

---

## Appendixâ€¯Eâ€ƒFutureâ€¯Work (informative)

1. **Selective disclosures** â€“ Bulletproofâ€‘style innerâ€‘product argument for limbâ€‘specific openings (target vâ€¯2.1).
2. **Postâ€‘quantum VRF** â€“ Explore pairingâ€‘free VRFs (e.g., SQIsignâ€‘VRF) once NIST PQC signatures are standardised.
3. **Larger field modulus** â€“ `q â‰ˆ 2^36` to raise SIS margin; requires 128â€‘bit limbs or multiâ€‘precision Montgomery.
4. **Hardware proofs** â€“ Investigate STARKâ€‘based `possÂ²` verifier to remove pairing preâ€‘compile.
5. **Green sealing** â€“ Dial profiles optimised for lowâ€‘power ARM + eMMC miners.

---

### Releaseâ€¯Packageâ€¯ChecklistÂ (completed)

* [x] `spec_v2.0.pdf` / `spec_v2.0.md` (this document)
* [x] Annexâ€¯A/B KAT directories (â‰ˆâ€¯8â€¯MiB compressed)
* [x] Annexâ€¯C script (+Â sha256sum in README)
* [x] Reference implementation tags (`nilcipherâ€‘v2.0`, `nilgoâ€‘v2.0`)
* [x] CI badge: **green** (#â€¯buildÂ â–¢764)
* [x] Reproducibility kit (`_artifacts/` + `SHA256SUMS`) and scripts (`make publish`) regenerating all published numbers

The Nilcoin Council hereby designates Versionâ€¯2.0 as the **canonical spec** for mainâ€‘net activation at heightâ€¯â–¢H\_ACT (approx. â–¢2025â€‘MMâ€‘DDÂ UTC).

*End of Specification.*
