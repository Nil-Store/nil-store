#!/bin/bash
set -e

# End-to-End Retrieval Receipt Test (Triple Proof)
# Usage: ./e2e_retrieval.sh

BINARY="./nilchaind"
NIL_CLI="./nil_cli/target/release/nil_cli"
CHAIN_ID="nilchain"
HOME_DIR="./.nilchain_retrieval"
MDU_FILE="./test_retrieval_mdu.dat" # Will be generated by sharding
INPUT_FILE="./test_input_1mb.bin"
SHARD_OUTPUT="./test_input_1mb.bin.json"
MANIFEST_FILE="./test_manifest.bin"
RECEIPT_FILE="./receipt.json"
TRUSTED_SETUP="$(pwd)/nilchain/trusted_setup.txt"

# Helper for hex decoding
python3 -c "import sys; print(bytes.fromhex(sys.argv[1][2:]).decode('latin1'))" 2>/dev/null || true

# Ensure binaries are built
echo ">>> Building binaries..."
touch nil_core/src/lib.rs
cd nil_core && cargo build --release --features debug-print && cd ..
cp nil_core/target/release/libnil_core.dylib . 2>/dev/null || cp nil_core/target/release/libnil_core.so . 2>/dev/null || true
cd nilchain && go clean -cache && go build -o ../nilchaind ./cmd/nilchaind && cd ..
cd nil_cli && cargo build --release && cd ..

export DYLD_LIBRARY_PATH=$(pwd):$DYLD_LIBRARY_PATH
export LD_LIBRARY_PATH=$(pwd):$LD_LIBRARY_PATH

# Clean start
echo ">>> Resetting chain..."
pkill -f nilchaind || true
rm -rf $HOME_DIR
$BINARY init mynode --chain-id $CHAIN_ID --home $HOME_DIR > /dev/null 2>&1
$BINARY config set client chain-id $CHAIN_ID --home $HOME_DIR
$BINARY config set client keyring-backend test --home $HOME_DIR

# Create accounts
echo ">>> Creating accounts..."
yes | $BINARY keys add user --home $HOME_DIR --keyring-backend test > /dev/null 2>&1
for i in {1..12}
do
   yes | $BINARY keys add "provider$i" --home $HOME_DIR --keyring-backend test > /dev/null 2>&1
done

USER_ADDR=$($BINARY keys show user -a --home $HOME_DIR --keyring-backend test)
PROVIDER1_ADDR=$($BINARY keys show provider1 -a --home $HOME_DIR --keyring-backend test)

# Add genesis accounts
# We give accounts 'aatom' (for EVM) and 'stake' (for consensus).
# User needs enough stake for Gentx (100M) AND Deal Escrow (1000). So giving 200M stake.
$BINARY genesis add-genesis-account "$USER_ADDR" 100000000000token,200000000stake,100000000000000000000aatom --home $HOME_DIR
for i in {1..12}
do
   PROV_ADDR=$($BINARY keys show "provider$i" -a --home $HOME_DIR --keyring-backend test)
   $BINARY genesis add-genesis-account "$PROV_ADDR" 1000000000token,1000000stake,10000000000000000000aatom --home $HOME_DIR
done

$BINARY genesis gentx user 100000000stake --chain-id $CHAIN_ID --home $HOME_DIR --keyring-backend test > /dev/null 2>&1
$BINARY genesis collect-gentxs --home $HOME_DIR > /dev/null 2>&1

# Inject EVM Denom Metadata (required for Ethermint to start)
echo ">>> Injecting EVM denom metadata..."
jq '.app_state.bank.denom_metadata += [{
  "description": "The native EVM token",
  "denom_units": [
    {"denom": "aatom", "exponent": 0, "aliases": ["atto"]},
    {"denom": "atom", "exponent": 18, "aliases": []}
  ],
  "base": "aatom",
  "display": "atom",
  "name": "Atom",
  "symbol": "ATOM"
}]' $HOME_DIR/config/genesis.json > $HOME_DIR/config/genesis.json.tmp && mv $HOME_DIR/config/genesis.json.tmp $HOME_DIR/config/genesis.json

# Config: Fast blocks
sed -i.bak 's/timeout_commit = "5s"/timeout_commit = "1s"/' $HOME_DIR/config/config.toml
sed -i.bak 's/minimum-gas-prices = ""/minimum-gas-prices = "0token"/' $HOME_DIR/config/app.toml

# Start Chain
echo ">>> Starting chain..."
export KZG_TRUSTED_SETUP=$TRUSTED_SETUP
$BINARY start --home $HOME_DIR --log_level info > $HOME_DIR/chain.log 2>&1 &
PID=$!

# Wait for start
echo ">>> Waiting for chain start..."
STARTED=false
for i in {1..30}; do
    if ! kill -0 $PID 2>/dev/null; then
        echo "CRITICAL: Chain process died!"
        cat $HOME_DIR/chain.log
        exit 1
    fi

    STATUS=$(curl -s --max-time 2 http://127.0.0.1:26657/status || echo "")
    if [ -n "$STATUS" ]; then
        HEIGHT=$(echo "$STATUS" | jq -r '.result.sync_info.latest_block_height' 2>/dev/null)
        if [[ -n "$HEIGHT" && "$HEIGHT" != "null" && "$HEIGHT" != "0" ]]; then
            echo "Chain started at height $HEIGHT."
            STARTED=true
            break
        fi
    fi
    sleep 1
done

if [ "$STARTED" = false ]; then
    echo "TIMEOUT: Chain failed to start."
    cat $HOME_DIR/chain.log
    kill $PID
    exit 1
fi

# Register Providers
echo ">>> Registering Providers..."
for i in {1..12}
do
   yes | $BINARY tx nilchain register-provider General 1000000000 --from "provider$i" --chain-id $CHAIN_ID --yes --home $HOME_DIR --keyring-backend test --broadcast-mode sync --node tcp://127.0.0.1:26657 > /dev/null
done

# 1. Prepare Data
echo ">>> Generating Data..."
dd if=/dev/urandom of=$INPUT_FILE bs=1024 count=1024 2>/dev/null # 1MB

echo ">>> Sharding Data..."
# This generates ./test_input_1mb.bin.json AND ./test_input_1mb.bin.mdu.0.bin (the encoded MDU)
$NIL_CLI --trusted-setup $TRUSTED_SETUP shard $INPUT_FILE --out $SHARD_OUTPUT --save-mdu-prefix "$INPUT_FILE"

# Extract CID and Manifest Blob
MANIFEST_ROOT=$(jq -r '.manifest_root_hex' $SHARD_OUTPUT)
MANIFEST_BLOB_HEX=$(jq -r '.manifest_blob_hex' $SHARD_OUTPUT)
SIZE=$(jq -r '.file_size_bytes' $SHARD_OUTPUT)

echo "   CID: $MANIFEST_ROOT"
echo "   Size: $SIZE"

# Use the generated encoded MDU for the receipt
MDU_FILE="${INPUT_FILE}.mdu.0.bin"

# Save Manifest Blob to file (binary)
python3 -c "import sys; sys.stdout.buffer.write(bytes.fromhex('$MANIFEST_BLOB_HEX'[2:]))" > $MANIFEST_FILE

# 2. Create Deal (Alloc)
echo ">>> Creating Deal (Alloc)..."
# Duration 100. Escrow 1000000. Spend 5000.
CREATE_RES=$(yes | $BINARY tx nilchain create-deal 100 1000000 5000 --service-hint "General" --from user --chain-id $CHAIN_ID --yes --home $HOME_DIR --keyring-backend test --broadcast-mode sync --node tcp://127.0.0.1:26657 --output json)
CREATE_HASH=$(echo $CREATE_RES | jq -r '.txhash')

echo ">>> Waiting for CreateDeal (Tx: $CREATE_HASH)..."
sleep 6

# Query Tx to get logs
TX_JSON=$($BINARY query tx $CREATE_HASH --home $HOME_DIR --node tcp://127.0.0.1:26657 --output json)
echo "CreateDeal Tx Result: $TX_JSON"

DEAL_ID=$(echo "$TX_JSON" | jq -r '(.logs[0].events[]? // .events[]?) | select(.type=="create_deal") | .attributes[] | select(.key=="deal_id") | .value' 2>/dev/null | head -n 1 || echo "")

if [ -z "$DEAL_ID" ] || [ "$DEAL_ID" == "null" ]; then
    echo "ERROR: Failed to create deal or parse Deal ID."
    echo "Tx JSON: $TX_JSON"
    exit 1
fi

echo ">>> Deal Created with ID: $DEAL_ID"

# 3. Commit Content
echo ">>> Committing Content..."
yes | $BINARY tx nilchain update-deal-content --deal-id $DEAL_ID --cid $MANIFEST_ROOT --size $SIZE --from user --chain-id $CHAIN_ID --yes --home $HOME_DIR --keyring-backend test --broadcast-mode sync --node tcp://127.0.0.1:26657

echo ">>> Content Committed. Waiting for block..."
sleep 2

# 4. Sign Receipt (Triple Proof Generation)
echo ">>> Signing Retrieval Receipt (User)..."
# sign-retrieval-receipt [deal-id] [provider] [epoch] [mdu-file] [trusted-setup] [manifest-file] [mdu-index]
$BINARY tx nilchain sign-retrieval-receipt $DEAL_ID $PROVIDER1_ADDR 1 $MDU_FILE $TRUSTED_SETUP $MANIFEST_FILE 0 \
  --from user --keyring-backend test --home $HOME_DIR --offline > $RECEIPT_FILE

echo ">>> Receipt Content:"
cat $RECEIPT_FILE

echo ">>> Receipt generated."

# 5. Submit Proof
echo ">>> Submitting Retrieval Proof (Provider)..."
TX_RES=$(yes | $BINARY tx nilchain submit-retrieval-proof $RECEIPT_FILE --from provider1 --chain-id $CHAIN_ID --yes --home $HOME_DIR --keyring-backend test --broadcast-mode sync --node tcp://127.0.0.1:26657 --output json)
echo $TX_RES
TX_HASH=$(echo $TX_RES | jq -r '.txhash')

echo ">>> Waiting for verification (Tx: $TX_HASH)..."
sleep 6

echo ">>> Querying Tx Result..."
TX_RESULT=$($BINARY query tx $TX_HASH --home $HOME_DIR --node tcp://127.0.0.1:26657 --output json)
echo $TX_RESULT

# Check for success event in the transaction result
SUCCESS_STATUS=$(echo $TX_RESULT | jq -r '(.logs[0].events[]? // .events[]?) | select(.type=="prove_liveness") | .attributes[] | select(.key=="success") | .value' 2>/dev/null)

if [ "$SUCCESS_STATUS" == "true" ]; then
    echo "SUCCESS: Retrieval Proof Verified on-chain (Liveness Confirmed)!"
elif [ "$SUCCESS_STATUS" == "false" ]; then
    echo "FAILURE: Proof was rejected by the chain (success=false)."
    cat $HOME_DIR/chain.log
    exit 1
else
    echo "FAILURE: Could not parse proof result from transaction."
    echo "Last 50 lines of log:"
    tail -n 50 $HOME_DIR/chain.log
    exit 1
fi

# Cleanup
kill $PID
rm -rf $HOME_DIR
rm $MDU_FILE $RECEIPT_FILE $INPUT_FILE $SHARD_OUTPUT $MANIFEST_FILE
