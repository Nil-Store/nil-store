#!/bin/bash
set -e

# End-to-End Retrieval Receipt Test (Triple Proof)
# Usage: ./e2e_retrieval.sh

BINARY="./nilchaind"
NIL_CLI="./nil_cli/target/release/nil_cli"
CHAIN_ID="nilchain"
HOME_DIR="./.nilchain_retrieval"
MDU_FILE="./test_retrieval_mdu.dat" # Will be generated by sharding
INPUT_FILE="./test_input_1mb.bin"
SHARD_OUTPUT="./test_input_1mb.bin.json"
MANIFEST_FILE="./test_manifest.bin"
RECEIPT_FILE="./receipt.json"
TRUSTED_SETUP="$(pwd)/nilchain/trusted_setup.txt"

# Helper for hex decoding
python3 -c "import sys; print(bytes.fromhex(sys.argv[1][2:]).decode('latin1'))" 2>/dev/null || true

# Ensure binaries are built
echo ">>> Building binaries..."
touch nil_core/src/lib.rs
cd nil_core && cargo build --release && cd ..
cd nilchain && go build -o ../nilchaind ./cmd/nilchaind && cd ..
cd nil_cli && cargo build --release && cd ..

# Clean start
echo ">>> Resetting chain..."
pkill -f nilchaind || true
rm -rf $HOME_DIR
$BINARY init mynode --chain-id $CHAIN_ID --home $HOME_DIR > /dev/null 2>&1
$BINARY config set client chain-id $CHAIN_ID --home $HOME_DIR
$BINARY config set client keyring-backend test --home $HOME_DIR

# Create accounts
echo ">>> Creating accounts..."
yes | $BINARY keys add user --home $HOME_DIR --keyring-backend test > /dev/null 2>&1
for i in {1..12}
do
   yes | $BINARY keys add "provider$i" --home $HOME_DIR --keyring-backend test > /dev/null 2>&1
done

USER_ADDR=$($BINARY keys show user -a --home $HOME_DIR --keyring-backend test)
PROVIDER1_ADDR=$($BINARY keys show provider1 -a --home $HOME_DIR --keyring-backend test)

# Add genesis accounts
# We give accounts 'aatom' (for EVM) and 'stake' (for consensus).
$BINARY genesis add-genesis-account "$USER_ADDR" 100000000000token,100000000stake,100000000000000000000aatom --home $HOME_DIR
for i in {1..12}
do
   PROV_ADDR=$($BINARY keys show "provider$i" -a --home $HOME_DIR --keyring-backend test)
   $BINARY genesis add-genesis-account "$PROV_ADDR" 1000000000token,1000000stake,10000000000000000000aatom --home $HOME_DIR
done

$BINARY genesis gentx user 100000000stake --chain-id $CHAIN_ID --home $HOME_DIR --keyring-backend test > /dev/null 2>&1
$BINARY genesis collect-gentxs --home $HOME_DIR > /dev/null 2>&1

# Inject EVM Denom Metadata (required for Ethermint to start)
echo ">>> Injecting EVM denom metadata..."
jq '.app_state.bank.denom_metadata += [{
  "description": "The native EVM token",
  "denom_units": [
    {"denom": "aatom", "exponent": 0, "aliases": ["atto"]},
    {"denom": "atom", "exponent": 18, "aliases": []}
  ],
  "base": "aatom",
  "display": "atom",
  "name": "Atom",
  "symbol": "ATOM"
}]' $HOME_DIR/config/genesis.json > $HOME_DIR/config/genesis.json.tmp && mv $HOME_DIR/config/genesis.json.tmp $HOME_DIR/config/genesis.json

# Config: Fast blocks
sed -i.bak 's/timeout_commit = "5s"/timeout_commit = "1s"/' $HOME_DIR/config/config.toml
sed -i.bak 's/minimum-gas-prices = ""/minimum-gas-prices = "0token"/' $HOME_DIR/config/app.toml

# Start Chain
echo ">>> Starting chain..."
export KZG_TRUSTED_SETUP=$TRUSTED_SETUP
$BINARY start --home $HOME_DIR --log_level info > $HOME_DIR/chain.log 2>&1 &
PID=$!

# Wait for start
echo ">>> Waiting for chain start..."
STARTED=false
for i in {1..30}; do
    if ! kill -0 $PID 2>/dev/null; then
        echo "CRITICAL: Chain process died!"
        cat $HOME_DIR/chain.log
        exit 1
    fi

    STATUS=$(curl -s --max-time 2 http://127.0.0.1:26657/status || echo "")
    if [ -n "$STATUS" ]; then
        HEIGHT=$(echo "$STATUS" | jq -r '.result.sync_info.latest_block_height' 2>/dev/null)
        if [[ -n "$HEIGHT" && "$HEIGHT" != "null" && "$HEIGHT" != "0" ]]; then
            echo "Chain started at height $HEIGHT."
            STARTED=true
            break
        fi
    fi
    sleep 1
done

if [ "$STARTED" = false ]; then
    echo "TIMEOUT: Chain failed to start."
    cat $HOME_DIR/chain.log
    kill $PID
    exit 1
fi

# Register Providers
echo ">>> Registering Providers..."
for i in {1..12}
do
   yes | $BINARY tx nilchain register-provider General 1000000000 --from "provider$i" --chain-id $CHAIN_ID --yes --home $HOME_DIR --keyring-backend test --broadcast-mode sync --node tcp://127.0.0.1:26657 > /dev/null
done

# 1. Prepare Data
echo ">>> Generating Data..."
dd if=/dev/urandom of=$INPUT_FILE bs=1024 count=1024 2>/dev/null # 1MB

echo ">>> Sharding Data..."
# This generates ./test_input_1mb.bin.json AND ./test_input_1mb.bin.mdu.0.bin (the encoded MDU)
$NIL_CLI --trusted-setup $TRUSTED_SETUP shard $INPUT_FILE --out $SHARD_OUTPUT --save-mdu-prefix "$INPUT_FILE"

# Extract CID and Manifest Blob
MANIFEST_ROOT=$(jq -r '.manifest_root_hex' $SHARD_OUTPUT)
MANIFEST_BLOB_HEX=$(jq -r '.manifest_blob_hex' $SHARD_OUTPUT)
SIZE=$(jq -r '.file_size_bytes' $SHARD_OUTPUT)

echo "   CID: $MANIFEST_ROOT"
echo "   Size: $SIZE"

# Use the generated encoded MDU for the receipt
MDU_FILE="${INPUT_FILE}.mdu.0.bin"

# Save Manifest Blob to file (binary)
python3 -c "import sys; print(bytes.fromhex('$MANIFEST_BLOB_HEX'[2:]).decode('latin1'))" > $MANIFEST_FILE 2>/dev/null || \
python3 -c "import sys; sys.stdout.buffer.write(bytes.fromhex('$MANIFEST_BLOB_HEX'[2:]))" > $MANIFEST_FILE

# Ensure we have an MDU file (mocking the download). 
# For 1MB file, it fits in one MDU. nil-cli pads it?
# Actually, `sign-retrieval-receipt` expects an 8MB MDU file.
# nil-cli shard might output chunks?
# For this test, let's create a dummy 8MB MDU that matches the structural requirement if possible,
# OR just use the input file and pad it, assuming `nil-cli` logic matches.
# Wait, `sign-retrieval-receipt` calls `ComputeMduMerkleRoot`.
# The MDU used there MUST match the one committed in the manifest.
# Since we are using `nil-cli` to generate the manifest, we need the MDU data `nil-cli` used.
# `nil-cli` doesn't currently output the MDU binary chunks separately.
# Hack: Re-create the MDU by padding the input file to 8MB.
cp $INPUT_FILE $MDU_FILE
truncate -s 8M $MDU_FILE

# 2. Create Deal (Alloc)
echo ">>> Creating Deal (Alloc)..."
# DealSize 1 = 4GB. Duration 100. Escrow 1000. Spend 5000.
yes | $BINARY tx nilchain create-deal 1 100 1000 5000 --service-hint "General" --from user --chain-id $CHAIN_ID --yes --home $HOME_DIR --keyring-backend test --broadcast-mode sync --node tcp://127.0.0.1:26657

echo ">>> Waiting for block..."
sleep 2

# Get Deal ID
DEAL_ID=0 # First deal

# 3. Commit Content
echo ">>> Committing Content..."
yes | $BINARY tx nilchain update-deal-content --deal-id $DEAL_ID --cid $MANIFEST_ROOT --size $SIZE --from user --chain-id $CHAIN_ID --yes --home $HOME_DIR --keyring-backend test --broadcast-mode sync --node tcp://127.0.0.1:26657

echo ">>> Content Committed. Waiting for block..."
sleep 2

# 4. Sign Receipt (Triple Proof Generation)
echo ">>> Signing Retrieval Receipt (User)..."
# sign-retrieval-receipt [deal-id] [provider] [epoch] [mdu-file] [trusted-setup] [manifest-file] [mdu-index]
$BINARY tx nilchain sign-retrieval-receipt $DEAL_ID $PROVIDER1_ADDR 1 $MDU_FILE $TRUSTED_SETUP $MANIFEST_FILE 0 \
  --from user --keyring-backend test --home $HOME_DIR --offline > $RECEIPT_FILE

echo ">>> Receipt generated."

# 5. Submit Proof
echo ">>> Submitting Retrieval Proof (Provider)..."
yes | $BINARY tx nilchain submit-retrieval-proof $RECEIPT_FILE --from provider1 --chain-id $CHAIN_ID --yes --home $HOME_DIR --keyring-backend test --broadcast-mode sync --node tcp://127.0.0.1:26657

echo ">>> Waiting for verification..."
sleep 6

# Check logs
if grep -q "ProviderRewards" $HOME_DIR/chain.log || grep -q "ModuleToAccount" $HOME_DIR/chain.log; then
    echo "SUCCESS: Rewards distributed (Proof Verified)."
elif grep -q "KZG Proof INVALID" $HOME_DIR/chain.log; then
    echo "FAILURE: Proof INVALID."
    cat $HOME_DIR/chain.log | grep "KZG"
    exit 1
else
    # Check for success event in tx log (if we queried it) or just scan logs for msg processing
    if grep -q "MsgProveLiveness" $HOME_DIR/chain.log; then
         echo "SUCCESS: Proof processed."
    else
         echo "FAILURE: Proof not processed."
         tail -n 50 $HOME_DIR/chain.log
         exit 1
    fi
fi

# Cleanup
kill $PID
rm -rf $HOME_DIR
rm $MDU_FILE $RECEIPT_FILE $INPUT_FILE $SHARD_OUTPUT $MANIFEST_FILE
