# NilStore Network Development Roadmap

## Protocol for Agents
**CRITICAL:** When pushing changes to the repository, you **MUST** push to both remotes to ensure synchronization.
*   `git push origin main` (Primary)
*   `git push nil-store main` (Mirror)

### Git Best Practices for Agents
*   **Commit Regularly:** Always commit your work frequently, in small, logical chunks.
*   **Prohibited Commands:** Agents are strictly forbidden from running aggressive Git commands like `git clean` or `git reset --hard` as these can lead to irreversible data loss of uncommitted work. If such commands are necessary, confirm with the user first.
*   **Tests Before Push:** For every non-trivial change, run the most relevant unit/e2e tests before committing. Do not push code that you haven't at least smoke-tested locally.
*   **Commit & Push Cadence:** Treat this file as the canonical TODO list. As you complete tasks, update the checklist, commit your work with a descriptive message, and push to both remotes (`origin` and `nil-store`) in small, verified increments.

This document outlines a strategic "Go-to-Market" Engineering Roadmap for the NilStore Network, designed to iteratively validate, market, and refine the project from "Paperware" to "Software." It recognizes the need to align Technology, Community, and Economy.

## Phase 1: The "Localhost" Prototype (Months 1-3)
**Goal:** Prove the math works on a single machine. Don't worry about the network yet.

*   **Build (Tech):**
    *   **Core Crypto Library:** [x] A standalone Rust/Go library implementing the KZG commitments and Argon2id logic.
    *   **CLI Tool:** [x] A simple `nil-cli` that can take a file, shard it, generating the "Useful Data" proof, and verify it locally.
    *   **Mock L1:** [x] Use a local JSON file or SQLite DB to simulate the "Chain State."
*   **Validate:**
    *   **Benchmark:** Can a 2015 MacBook verify a proof generated by a 2024 Server in < 10ms?
        *   [x] **Result:** ~0.94ms per proof on current hardware. Well within < 10ms budget.
    *   **Argon2id Timing:** Does the Argon2id timing actually prevent on-demand generation?
        *   [x] **Result:** ~191ms per 1KB block (15MB/2 passes).
*   **Market (Narrative):**
    *   **"Building in Public":** Publish the `core-crypto` repo.
    *   **Content:** Write a blog post: *"Why we chose PoDE over Filecoin's Seal"* (Comparatives sell well).
    *   **Educational Website:** [x] Launch a landing page to demonstrate benchmarks and visually explain core algorithms (Sharding, KZG, Argon2id).

## Phase 2: The "Friendly" Devnet (Months 3-6)
**Goal:** Connect 10-50 nodes controlled by you and "friendly" early backers.

*   **Build (Tech):**
    *   **The "Thin" L1:** [x] Initialize the Cosmos-SDK chain. Minimal governance.
    *   **P2P Networking:** [x] Nodes can now gossip shards to each other.
    *   **Faucet:** [x] A simple way to get test tokens.
*   **Validate:**
    *   **Chaos Testing:** [x] Kill nodes randomly. Does the data survive?
    *   **Latency:** [x] How long does it take for a shard to propagate from London to Tokyo?
        *   **Result:** ~14.38ms (Localhost).
*   **Market (Community):**
    *   **The "Founding Node" Program:** Hand-pick 20 diverse engineers (universities, data centers, crypto-natives) to run nodes. Give them direct access to the dev team.
    *   **Discord:** Open a Discord, but keep it technical.
*   **Refine:**
    *   [x] The installation experience. If it takes a PhD to install `nild`, you will fail. It must be `curl | bash`.

## Phase 2.5: The Pivot (Performance Market & System Placement)
**Status:** Spec Updated, Implementation Pending.

We have moved away from "Physics-Policed" constraints (strict 1.1s deadlines) to a **Market-Incentivized** model.

*   **Architecture Change 1: System-Defined Placement.**
    *   *Old:* User selects SPs. (Vulnerable to Sybil).
    *   *New:* Chain selects SPs deterministically (`Hash(Deal + Block)`).
    *   *Goal:* Anti-Sybil. Forced Diversity.
*   **Architecture Change 2: Performance Market.**
    *   *Old:* 1.1s Deadline or Slash.
    *   *New:* Block-Tiered Rewards. H+1 (Platinum), H+5 (Gold), H+20 (Fail).
    *   *Goal:* Incentivize speed without punishing honest jitter. Implicitly filters S3 Glacier.
*   **Architecture Change 3: Explicit Deal State.**
    *   *Old:* Stateless proofs.
    *   *New:* `MsgCreateDeal` creates a `Deal` object. Proofs must match Deal ID.

**Immediate Tasks:**
1.  [x] Implement `MsgCreateDeal` in `nilchain`.
2.  [x] Implement `ActiveProviderList` Keeper.
3.  [x] Implement Deterministic Slotting Logic.

---

## Phase 3: "Store Wars" (Incentivized Testnet) (Months 6-12)
**Goal:** Stress test the system with adversarial behavior. This is your biggest marketing event before launch.

*   **Build (Tech):**
    *   **The L2 Bridge:** [x] Contract implemented & verified. Relayer pending.
    *   **Incentives:** [x] L1 Proof Verification (Rust FFI) & Rewards (Minting) active.
    *   **Block Explorer:** [x] "Lattice" Visualizer & Interactive Playground live.
    *   **System Upgrade:** [x] 8 MiB Mega-Data Units (Optimized for Throughput).
*   **Validate:**
    *   **Game Theory:** [x] Slashing implemented for invalid proofs (Anti-spam/Anti-fraud).
    *   **Economics:** [x] Token Minting (Rewards) and Burning (Slashing) active.
*   **Market (Hype):**
    *   **"Race to 1 Petabyte":** [x] Leaderboard UI implemented.
    *   **Design Partners:** Onboard *one* real data client.

## Phase 4: Mainnet Beta (Launch)
**Goal:** Real money, real data, "Training Wheels" on.

*   **Build:**
    *   **S3 Adapter:** [x] `nil_s3` Go service implemented (PUT/GET -> Shard -> Chain).
    *   **Governance:** [x] Emergency Council setup (`x/group`) & Mainnet Params configured.
    *   **Adversarial Simulation:** [x] End-to-End attack simulation & visualization.
    *   Production-grade Audits (Security).
*   **Validate:**
    *   Slow rollout of the "Lattice" (limit the number of nodes initially).
*   **Market:**
    *   **Re-branding:** [ ] Update copy to "Nilmanifold" & "Homogeneity".
    *   Announce the "Genesis Block."
    *   **Web2 Wrapper:** [ ] Documentation for S3 Adapter.
    *   **Governance:** [ ] Documentation for DAO & Council.
    *   Focus on the "Web2 Wrapper" (S3 compatibility) to attract actual users, not just crypto speculators.

---

## Phase 5: EVM Integration (Ethermint) - "The Bi-Lingual Chain"
**Goal:** Make `nilchain` compatible with MetaMask and Solidity to serve as a robust Testnet and simplify onboarding.

### Step 1: Dependencies & Configuration
*   [x] **Update `go.mod`:** Add `github.com/cosmos/evm` (v0.5.1) and `github.com/cosmos/go-ethereum`.
*   [x] **Configure App (`app.go`):**
    *   Register `EVMKeeper` and `FeeMarketKeeper`.
    *   Add EVM modules to `AppConfig` (using `depinject` overrides).
    *   *Note:* EVM Modules are temporarily disabled in `app.go` manual wiring for simulation tests due to a `MsgEthereumTx` signer panic in the Cosmos SDK runtime. They must be re-enabled for production binaries.
*   [x] **AnteHandler:** Implement a hybrid AnteHandler to support both Cosmos (Keplr) and Ethereum (MetaMask) signatures.
*   [x] **Genesis:** Update `genesis.json` generation to include EVM parameters (ChainID, Gas Limits). (Auto-generated usually).

### Step 2: Smart Contract Deployment
*   [ ] **Deploy `NilBridge.sol`:** Deploy the bridge contract directly to the internal EVM.
*   [ ] **Test Interaction:** Verify that calling the contract from MetaMask works.

### Step 3: Frontend Integration
*   [ ] **Wallet Connection:** Add `wagmi` / `viem` to `nil-website`.
*   [ ] **"Connect MetaMask" Button:** Allow users to see their balance and interact with the bridge contract.

---

### Recommended Work Stream Categories (Organizational)

To manage this, it is recommended to organize development efforts into these three ongoing streams:

**1. The "Engine Room" (Core Protocol)**
*   *Focus:* Rust/Go code, Cryptography, Consensus.
*   *Metric:* Block time, Verification speed (ms).
*   *Output:* `nil-core` repo.

**2. The "Experience" (Product & Tooling)**
*   *Focus:* CLI, JS SDK, Explorer, Documentation.
*   *Metric:* "Time to First File" (How fast can a new user store "hello.txt"?).
*   *Output:* NPM packages, Docs site.

**3. The "Lab" (Research & Simulation)**

*   *Focus:* Python/Jupyter Notebooks. Validating the economics and lattice distribution.

*   *Metric:* "Nakamoto Coefficient" (How decentralized is the lattice?).

*   *Output:* Research papers, Simulation reports.



## Change Log (Session 1)

**Architectural Pivot: The Performance Market**

We have executed a major refactor of the protocol specification to replace "Physics-Policed" with "Economic Incentives."

1.  **PoDE Deprecation:** Removed `Argon2id` and strict 1.1s timing checks. The mechanism was deemed brittle and unverifiable on-chain.
2.  **Tiered Rewards:** Introduced **Block-Height Latency** tiers (Platinum/Gold/Silver). Speed is now priced by the market.
3.  **Unified Liveness:** Merged "Storage" and "Retrieval." User `RetrievalReceipts` now count as valid storage proofs.
4.  **System-Defined Placement:** Implemented deterministic slotting (`Hash(Deal+Block)`) to prevent Sybil attacks.
5.  **Elasticity:** Added "Saturation Signals" and "User-Funded Scaling" to handle viral content dynamically.
6.  **Risk Analysis:** Documented meta-risks including Cold Start fragility and Data Gravity in `metaspec.md`.

## Change Log (Session 2: Testnet Polish & EVM Integration)

**Codebase Stabilization**
1.  **Test Fixes:** Resolved `TestProveLiveness_Invalid` failure by correcting environment variable setup for trusted setup path.
2.  **CI/CD Hygiene:** Updated `Makefile` to strictly fail on "ERROR" logs, ensuring test failures aren't masked.
3.  **Rust Core:** Implemented `debug-print` feature flag in `nil_core` to silence verbose error logging during standard tests.
4.  **EVM Workaround:** Temporarily disabled EVM module wiring in `app.go` and `app_config.go` to bypass a `depinject` panic (`no cosmos.msg.v1.signer option`) affecting simulation tests (`TestFullAppSimulation`). This allows verifying the core storage logic via simulation while the upstream EVM signer issue is addressed.

## Change Log (Session 3: EVM Integration & Chain Configuration)

**EVM & Chain Stabilization**
1.  **Module Wiring:** Successfully manually wired `evm` and `feemarket` modules in `app.go`, resolving `depinject` conflicts and initialization ordering issues.
2.  **Runtime Panic Fix:** Implemented a custom `ProvideCustomGetSigner` injection in `root.go` to bypass a critical runtime panic (`MsgEthereumTx` signer option missing) caused by `depinject` strict validation.
3.  **Initialization Order:** Fixed `SetOrderBeginBlockers` and `SetOrderInitGenesis` panics by manually enforcing module load order after `app.Load()` to handle manually registered modules (IBC, EVM).
4.  **Blocker Identified:** The `collect-gentxs` CLI command crashes with a segmentation fault, preventing automatic genesis validator creation.
5.  **Manual Wiring Issues:** Attempted manual wiring for EVM/IBC modules led to complex store key and keeper initialization issues (`kv store with key <nil> has not been registered`). This approach was abandoned in favor of a full `depinject` strategy for these modules.

**Change Log (Session 4: Genesis Rebuild & EVM Bring-up)**

1.  **Gentx Decoder Hardening:** Patched the genesis pipeline to guard against nil decoders/typed-nil txs, decode gentxs directly, and validate messages without panicking.
2.  **Validator Gentx Fix:** `MsgCreateValidator` now sets the delegator (account prefix) alongside the validator address so gentx files are well-formed.
3.  **EVM Metadata Auto-Injection:** `collect-gentxs` auto-adds `aatom/atom` denom metadata (with `uatom` alias), unblocking EVM init.
4.  **Clean Genesis Flow:** `nilchaind genesis` now runs end-to-end again (init -> add-genesis-account -> gentx -> collect-gentxs). Start nodes with `--minimum-gas-prices=0.001aatom` to match the EVM/feemarket defaults.
5.  **Frontend & Faucet:** Added MetaMask-compatible chain config (chain-id 262144), wired faucet + deal submission endpoints, and shipped a browser form to request funds and create storage deals via the faucet service.
6.  **Local Stack Runner:** Added `scripts/run_local_stack.sh` to spin up nilchaind (EVM/REST/JSON-RPC), the faucet, and the web UI with one command; supports `start|stop`.

**Change Log (Session 5: Fresh Genesis + Stack Stability)**

1.  **Always-Fresh Genesis:** `run_local_stack.sh start` now wipes the chain home and rebuilds genesis every run (new deterministic faucet mnemonic: `course what neglect valley visual ride common cricket bachelor rigid vessel mask actor pumpkin edit follow sorry used divorce odor ask exclude crew hole`).
2.  **EVM Denom Safety:** Injects `aatom` denom metadata and matching supply into genesis before start, eliminating the `evm coin info: denom metadata aatom could not be found` panic.
3.  **Start/Stop Hardening:** Removed data directory nuking (keeps `priv_validator_state.json`), added liveness checks for nilchaind/faucet, and added port-based cleanup in `stop` to avoid stale faucet/web processes.
4.  **Faucet Defaults:** Faucet now dispenses both `aatom` (1e18) and `stake` (1e6) per request with gas priced in `aatom`, so MetaMask accounts get usable EVM gas immediately.

**Change Log (Session 6: EVM JSON-RPC Bridge & Tooling)**

1.  **Go Tooling:** Default local builds use `GO_BIN=/Users/michaelseiler/.gvm/gos/go1.25.5/bin/go` (falls back to system `go`), aligning with the requested gvm toolchain.
2.  **EVM JSON-RPC Bridge:** Added `tools/evm_jsonrpc_bridge` (read-only) exposing `eth_chainId`, `eth_blockNumber`, `eth_getBalance`, and `eth_gasPrice` by proxying LCD. CORS is wide open for the web UI.
3.  **Stack Runner:** `scripts/run_local_stack.sh` now boots the bridge with liveness checks so port 8545 is up immediately after `start`.

**Change Log (Session 7: Native EVM JSON-RPC)**

1.  **Cosmos EVM Server Integration:** Switched `nilchaind` to use the Cosmos EVM server stack (`github.com/cosmos/evm/server`), so the node now exposes a native Ethereum JSON-RPC endpoint directly from the binary.
2.  **EVM Mempool Wiring:** Implemented an `ExperimentalEVMMempool` configuration in `nilchain/app`, wired into the ante handler’s pending-tx listener and BaseApp proposal pipeline to support full EVM transaction flow.
3.  **Bridge Decommissioned:** `scripts/run_local_stack.sh` no longer starts the read-only `tools/evm_jsonrpc_bridge`; local EVM clients should connect directly to `nilchaind` on port `8545`.

## Phase 3: Implementation Plan (To-Do List)

### 1. Spec Alignment: Protobuf Definitions (Go)
*   [x] **`nilchain/proto/nilchain/nilchain/v1/types.proto`**: Create this file.
    *   Define `message Deal`: `{id, cid, size, owner, escrow, start_block, end_block, providers, redundancy_mode, service_hint}`.
    *   Define `message Provider`: `{address, total_storage, used_storage, capabilities (archive/general/edge), status}`.
    *   Define `message VirtualStripe`: `{deal_id, stripe_index, overlay_providers[]}` (For Elasticity tracking).
*   [x] **`nilchain/proto/nilchain/nilchain/v1/tx.proto`**: Update Service definitions.
    *   Add `MsgRegisterProvider`: `(creator, capabilities)`.
    *   Add `MsgCreateDeal`: `(creator, cid, size, duration, hint, max_monthly_spend)`.
    *   Rename `MsgSubmitProof` to `MsgProveLiveness`: `(creator, deal_id, epoch_id, proof_type {RetrievalReceipt | KzgProof})`.
    *   Add `MsgSignalSaturation`: `(creator, deal_id)`.

### 2. Spec Alignment: Keeper Logic (Go)
*   [x] **Provider Registry**: Implement `Keepers` to store/retrieve Providers. Support filtering by `Capabilities` (Hot/Cold).
*   [x] **Placement Engine**: Implement `AssignProviders(deal_id, block_hash, hint)` using the deterministic hashing algorithm.
    *   *Constraint:* Enforce distinct IP/ASN diversity (mocked for now).
*   [x] **Deal Lifecycle**: Implement `MsgCreateDeal` handler.
    *   Deduct escrow.
    *   Run placement.
    *   Save Deal state.
    *   Emit `DealCreated` event.
*   [x] **Unified Verification**: Implement `MsgProveLiveness` handler.
    *   Verify KZG (via FFI).
    *   Verify Signature (if RetrievalReceipt).
    *   Calculate **Tier** based on `ctx.BlockHeight() - challenge_block`.
    *   Distribute Rewards (Storage vs Bandwidth split).

### 3. Spec Alignment: Core Cryptography (Rust)
*   [x] **Audit nil_core: Remove Argon2id (PoDE) logic as it is now deprecated.**
*   [x] **Audit nil_core: Verify KZG Blob size constants and ensure support for 8 MiB MDUs.**
*   [x] **Batch Verification**: Expose a `verify_batch` FFI function to allow verifying an entire 8 MiB MDU proof efficiently.

### 4. Simulation & Testing
*   [x] **Unit Test**: `Placement_test.go`: Verify determinism and distribution of `AssignProviders`.
*   [x] **Integration Test**: `e2e_flow.sh`: Register -> Create Deal -> Submit Proof -> Check Balance.
*   [x] **Performance Test**: `load_gen.sh`: Baseline Small Scale simulation passing (12 blocks, 15 txs).

## Phase 3.1: Web E2E Storage Deals (TODO List)

**Goal:** Make the storage deal flow fully usable from the web UI, including file ingest → sharding/MDUs → CID derivation → deal creation on `nilchain`, while keeping supply (providers) and demand (users) clearly modeled.

### A. Backend Gateway & Sharding
*   [x] **Gateway Service:** Extend a small Go HTTP service ("gateway") in `nil_s3/main.go` that:
    *   Accepts file uploads from the web UI at `/gateway/upload`.
    *   Invokes `nil_cli shard` with the trusted setup to compute MDUs and a Root CID compatible with the spec.
    *   Returns `{cid, size_bytes, filename}` (Root CID + size) to the client.
*   [x] **Configurable Paths:** Make the gateway configurable via env (paths to `nil_cli`, trusted setup, upload directory, nilchaind home/chain-id/gas prices) to keep it portable.
*   [x] **Chain Deal Creation:** Add an HTTP endpoint (`/gateway/create-deal`) that accepts `{creator, cid, size_bytes, duration_blocks, service_hint, initial_escrow, max_monthly_spend}` and creates a `MsgCreateDeal` on-chain (currently signed by the `faucet` key for simplicity).
*   [x] **Gateway Tests:** Exercise the gateway via `scripts/run_local_stack.sh start` plus manual `curl`:
    *   Happy-path upload → shard → CID extraction (verified CID + size from `nil_cli shard`).
    *   Deal creation endpoint returning a valid `tx_hash` and a persisted deal visible via `nilchaind query nilchain list-deals` and `GET /nilchain/nilchain/v1/deals`.

### B. Website Integration (Demand Side)
*   [x] **Config Wiring:** Extend `nil-website/src/config.ts` with a dedicated `gatewayBase` (e.g. `VITE_GATEWAY_BASE`, defaulting to `http://localhost:8080`).
*   [x] **Upload Hook:** Implement a `useUpload` hook that:
    *   Accepts a `File` and the connected wallet address.
    *   Converts `0x` → `nil...` via `ethToNil`.
    *   Calls the gateway upload endpoint and returns `{cid, size_bytes}`.
*   [x] **Dashboard UX:** Update the Dashboard to:
    *   Let users select a file, call `useUpload`, and pre-fill the "Create Storage Deal" form with CID + size.
    *   Keep the existing tuning knobs for `duration`, `service_hint`, `initialEscrow`, `maxMonthlySpend`.
*   [x] **Deal Submission Path:** Point the "Create Storage Deal" button at the new gateway deal-creation endpoint so that the UI always uses spec-derived CIDs/sizes (faucet signs the Cosmos tx).
*   [x] **UI Tests / Smoke:** At minimum, verify via `run_local_stack.sh start` that:
    *   Upload → CID derivation works from the browser.
    *   "Create Storage Deal" completes and a new deal appears in the `GET /nilchain/nilchain/v1/deals` response.

### C. Supply Side & Visibility
*   [x] **Provider Surfacing:** Add a simple read-only view in the web Dashboard that lists registered providers and their capabilities (`Archive/General/Edge`) from the provider registry (LCD `/nilchain/nilchain/v1/providers`), surfaced as an **Active Providers** table.
*   [x] **Deal Detail View:** Extend the "My Storage Deals" table to show:
    *   `service_hint`, `current_replication` (or number of `providers[]`), `escrow_balance`, and assigned `providers[]` (first address + count) for each deal.
    *   Note: `max_monthly_spend` is currently visible via the LCD/CLI JSON payload, and can be wired into the UI later if product requirements call for it.
*   [x] **Spec Notes:** The current web flow now satisfies:
    *   **File ingest → MDUs → Root CID:** Implemented via `nil_s3` gateway calling `nil_cli shard` with the trusted setup and returning the DU root (`du_c_root_hex`) and `file_size_bytes`.
    *   **Deal creation on-chain:** Implemented via gateway → `MsgCreateDeal` using the Cosmos nilchain module; deals persist in `k.Deals` and are queryable via LCD and CLI.
    *   **Supply visibility:** Provider registry is live; providers can be registered (demo uses the `faucet` key) and are listed in the Dashboard.
    *   **Bootstrap placement:** On small devnets, `AssignProviders` now caps replication at the number of available providers instead of failing, enabling single-provider testnets while keeping the spec’s `DealBaseReplication` for larger networks.
    *   **Remaining TODOs:** Client-side encryption and manifest creation in the browser, WASM-compiled `nil_core` for in-browser verification/sharding, user-signed `MsgCreateDeal` via an EVM→Cosmos bridge (so deals are owned by the MetaMask account instead of the faucet), full liveness/saturation UI (visualising `MsgProveLiveness` tiers and `MsgSignalSaturation`), and richer deal history/escrow charts.

### D. Process Requirements for Agents (for this phase)
*   [ ] For each of the A/B/C tasks above:
    *   Implement the smallest coherent slice.
    *   Run the most relevant tests (`go test ./...`, targeted e2e shell scripts, or UI smoke checks via `run_local_stack.sh`) before committing.
    *   Commit with a descriptive message (e.g. `feat(gateway): add upload->CID endpoint`).
    *   Push to **both** remotes after green tests: `git push origin main` and `git push nil-store main`.
