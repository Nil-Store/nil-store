# NilStore Network Development Roadmap

## Protocol for Agents
**CRITICAL:** When pushing changes to the repository, you **MUST** push to both remotes to ensure synchronization.
*   `git push origin main` (Primary)
*   `git push nil-store main` (Mirror)

### Git Best Practices for Agents
*   **Commit Regularly:** Always commit your work frequently, in small, logical chunks.
*   **Prohibited Commands:** Agents are strictly forbidden from running aggressive Git commands like `git clean` or `git reset --hard` as these can lead to irreversible data loss of uncommitted work. If such commands are necessary, confirm with the user first.
*   **Tests Before Push:** For every non-trivial change, run the most relevant unit/e2e tests before committing. Do not push code that you haven't at least smoke-tested locally.
*   **Commit & Push Cadence:** Treat this file as the canonical TODO list. As you complete tasks, update the checklist, commit your work with a descriptive message, and push to both remotes (`origin` and `nil-store`) in small, verified increments.

This document outlines a strategic "Go-to-Market" Engineering Roadmap for the NilStore Network, designed to iteratively validate, market, and refine the project from "Paperware" to "Software." It recognizes the need to align Technology, Community, and Economy.

## Phase 1: The "Localhost" Prototype (Months 1-3)
**Goal:** Prove the math works on a single machine. Don't worry about the network yet.

*   **Build (Tech):**
    *   **Core Crypto Library:** [x] A standalone Rust/Go library implementing the KZG commitments and Argon2id logic.
    *   **CLI Tool:** [x] A simple `nil-cli` that can take a file, shard it, generating the "Useful Data" proof, and verify it locally.
    *   **Mock L1:** [x] Use a local JSON file or SQLite DB to simulate the "Chain State."
*   **Validate:**
    *   **Benchmark:** Can a 2015 MacBook verify a proof generated by a 2024 Server in < 10ms?
        *   [x] **Result:** ~0.94ms per proof on current hardware. Well within < 10ms budget.
    *   **Argon2id Timing:** Does the Argon2id timing actually prevent on-demand generation?
        *   [x] **Result:** ~191ms per 1KB block (15MB/2 passes).
*   **Market (Narrative):**
    *   **"Building in Public":** Publish the `core-crypto` repo.
    *   **Content:** Write a blog post: *"Why we chose PoDE over Filecoin's Seal"* (Comparatives sell well).
    *   **Educational Website:** [x] Launch a landing page to demonstrate benchmarks and visually explain core algorithms (Sharding, KZG, Argon2id).

## Phase 2: The "Friendly" Devnet (Months 3-6)
**Goal:** Connect 10-50 nodes controlled by you and "friendly" early backers.

*   **Build (Tech):**
    *   **The "Thin" L1:** [x] Initialize the Cosmos-SDK chain. Minimal governance.
    *   **P2P Networking:** [x] Nodes can now gossip shards to each other.
    *   **Faucet:** [x] A simple way to get test tokens.
*   **Validate:**
    *   **Chaos Testing:** [x] Kill nodes randomly. Does the data survive?
    *   **Latency:** [x] How long does it take for a shard to propagate from London to Tokyo?
        *   **Result:** ~14.38ms (Localhost).
*   **Market (Community):**
    *   **The "Founding Node" Program:** Hand-pick 20 diverse engineers (universities, data centers, crypto-natives) to run nodes. Give them direct access to the dev team.
    *   **Discord:** Open a Discord, but keep it technical.
*   **Refine:**
    *   [x] The installation experience. If it takes a PhD to install `nild`, you will fail. It must be `curl | bash`.

## Phase 2.5: The Pivot (Performance Market & System Placement)
**Status:** Spec Updated, Implementation Pending.

We have moved away from "Physics-Policed" constraints (strict 1.1s deadlines) to a **Market-Incentivized** model.

*   **Architecture Change 1: System-Defined Placement.**
    *   *Old:* User selects SPs. (Vulnerable to Sybil).
    *   *New:* Chain selects SPs deterministically (`Hash(Deal + Block)`).
    *   *Goal:* Anti-Sybil. Forced Diversity.
*   **Architecture Change 2: Performance Market.**
    *   *Old:* 1.1s Deadline or Slash.
    *   *New:* Block-Tiered Rewards. H+1 (Platinum), H+5 (Gold), H+20 (Fail).
    *   *Goal:* Incentivize speed without punishing honest jitter. Implicitly filters S3 Glacier.
*   **Architecture Change 3: Explicit Deal State.**
    *   *Old:* Stateless proofs.
    *   *New:* `MsgCreateDeal` creates a `Deal` object. Proofs must match Deal ID.

**Immediate Tasks:**
1.  [x] Implement `MsgCreateDeal` in `nilchain`.
2.  [x] Implement `ActiveProviderList` Keeper.
3.  [x] Implement Deterministic Slotting Logic.

---

## Phase 3: "Store Wars" (Incentivized Testnet) (Months 6-12)
**Goal:** Stress test the system with adversarial behavior. This is your biggest marketing event before launch.

*   **Build (Tech):**
    *   **The L2 Bridge:** [x] Contract implemented & verified. Relayer pending.
    *   **Incentives:** [x] L1 Proof Verification (Rust FFI) & Rewards (Minting) active.
    *   **Block Explorer:** [x] "Lattice" Visualizer & Interactive Playground live.
    *   **System Upgrade:** [x] 8 MiB Mega-Data Units (Optimized for Throughput).
*   **Validate:**
    *   **Game Theory:** [x] Slashing implemented for invalid proofs (Anti-spam/Anti-fraud).
    *   **Economics:** [x] Token Minting (Rewards) and Burning (Slashing) active.
*   **Market (Hype):**
    *   **"Race to 1 Petabyte":** [x] Leaderboard UI implemented.
    *   **Design Partners:** Onboard *one* real data client.

## Phase 4: Mainnet Beta (Launch)
**Goal:** Real money, real data, "Training Wheels" on.

*   **Build:**
    *   **S3 Adapter:** [x] `nil_s3` Go service implemented (PUT/GET -> Shard -> Chain).
    *   **Governance:** [x] Emergency Council setup (`x/group`) & Mainnet Params configured.
    *   **Adversarial Simulation:** [x] End-to-End attack simulation & visualization.
    *   Production-grade Audits (Security).
*   **Validate:**
    *   Slow rollout of the "Lattice" (limit the number of nodes initially).
*   **Market:**
    *   **Re-branding:** [ ] Update copy to "Nilmanifold" & "Homogeneity".
    *   Announce the "Genesis Block."
    *   **Web2 Wrapper:** [ ] Documentation for S3 Adapter.
    *   **Governance:** [ ] Documentation for DAO & Council.
    *   Focus on the "Web2 Wrapper" (S3 compatibility) to attract actual users, not just crypto speculators.

---

## Phase 5: EVM Integration (Ethermint) - "The Bi-Lingual Chain"
**Goal:** Make `nilchain` compatible with MetaMask and Solidity to serve as a robust Testnet and simplify onboarding.

### Step 1: Dependencies & Configuration
*   [x] **Update `go.mod`:** Add `github.com/cosmos/evm` (v0.5.1) and `github.com/cosmos/go-ethereum`.
*   [x] **Configure App (`app.go`):**
    *   Register `EVMKeeper` and `FeeMarketKeeper`.
    *   Add EVM modules to `AppConfig` (using `depinject` overrides).
    *   *Note:* EVM Modules are temporarily disabled in `app.go` manual wiring for simulation tests due to a `MsgEthereumTx` signer panic in the Cosmos SDK runtime. They must be re-enabled for production binaries.
*   [x] **AnteHandler:** Implement a hybrid AnteHandler to support both Cosmos (Keplr) and Ethereum (MetaMask) signatures.
*   [x] **Genesis:** Update `genesis.json` generation to include EVM parameters (ChainID, Gas Limits). (Auto-generated usually).

### Step 2: Smart Contract Deployment
*   [ ] **Deploy `NilBridge.sol`:** Deploy the bridge contract directly to the internal EVM.
*   [ ] **Test Interaction:** Verify that calling the contract from MetaMask works.

### Step 3: Frontend Integration
*   [ ] **Wallet Connection:** Add `wagmi` / `viem` to `nil-website`.
*   [ ] **"Connect MetaMask" Button:** Allow users to see their balance and interact with the bridge contract.

---

### Recommended Work Stream Categories (Organizational)

To manage this, it is recommended to organize development efforts into these three ongoing streams:

**1. The "Engine Room" (Core Protocol)**
*   *Focus:* Rust/Go code, Cryptography, Consensus.
*   *Metric:* Block time, Verification speed (ms).
*   *Output:* `nil-core` repo.

**2. The "Experience" (Product & Tooling)**
*   *Focus:* CLI, JS SDK, Explorer, Documentation.
*   *Metric:* "Time to First File" (How fast can a new user store "hello.txt"?).
*   *Output:* NPM packages, Docs site.

**3. The "Lab" (Research & Simulation)**

*   *Focus:* Python/Jupyter Notebooks. Validating the economics and lattice distribution.

*   *Metric:* "Nakamoto Coefficient" (How decentralized is the lattice?).

*   *Output:* Research papers, Simulation reports.

## Spring Roadmap (Executed)

### 1. Work Stream: Strict Data Granularity & Deal Decoupling
*   [x] **Specs:** Adopted `rfc-data-granularity` (DealSize Tiers).
*   [x] **Types:** Added `DealSize` enum and updated `Deal` struct (Container).
*   [x] **Chain:** Refactored `MsgCreateDeal` (Capacity) and `MsgUpdateDealContent` (Commitment).
*   [x] **CLI/Gateway:** Updated tools to support the 2-step flow.
*   [x] **Verification:** Added Unit Tests and E2E Gateway Test (`e2e_gateway_spring.sh`).

### 2. Work Stream: Heat & Traffic Observability (Phase A)
*   [x] **State:** Added `DealHeatState` to types.
*   [x] **Keeper:** Added `DealHeatStates` collection and `IncrementHeat` logic.
*   [x] **Hook:** Instrumented `ProveLiveness` to track bytes served.

### 3. Work Stream: The Deputy System (Phase 1)
*   [x] **P2P:** Added `AskForProxy` message structure and handler stub in `nil_p2p`.
*   [x] **CLI:** Added `proxy` command to `nil-p2p` REPL.

---

## Spring Roadmap - Phase 2: The Triple Proof & Web Modernization

This phase focuses on implementing the scalable "Triple Proof" architecture and exposing the new features in the Web UI.

### 1. Work Stream: Triple Proof Architecture (Core & Chain)
**Goal:** Implement the 3-Hop Verification to allow dealing with large datasets using a single 48-byte Manifest Root.

*   **Step A: Protobuf Definitions (Executed)**
    *   [x] **File:** `nilchain/proto/nilchain/nilchain/v1/types.proto`
    *   [x] **Task:** Update `Deal` struct: replace `string cid` with `bytes manifest_root` (48-byte) and add `uint64 total_mdus`.
    *   [x] **Task:** Define `message ChainedProof`: `mdu_index`, `mdu_root_fr`, `manifest_opening` (Hop 1), `blob_commitment`, `merkle_path` (Hop 2), `z`, `y`, `kzg_opening` (Hop 3).
*   **Step B: Core Cryptography (`nil_core`) (Executed)**
    *   [x] **Task:** Implement `ManifestMDU` generation:
        *   Input: List of MDU Roots (hashes).
        *   Process: Map hashes to Scalars -> Blob -> KZG Commitment.
        *   Output: `ManifestRoot` (G1) and `ManifestBlob` data.
*   **Step C: Chain Verification Logic**
    *   [x] **Task (Core):** Implement `verify_manifest_inclusion` in `nil_core` (Need to handle Roots of Unity coordinate mapping).
    *   [x] **Task (FFI):** Expose `nil_verify_chained_proof` (Hop 1 + 3) and `nil_compute_manifest_commitment`.
    *   [x] **File:** `nilchain/x/nilchain/keeper/msg_server.go` (or dedicated verifier).
    *   [x] **Task:** Implement `VerifyChainedProof` algorithm using FFI:
        *   Hop 1 (KZG): Verify MDU Root is in Manifest.
        *   Hop 2 (Merkle): Verify Blob is in MDU.
        *   Hop 3 (KZG): Verify Data is in Blob.
*   **Step D: CLI Tooling**
    *   [x] **Task:** Update `nil-cli shard` to produce `ManifestMDU` and the final `ManifestRoot` for the Deal.

### 2. Work Stream: Web UI Modernization
**Goal:** Update the frontend to reflect the "Container vs Content" model and visualize the new architecture.

*   **Step A: Dashboard Updates (`src/components/Dashboard.tsx`)**
    *   [x] **Task:** Refactor "Create Storage Deal" into a multi-step component:
        *   **Tab 1 (Alloc):** "Allocate Capacity". Inputs: Size Tier, Duration, Escrow. Calls `create-deal`.
        *   **Tab 2 (Content):** "Commit Content". Inputs: Deal ID (Select), File (Upload). Calls `update-deal-content`.
    *   [x] **Task:** Update Deal List to distinguish between "Empty" (Capacity only) and "Active" (Content Committed) deals.
    *   [x] **Task:** Add "Bytes Served" column (Heat) to the Deal List using `DealHeatState` (via `proofs` aggregation for now, pending full HeatState exposure).
*   **Step B: Deal Explorer (New Component/Page)**
    *   [x] **Task:** Create `src/components/DealDetail.tsx`.
    *   [x] **Task:** Visualize the "Manifest" (List of MDUs) if available (fetched from gateway).
    *   [x] **Task:** Show "Liveness History" (Heatmap of proofs) and "Heat" stats.
*   **Step C: Integration Hooks (`src/hooks/`)**
    *   [x] **Task:** Update `useCreateDeal.ts` to call the new `GatewayCreateDeal` (with tiers).
    *   [x] **Task:** Create `useUpdateDealContent.ts` to call `GatewayUpdateDealContentFromEvm`.

### 4. Work Stream: Visualizations & Marketing
*   [x] **Task:** Implement interactive Performance Market visualization in `nil-website` (The Latency Racer).
*   [x] **Task:** Visualize `DealHeatState` in Deal Explorer (Added `GetDealHeat` query and UI integration).

## Future Phases
*   **Web2 Wrapper:** S3 Adapter documentation and further integration (Updated S3AdapterDocs page).
*   **Governance:** DAO & Council setup visualization.
*   **Adversarial Simulation:** End-to-End attack simulation & visualization (P&L model - *Completed*).
*   **Unified Liveness:** Integrate user traffic directly into consensus via `RetrievalReceipt` aggregation (partially implemented in Phase 2).