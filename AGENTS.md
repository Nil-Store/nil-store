# NilStore Network Development Roadmap

## Protocol for Agents
**CRITICAL:** When pushing changes to the repository, you **MUST** push to both remotes to ensure synchronization.
*   `git push origin main` (Primary)
*   `git push nil-store main` (Mirror)

### Git Best Practices for Agents
*   **Commit Regularly:** Always commit your work frequently, in small, logical chunks.
*   **Prohibited Commands:** Agents are strictly forbidden from running aggressive Git commands like `git clean` or `git reset --hard` as these can lead to irreversible data loss of uncommitted work. If such commands are necessary, confirm with the user first.
*   **Tests Before Push:** For every non-trivial change, run the most relevant unit/e2e tests before committing. Do not push code that you haven't at least smoke-tested locally.
*   **Commit & Push Cadence:** Treat this file as the canonical TODO list. As you complete tasks, update the checklist, commit your work with a descriptive message, and push to both remotes (`origin` and `nil-store`) in small, verified increments.

This document outlines a strategic "Go-to-Market" Engineering Roadmap for the NilStore Network, designed to iteratively validate, market, and refine the project from "Paperware" to "Software." It recognizes the need to align Technology, Community, and Economy.

## Phase 1: The "Localhost" Prototype (Months 1-3)
**Goal:** Prove the math works on a single machine. Don't worry about the network yet.

*   **Build (Tech):**
    *   **Core Crypto Library:** [x] A standalone Rust/Go library implementing the KZG commitments and Argon2id logic.
    *   **CLI Tool:** [x] A simple `nil-cli` that can take a file, shard it, generating the "Useful Data" proof, and verify it locally.
    *   **Mock L1:** [x] Use a local JSON file or SQLite DB to simulate the "Chain State."
*   **Validate:**
    *   **Benchmark:** Can a 2015 MacBook verify a proof generated by a 2024 Server in < 10ms?
        *   [x] **Result:** ~0.94ms per proof on current hardware. Well within < 10ms budget.
    *   **Argon2id Timing:** Does the Argon2id timing actually prevent on-demand generation?
        *   [x] **Result:** ~191ms per 1KB block (15MB/2 passes).
*   **Market (Narrative):**
    *   **"Building in Public":** Publish the `core-crypto` repo.
    *   **Content:** Write a blog post: *"Why we chose PoDE over Filecoin's Seal"* (Comparatives sell well).
    *   **Educational Website:** [x] Launch a landing page to demonstrate benchmarks and visually explain core algorithms (Sharding, KZG, Argon2id).

## Phase 2: The "Friendly" Devnet (Months 3-6)
**Goal:** Connect 10-50 nodes controlled by you and "friendly" early backers.

*   **Build (Tech):**
    *   **The "Thin" L1:** [x] Initialize the Cosmos-SDK chain. Minimal governance.
    *   **P2P Networking:** [x] Nodes can now gossip shards to each other.
    *   **Faucet:** [x] A simple way to get test tokens.
*   **Validate:**
    *   **Chaos Testing:** [x] Kill nodes randomly. Does the data survive?
    *   **Latency:** [x] How long does it take for a shard to propagate from London to Tokyo?
        *   **Result:** ~14.38ms (Localhost).
*   **Market (Community):**
    *   **The "Founding Node" Program:** Hand-pick 20 diverse engineers (universities, data centers, crypto-natives) to run nodes. Give them direct access to the dev team.
    *   **Discord:** Open a Discord, but keep it technical.
*   **Refine:**
    *   [x] The installation experience. If it takes a PhD to install `nild`, you will fail. It must be `curl | bash`.

## Phase 2.5: The Pivot (Performance Market & System Placement)
**Status:** Spec Updated, Implementation Pending.

We have moved away from "Physics-Policed" constraints (strict 1.1s deadlines) to a **Market-Incentivized** model.

*   **Architecture Change 1: System-Defined Placement.**
    *   *Old:* User selects SPs. (Vulnerable to Sybil).
    *   *New:* Chain selects SPs deterministically (`Hash(Deal + Block)`).
    *   *Goal:* Anti-Sybil. Forced Diversity.
*   **Architecture Change 2: Performance Market.**
    *   *Old:* 1.1s Deadline or Slash.
    *   *New:* Block-Tiered Rewards. H+1 (Platinum), H+5 (Gold), H+20 (Fail).
    *   *Goal:* Incentivize speed without punishing honest jitter. Implicitly filters S3 Glacier.
*   **Architecture Change 3: Explicit Deal State.**
    *   *Old:* Stateless proofs.
    *   *New:* `MsgCreateDeal` creates a `Deal` object. Proofs must match Deal ID.

**Immediate Tasks:**
1.  [x] Implement `MsgCreateDeal` in `nilchain`.
2.  [x] Implement `ActiveProviderList` Keeper.
3.  [x] Implement Deterministic Slotting Logic.

---

## Phase 3: "Store Wars" (Incentivized Testnet) (Months 6-12)
**Goal:** Stress test the system with adversarial behavior. This is your biggest marketing event before launch.

*   **Build (Tech):**
    *   **The L2 Bridge:** [x] Contract implemented & verified. Relayer pending.
    *   **Incentives:** [x] L1 Proof Verification (Rust FFI) & Rewards (Minting) active.
    *   **Block Explorer:** [x] "Lattice" Visualizer & Interactive Playground live.
    *   **System Upgrade:** [x] 8 MiB Mega-Data Units (Optimized for Throughput).
*   **Validate:**
    *   **Game Theory:** [x] Slashing implemented for invalid proofs (Anti-spam/Anti-fraud).
    *   **Economics:** [x] Token Minting (Rewards) and Burning (Slashing) active.
*   **Market (Hype):**
    *   **"Race to 1 Petabyte":** [x] Leaderboard UI implemented.
    *   **Design Partners:** Onboard *one* real data client.

## Phase 4: Mainnet Beta (Launch)
**Goal:** Real money, real data, "Training Wheels" on.

*   **Build:**
    *   **S3 Adapter:** [x] `nil_s3` Go service implemented (PUT/GET -> Shard -> Chain).
    *   **Governance:** [x] Emergency Council setup (`x/group`) & Mainnet Params configured.
    *   **Adversarial Simulation:** [x] End-to-End attack simulation & visualization.
    *   Production-grade Audits (Security).
*   **Validate:**
    *   Slow rollout of the "Lattice" (limit the number of nodes initially).
*   **Market:**
    *   **Re-branding:** [ ] Update copy to "Nilmanifold" & "Homogeneity".
    *   Announce the "Genesis Block."
    *   **Web2 Wrapper:** [ ] Documentation for S3 Adapter.
    *   **Governance:** [ ] Documentation for DAO & Council.
    *   Focus on the "Web2 Wrapper" (S3 compatibility) to attract actual users, not just crypto speculators.

---

## Phase 5: EVM Integration (Ethermint) - "The Bi-Lingual Chain"
**Goal:** Make `nilchain` compatible with MetaMask and Solidity to serve as a robust Testnet and simplify onboarding.

### Step 1: Dependencies & Configuration
*   [x] **Update `go.mod`:** Add `github.com/cosmos/evm` (v0.5.1) and `github.com/cosmos/go-ethereum`.
*   [x] **Configure App (`app.go`):**
    *   Register `EVMKeeper` and `FeeMarketKeeper`.
    *   Add EVM modules to `AppConfig` (using `depinject` overrides).
    *   *Note:* EVM Modules are temporarily disabled in `app.go` manual wiring for simulation tests due to a `MsgEthereumTx` signer panic in the Cosmos SDK runtime. They must be re-enabled for production binaries.
*   [x] **AnteHandler:** Implement a hybrid AnteHandler to support both Cosmos (Keplr) and Ethereum (MetaMask) signatures.
*   [x] **Genesis:** Update `genesis.json` generation to include EVM parameters (ChainID, Gas Limits). (Auto-generated usually).

### Step 2: Smart Contract Deployment
*   [ ] **Deploy `NilBridge.sol`:** Deploy the bridge contract directly to the internal EVM.
*   [ ] **Test Interaction:** Verify that calling the contract from MetaMask works.

### Step 3: Frontend Integration
*   [ ] **Wallet Connection:** Add `wagmi` / `viem` to `nil-website`.
*   [ ] **"Connect MetaMask" Button:** Allow users to see their balance and interact with the bridge contract.

---

### Recommended Work Stream Categories (Organizational)

To manage this, it is recommended to organize development efforts into these three ongoing streams:

**1. The "Engine Room" (Core Protocol)**
*   *Focus:* Rust/Go code, Cryptography, Consensus.
*   *Metric:* Block time, Verification speed (ms).
*   *Output:* `nil-core` repo.

**2. The "Experience" (Product & Tooling)**
*   *Focus:* CLI, JS SDK, Explorer, Documentation.
*   *Metric:* "Time to First File" (How fast can a new user store "hello.txt"?).
*   *Output:* NPM packages, Docs site.

**3. The "Lab" (Research & Simulation)**

*   *Focus:* Python/Jupyter Notebooks. Validating the economics and lattice distribution.

*   *Metric:* "Nakamoto Coefficient" (How decentralized is the lattice?).

*   *Output:* Research papers, Simulation reports.

## Spring Roadmap (Executed)

### 1. Work Stream: Strict Data Granularity & Deal Decoupling
*   [x] **Specs:** Adopted `rfc-data-granularity` (DealSize Tiers).
*   [x] **Types:** Added `DealSize` enum and updated `Deal` struct (Container).
*   [x] **Chain:** Refactored `MsgCreateDeal` (Capacity) and `MsgUpdateDealContent` (Commitment).
*   [x] **CLI/Gateway:** Updated tools to support the 2-step flow.
*   [x] **Verification:** Added Unit Tests and E2E Gateway Test (`e2e_gateway_spring.sh`).

### 2. Work Stream: Heat & Traffic Observability (Phase A)
*   [x] **State:** Added `DealHeatState` to types.
*   [x] **Keeper:** Added `DealHeatStates` collection and `IncrementHeat` logic.
*   [x] **Hook:** Instrumented `ProveLiveness` to track bytes served.

### 3. Work Stream: The Deputy System (Phase 1)
*   [x] **P2P:** Added `AskForProxy` message structure and handler stub in `nil_p2p`.
*   [x] **CLI:** Added `proxy` command to `nil-p2p` REPL.

---

## Spring Roadmap - Phase 2: The Triple Proof & Web Modernization

This phase focuses on implementing the scalable "Triple Proof" architecture and exposing the new features in the Web UI.

### 1. Work Stream: Triple Proof Architecture (Core & Chain)
**Goal:** Implement the 3-Hop Verification to allow dealing with large datasets using a single 48-byte Manifest Root.

*   **Step A: Protobuf Definitions (Executed)**
    *   [x] **File:** `nilchain/proto/nilchain/nilchain/v1/types.proto`
    *   [x] **Task:** Update `Deal` struct: replace `string cid` with `bytes manifest_root` (48-byte) and add `uint64 total_mdus`.
    *   [x] **Task:** Define `message ChainedProof`: `mdu_index`, `mdu_root_fr`, `manifest_opening` (Hop 1), `blob_commitment`, `merkle_path` (Hop 2), `z`, `y`, `kzg_opening` (Hop 3).
*   **Step B: Core Cryptography (`nil_core`) (Executed)**
    *   [x] **Task:** Implement `ManifestMDU` generation:
        *   Input: List of MDU Roots (hashes).
        *   Process: Map hashes to Scalars -> Blob -> KZG Commitment.
        *   Output: `ManifestRoot` (G1) and `ManifestBlob` data.
*   **Step C: Chain Verification Logic**
    *   [x] **Task (Core):** Implement `verify_manifest_inclusion` in `nil_core` (Need to handle Roots of Unity coordinate mapping).
    *   [x] **Task (FFI):** Expose `nil_verify_chained_proof` (Hop 1 + 3) and `nil_compute_manifest_commitment`.
    *   [x] **File:** `nilchain/x/nilchain/keeper/msg_server.go` (or dedicated verifier).
    *   [x] **Task:** Implement `VerifyChainedProof` algorithm using FFI:
        *   Hop 1 (KZG): Verify MDU Root is in Manifest.
        *   Hop 2 (Merkle): Verify Blob is in MDU.
        *   Hop 3 (KZG): Verify Data is in Blob.
*   **Step D: CLI Tooling**
    *   [x] **Task:** Update `nil-cli shard` to produce `ManifestMDU` and the final `ManifestRoot` for the Deal.

### 2. Work Stream: Web UI Modernization
**Goal:** Update the frontend to reflect the "Container vs Content" model and visualize the new architecture.

*   **Step A: Dashboard Updates (`src/components/Dashboard.tsx`)**
    *   [x] **Task:** Refactor "Create Storage Deal" into a multi-step component:
        *   **Tab 1 (Alloc):** "Allocate Capacity". Inputs: Size Tier, Duration, Escrow. Calls `create-deal`.
        *   **Tab 2 (Content):** "Commit Content". Inputs: Deal ID (Select), File (Upload). Calls `update-deal-content`.
    *   [x] **Task:** Update Deal List to distinguish between "Empty" (Capacity only) and "Active" (Content Committed) deals.
    *   [x] **Task:** Add "Bytes Served" column (Heat) to the Deal List using `DealHeatState` (via `proofs` aggregation for now, pending full HeatState exposure).
*   **Step B: Deal Explorer (New Component/Page)**
    *   [x] **Task:** Create `src/components/DealDetail.tsx`.
    *   [x] **Task:** Visualize the "Manifest" (List of MDUs) if available (fetched from gateway).
    *   [x] **Task:** Show "Liveness History" (Heatmap of proofs) and "Heat" stats.
*   **Step C: Integration Hooks (`src/hooks/`)**
    *   [x] **Task:** Update `useCreateDeal.ts` to call the new `GatewayCreateDeal` (with tiers).
    *   [x] **Task:** Create `useUpdateDealContent.ts` to call `GatewayUpdateDealContentFromEvm`.

### 4. Work Stream: Visualizations & Marketing
*   [x] **Task:** Implement interactive Performance Market visualization in `nil-website` (The Latency Racer).
*   [x] **Task:** Visualize `DealHeatState` in Deal Explorer (Added `GetDealHeat` query and UI integration).

### 5. Work Stream: Protocol Cleanup (Dynamic Sizing)
*   [ ] **Proto:** Remove `DealSize` enum and `deal_size` field from `types.proto`.
*   [ ] **Logic:** Update `MsgCreateDeal` to ignore tier, defaulting to a "Thin Provisioned" state (0 bytes).
*   [ ] **CLI:** Remove `tier` argument from `nil-cli create-deal`.
*   [ ] **Web:** Remove Tier selection from Dashboard UI (`Dashboard.tsx`).
*   [ ] **Web:** Remove Tier display from `DealDetail.tsx`.

### 6. Work Stream: UI Polish
*   [ ] **DealDetail:** Refactor `DealDetail.tsx` to use semantic Tailwind classes (support Light Mode).
*   [ ] **Visualization:** Update Deal Explorer to visualize "Stripe Layout" (12 columns) instead of just linear blobs.

## Winter Roadmap: StripeReplica & Thick Client (Phase 3)

**Goal:** Enable client-side encryption, erasure coding, and KZG commitment generation in the browser (Thick Client) to support the Mode 2 (StripeReplica) architecture.

### 1. WASM Foundation (Rust)
*   [x] **Build:** Configure `nil_core` to compile to `wasm32-unknown-unknown` (replaced `c-kzg` with `bls12_381` manual impl).
*   [x] **Trusted Setup:** Implement `KzgContext::load_from_reader` in `nil_core` to accept raw setup data from JS.
*   [x] **Bindgen:** Expose `expand_file` to JS via `wasm-bindgen`.

### 2. Mode 2 Logic (Rust)
*   [x] **Erasure Coding:** Integrate `reed-solomon-erasure` crate (RS 12,8).
*   [x] **Expansion:** Implement `expand_mdu(data: &[u8]) -> (WitnessMdu, Vec<Shard>)` following the "Blob Alignment" spec (§ 8).
*   [x] **Exposure:** Bind `expand_mdu` to JS, returning a structured object with Shards and Witness.

### 3. Frontend Integration (React)
*   [x] **Worker:** Create `src/workers/mduWorker.ts` to run `expand_mdu` off the main thread.
*   [x] **Asset:** Serve `trusted_setup.txt` (or bin) as a static asset.
*   [x] **UI:** Replace `FileSharder.tsx` mock with `WasmWorker` integration.
*   [x] **Validation:** Verified WASM compilation and basic logic flow.

### 4. Protocol Cleanup & UI Polish
*   [x] **UI:** Remove Tier selection from Dashboard UI (`Dashboard.tsx`).
*   [x] **UI:** Remove Tier display from `DealDetail.tsx`.
*   [x] **Style:** Refactor `DealDetail.tsx` to use semantic Tailwind classes (support Light Mode).

## Future Phases
*   **Web2 Wrapper:** S3 Adapter documentation and further integration (Updated S3AdapterDocs page).
*   **Governance:** DAO & Council setup visualization (Updated GovernanceDocs page with dashboard).
*   **Adversarial Simulation:** End-to-End attack simulation & visualization (P&L model - *Completed*).
*   **Unified Liveness:** Integrate user traffic directly into consensus via `RetrievalReceipt` aggregation (partially implemented in Phase 2).

## 8. Gap Analysis: Frontend vs. Protocol Spec

Future agents utilizing this documentation must be aware of the following architectural divergence detected during the review of `@spec.md` and `@nil-website/**`:

- **Triple Proof Model:** The frontend **does not** currently implement the Triple Proof verification logic described in `@notes/triple-proof.md`. It relies on the Gateway (`nil_gateway` / `nil_s3`) to perform these checks.
- **MDU Packing:** The frontend **does not** pack files into MDUs (as defined in `@spec.md`). It streams raw bytes to the Gateway via `useUpload`.
- **Simulation vs. Reality:** The `FileSharder.tsx` component is a visual simulation using SHA-256 and is **not** part of the actual transaction pipeline.
- **Action Item:** Future work involves compiling the Rust `nil_core` crate to Wasm to enable true "Thick Client" functionality (Local KZG generation, MDU packing, and autonomous SP negotiation) directly in the browser.

## 9. Current Architecture State: Mode 2 & NilFS (As of Dec 2025)

**Status:** Specs Aligned. Implementation Pending.

We have finalized the design for **Mode 2 (StripeReplica)** and the **NilFS Layout**.

### 9.1 Mode 2 Alignment
*   **Atomic Unit:** 1 MB Shard.
*   **MDU Unit:** 8 MB (8 Shards x 1 MB).
*   **Configuration:** RS(12, 8). 12 Providers per Deal.
*   **Verification:** Uses **Replicated Metadata** (Witness MDUs) to enable Shared-Nothing Verification.
*   **Source of Truth:** `rfcs/rfc-blob-alignment-and-striping.md`.

### 9.2 NilFS Layout (Spec Status)
*   **Current Target (V1):** Fixed 6MB Table. Simple, Robust, but limited capacity (98k files).
    *   **Decision:** We are implementing **V1** for the current Devnet.
*   **Future Upgrade (V2):** Detached Paths / Inode #1.
    *   **Decision:** Deferred to Mainnet.
    *   **Reference:** `notes/triple-proof-review.md`.

## 10. `nil_s3` Refactor: Implementing Filesystem on Slab (TDD Plan)

This section outlines the Test-Driven Development (TDD) plan for refactoring the `nil_s3` Gateway to implement the "Filesystem on Slab" architecture. Each step includes specific tests to pass before considering the task complete.

### 10.1 Task 1: Define Go Structs for MDU #0 Layout (V1 Schema)

**Status:** [x] COMPLETED

**Description:** Define Go structs (`FileTableHeader`, `FileRecordV1`) for the MDU #0 Super-Manifest layout in a new package `nil_s3/pkg/layout`. This includes bit-packing logic for `length_and_flags`.

**TDD Plan:** Create `nil_s3/pkg/layout/layout_test.go` first.

1.  **`TestBitPacking`**:
    *   **Input:** A `length` value (e.g., 100), and specific `flags` (e.g., `Encrypted | Gzip`).
    *   **Expected Output:** A `u64` representing `length_and_flags` with the correct bit-packing.
    *   **Verification:** Decode the `u64` back into `length` and `flags`, asserting they match the input.
2.  **`TestStructAlignment`**:
    *   Use `unsafe.Sizeof` to assert that `FileRecordV1` is exactly 64 bytes.
    *   Assert that `FileTableHeader` is exactly 128 bytes.
3.  **`TestSerialization`**:
    *   Create an instance of `FileRecordV1` with sample data.
    *   Serialize it to a `[]byte`.
    *   Deserialize the `[]byte` back into a new `FileRecordV1` instance.
    *   Assert that the deserialized instance is deep-equal to the original.
    *   Repeat for `FileTableHeader`.

**Definition of Done:** `go test ./pkg/layout` passes with 100% coverage of struct definition and serialization/deserialization logic. All bit-packing and size assertions are correct.

### 10.2 Task 2: Implement `Mdu0Builder` Logic

**Status:** [x] COMPLETED

**Description:** Develop a `Mdu0Builder` module responsible for initializing, modifying, and serializing the 8MB MDU #0 buffer. This builder must account for the Root Table containing roots for MDU #0 itself, **Witness MDUs**, and User Data MDUs.

**TDD Plan:** Create `nil_s3/pkg/builder/builder_test.go` first.

1.  **`TestInitEmptyMdu0`**:
    *   Create a new `Mdu0Builder` instance with `max_user_mdus` (e.g., 65536).
    *   Assert that the internal 8MB buffer is initialized correctly:
        *   The `FileTableHeader` has `magic="NILF"`, `version=1`, `record_size=64`, `record_count=0`.
        *   The Root Table region (Blobs 0-15) is zeroed.
        *   The File Table region (Blobs 16-63) is mostly zeroed (except header).
        *   **Verify `W` calculation**: Ensure `W` (Witness MDUs count) is correctly derived based on `max_user_mdus`.
2.  **`TestAppendFileRecord`**:
    *   Initialize an `Mdu0Builder`.
    *   Add a `FileRecordV1` for "file1.txt" (1KB at logical offset 0).
    *   Assert that `FileTableHeader.record_count` increments.
    *   Assert that `FileTable` entry at index 0 matches the input record.
    *   Add a second `FileRecordV1` for "file2.txt". Assert `record_count` is 2 and the second entry is correct.
3.  **`TestAddRoot`**:
    *   Initialize an `Mdu0Builder`.
    *   Add a dummy 32-byte root (e.g., all `0xAA`) for `MDU #1` (index 0).
    *   Assert that the Root Table region at the correct offset (Blob 0, Offset 0) contains this root.
    *   **Crucial:** This root corresponds to `MDU #1` (first Witness MDU).
4.  **`TestLoadAndModify`**:
    *   Initialize an `Mdu0Builder`, add a file record and a root.
    *   Serialize the builder's buffer to a `[]byte`.
    *   Create a *new* `Mdu0Builder` and `Load()` it from the `[]byte`.
    *   Add another file record and root.
    *   Assert that `record_count` and new root are correctly applied to the loaded state.
5.  **`TestFindFreeSpace_TombstoneSplitting`**: (Covers deletion/reuse logic)
    *   Initialize builder. Add a 100KB file. Delete it (mark as tombstone).
    *   Add a 30KB file. Assert that the 100KB tombstone is reused (partially), and a new 70KB tombstone is appended.
    *   Assert File Table count is correct.

**Definition of Done:** `go test ./pkg/builder` passes, creating valid 8MB binary images, and correctly handling the Root Table indexing for Witness and User Data MDUs.

### 10.3 Task 3: Refactor `GatewayUpload` (Service Layer)

**Status:** [x] COMPLETED

**Description:** Modify the `GatewayUpload` handler (`nil_s3/main.go`) to utilize the `Mdu0Builder` and the new "Filesystem on Slab" logic, including the generation and storage of **Witness MDUs**.

**TDD Plan:** Create `nil_s3/main_test.go` (or a dedicated integration test package for handlers).

1.  **`TestUploadNewDealLifecycle`**:
    *   Mock `nil_cli` `shardFile` call to return dummy MDUs and roots for user data.
    *   Call `GatewayUpload` for "file_A.txt" (no `deal_id` provided, `max_user_mdus` specified).
    *   **Assert:** The response includes a *newly generated* `deal_id` (simulated) and the initial `manifest_root` for MDU #0.
    *   **Crucial:** `nil_s3` must now:
        *   Generate the actual content for MDU #0 (empty FAT, roots for Witness and User Data MDUs set to zeros/dummies).
        *   Generate **Witness MDUs** (filled with zeros initially).
        *   Store these `(1 + W)` initial MDUs to disk.
    *   Simulate subsequent `GatewayUpdateDealContent` call to commit this.
2.  **`TestUploadAppendToExistingDeal`**:
    *   Pre-populate deal state: an existing `deal_id` on chain, and on-disk representations for MDU #0, Witness MDUs, and existing User Data MDUs.
    *   Call `GatewayUpload` for "file_B.txt", providing the `deal_id`.
    *   **Assert:** The response contains the `manifest_root` reflecting "file_B.txt" appended to the File Table, and the new `allocated_length`.
    *   **Verification:** `nil_s3` must:
        *   Read the existing MDU #0 and Witness MDUs.
        *   Pack "file_B.txt" into new User Data MDUs.
        *   Generate/update corresponding roots in MDU #0.
        *   Generate/update corresponding Blob Commitments in Witness MDUs.
        *   Store updated MDU #0, Witness MDUs, and new User Data MDUs.
3.  **`TestUploadTombstoneReuse`**:
    *   Pre-populate deal with a deleted file.
    *   Call `GatewayUpload` for a new file that fits the deleted slot.
    *   **Assert:** `MDU #0` (and Witness MDUs) are updated reflecting reuse (and splitting if necessary).
4.  **`TestUploadLargeFileExpansion`**:
    *   Upload a file spanning multiple User Data MDUs.
    *   **Assert:** `Mdu0Builder` correctly adds multiple roots to the Root Table and `allocated_length` is updated correctly.
    *   **Verification:** Ensure Witness MDUs are correctly updated for all new User Data MDUs.

**Definition of Done:** The `GatewayUpload` handler correctly processes new file uploads, managing the MDU #0 and Witness MDUs states locally, and returning the necessary information for `MsgUpdateDealContent` (new `ManifestRoot`, `allocated_length`).

### 10.4 Task 4: Refactor `GatewayFetch` (Filesystem Resolution)

**Status:** [x] COMPLETED

**Description:** Update the `GatewayFetch` handler to resolve files by their path within a Deal, rather than requiring a direct CID for a single file. This involves reading MDU #0 and retrieving Blob Commitments from Witness MDUs for proof generation.

**TDD Plan:** Extend `nil_s3/main_test.go` (or a dedicated integration test package for handlers).

1.  **`TestFetchByExistingPath`**:
    *   Setup deal state (MDU #0, Witness MDUs, User Data MDUs) with "video.mp4" via `Mdu0Builder`.
    *   Call `GatewayFetch(deal_id, path="video.mp4")`.
    *   **Assert:** `MDU #0` is correctly read and parsed to locate the `FileRecord`.
    *   **Crucial:** Assert Blob Commitments are correctly retrieved from **Witness MDUs** for the relevant User Data MDUs.
    *   Mock retrieval of the actual User Data MDUs. Assert the correct bytes are streamed back (e.g., via `httptest.ResponseRecorder`).
2.  **`TestFetchPathNotFound`**:
    *   Call `GatewayFetch` for non-existent path. Assert 404.
3.  **`TestFetchFromDeletedFile`**:
    *   Setup deal state with a file marked as a Tombstone.
    *   Call `GatewayFetch` for that path. Assert a 404.
4.  **`TestFetchOffsetMapping`**:
    *   Upload a file spanning multiple User Data MDUs.
    *   Request specific byte ranges within the file.
    *   **Assert:** Internal logic correctly maps `Logical_Offset` to `User_Data_MDU_Index` and `Offset_within_MDU`, and correctly retrieves commitments from Witness MDUs.

**Definition of Done:** `GatewayFetch` correctly resolves file paths, retrieves `FileRecord`s, reads Blob Commitments from Witness MDUs, and streams the correct byte ranges from the User Data MDUs.

### 10.5 Task 5: Implement `GatewayUpdateDealContent` Refactor (Chain Interaction)

**Status:** [x] COMPLETED

**Description:** Modify `GatewayUpdateDealContentFromEvm` (and potentially `GatewayUpdateDealContent`) to properly handle the `allocated_length` field and ensure the on-chain representation matches the `nil_s3`'s understanding of the Deal's state.

**TDD Plan:** Create an integration test script (`test_lifecycle.sh`) that orchestrates chain operations.

1.  **`TestFullDealLifecycle_E2E`**:
    *   **Phase 1: Setup:** Start local `nilchaind` and `nil_s3`.
    *   **Phase 2: Create Deal:** Use `GatewayCreateDealFromEvm` (with `max_user_mdus` to imply max capacity) to establish a base deal.
        *   **Assertion:** Verify `allocated_length` on-chain equals `1 + W` (MDU #0 + Witness MDUs).
    *   **Phase 3: Upload File 1 (Expansion):**
        *   Call `GatewayUpload` for "first.txt" (e.g., 100KB).
        *   Capture the returned `manifest_root` and `new_allocated_length`.
        *   Call `GatewayUpdateDealContentFromEvm` with this data.
        *   **Assertion:** Query `nilchaind` to verify that the Deal on-chain now has the correct `manifest_root` and `allocated_length`.
    *   **Phase 4: Upload File 2 (Append):**
        *   Call `GatewayUpload` for "second.txt".
        *   Capture new `manifest_root` and `new_allocated_length`.
        *   Call `GatewayUpdateDealContentFromEvm`.
        *   **Assertion:** Query `nilchaind` to verify that the Deal on-chain has updated again.
    *   **Phase 5: Fetch & Verify:** Call `GatewayFetch` for "first.txt" and "second.txt". Assert content is correct.
    *   **Phase 6: Deletion & Reupload:** Simulate deletion, then re-upload a file to reuse space. Assert `manifest_root` updates correctly and `allocated_length` remains stable (if no new User Data MDUs were needed).

**Definition of Done:** The end-to-end chain interaction correctly updates the `Deal.manifest_root` and `Deal.allocated_length` on-chain, and these changes are reflected accurately when querying the chain.

## 11. Active Agent Work Queue (Current)

This section tracks the currently active TODOs for the AI agent working in this repo. Items here should be updated, checked off, and committed as work is completed.

### 11.1 EVM Integration UX (Phase 5 Step 2–3)
- [ ] Implement and stabilize `NilBridge.sol` deployment to the internal EVM (Foundry), including fixing funding for the deploy key so `scripts/deploy_bridge_local.sh` succeeds by default under `./scripts/run_local_stack.sh start`.
- [ ] Ensure `NIL_DEPLOY_BRIDGE=1` remains the default behavior and that a successful deploy writes `_artifacts/bridge_address.txt`, which is then wired into the web app via `VITE_BRIDGE_ADDRESS`.
- [ ] Verify and, if needed, finish the Wagmi/Viem Web3 provider wiring in `nil-website` (Connect MetaMask, chain config, RPC URL).
- [ ] Add a “Connect MetaMask” flow that shows the user’s NIL balance and exposes at least one happy-path NilBridge interaction (e.g., a simple `ping`/view or demo call) from the dashboard.

### 11.2 Protocol Cleanup (Dynamic Sizing)
- [ ] Remove `DealSize` enum and `deal_size` field from `nilchain/proto/nilchain/nilchain/v1/types.proto` and regenerate Go/Rust types.
- [ ] Update `MsgCreateDeal` and `MsgCreateDealFromEvm` handlers to ignore any legacy tier/size_tier fields and treat deals as thin-provisioned (0 bytes until content is committed).
- [ ] Update `nil_cli` (`create-deal`/gateway flows) to drop any `tier` argument and align with the thin-provisioning semantics.
- [ ] Update `nil_s3` and `nil-website` so the dashboard, deal explorer, and gateway endpoints no longer reference tiers, and instead rely on `size_bytes`/`allocated_length` and MDUs.
- [ ] Extend/adjust migrations and tests so dynamic sizing is covered end-to-end (genesis migration, keeper tests, CLI tests).

### 11.3 Gateway & File Lifecycle E2E
- [x] Stabilize `/gateway/upload`, `/gateway/create-deal-evm`, and `/gateway/update-deal-content-evm` so that a full “allocate capacity → upload file → commit content → fetch file” flow works reliably via both curl and the web UI.
- [x] Ensure errors like “failed to parse tx response” and “deal creation failed: deal_id not found in transaction events” are surfaced as non-200 responses from the gateway (no silent success).
- [x] Expand shell-based e2e scripts (`scripts/e2e_lifecycle.sh`) to cover: deal creation (EVM), upload, update-deal-content, LCD verification of `manifest_root` and size, and fetch verification.
    - *Status:* **COMPLETED**.
    - *Note:* Fixed syntax errors in `msg_server.go` and verified the full lifecycle (Create -> Upload -> Update -> Fetch) works with EIP-712 signatures using ChainID 31337.

### 11.4 Frontend Browser E2E (Cypress/Playwright)
- [ ] Introduce a lightweight browser e2e suite (Cypress or Playwright) under `nil-website` that runs against `./scripts/run_local_stack.sh start`.
- [ ] Add a smoke test that: connects a wallet (using a test account), creates a deal via the dashboard, uploads a file, commits content, and asserts the deal row shows a non-zero size and a manifest root.
- [ ] Add a smoke test for the deal explorer to confirm that an uploaded file appears and can be fetched via the gateway.

### 11.5 Core & WASM Health
- [ ] Keep `nil_core` and `nil_cli` warning-free across `cargo build` and `cargo test`, and expand unit/integration tests as new KZG/coding functionality is added.
- [ ] Ensure the WASM Mode 2 path (`expand_mdu` / `expand_file`) is exercised by tests (Rust integration tests and, where feasible, frontend tests) so “Invalid scalar”/encoding issues are caught automatically.
