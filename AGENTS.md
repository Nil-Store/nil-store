# NilStore Network Development Roadmap

## Protocol for Agents
**CRITICAL:** When pushing changes to the repository, you **MUST** push to both remotes to ensure synchronization.
*   `git push origin main` (Primary)
*   `git push nil-store main` (Mirror)

### Git Best Practices for Agents
*   **Commit Regularly:** Always commit your work frequently, in small, logical chunks.
*   **Prohibited Commands:** Agents are strictly forbidden from running aggressive Git commands like `git clean` or `git reset --hard` as these can lead to irreversible data loss of uncommitted work. If such commands are necessary, confirm with the user first.
*   **Tests Before Push:** For every non-trivial change, run the most relevant unit/e2e tests before committing. Do not push code that you haven't at least smoke-tested locally.
*   **Commit & Push Cadence:** Treat this file as the canonical TODO list. As you complete tasks, update the checklist, commit your work with a descriptive message, and push to both remotes (`origin` and `nil-store`) in small, verified increments.
*   **Default Autonomy:** Unless the user explicitly says “don’t commit/push yet,” agents should **automatically** commit completed work (after relevant tests pass) and push to both remotes. Keep commits small and descriptive, and avoid batching unrelated changes.

This document outlines a strategic "Go-to-Market" Engineering Roadmap for the NilStore Network, designed to iteratively validate, market, and refine the project from "Paperware" to "Software." It recognizes the need to align Technology, Community, and Economy.

## Phase 1: The "Localhost" Prototype (Months 1-3)
**Goal:** Prove the math works on a single machine. Don't worry about the network yet.

*   **Build (Tech):**
    *   **Core Crypto Library:** [x] A standalone Rust/Go library implementing the KZG commitments and Argon2id logic.
    *   **CLI Tool:** [x] A simple `nil-cli` that can take a file, shard it, generating the "Useful Data" proof, and verify it locally.
    *   **Mock L1:** [x] Use a local JSON file or SQLite DB to simulate the "Chain State."
*   **Validate:**
    *   **Benchmark:** Can a 2015 MacBook verify a proof generated by a 2024 Server in < 10ms?
        *   [x] **Result:** ~0.94ms per proof on current hardware. Well within < 10ms budget.
    *   **Argon2id Timing:** Does the Argon2id timing actually prevent on-demand generation?
        *   [x] **Result:** ~191ms per 1KB block (15MB/2 passes).
*   **Market (Narrative):**
    *   **"Building in Public":** Publish the `core-crypto` repo.
    *   **Content:** Write a blog post: *"Why we chose PoDE over Filecoin's Seal"* (Comparatives sell well).
    *   **Educational Website:** [x] Launch a landing page to demonstrate benchmarks and visually explain core algorithms (Sharding, KZG, Argon2id).

## Phase 2: The "Friendly" Devnet (Months 3-6)
**Goal:** Connect 10-50 nodes controlled by you and "friendly" early backers.

*   **Build (Tech):**
    *   **The "Thin" L1:** [x] Initialize the Cosmos-SDK chain. Minimal governance.
    *   **P2P Networking:** [x] Nodes can now gossip shards to each other.
    *   **Faucet:** [x] A simple way to get test tokens.
*   **Validate:**
    *   **Chaos Testing:** [x] Kill nodes randomly. Does the data survive?
    *   **Latency:** [x] How long does it take for a shard to propagate from London to Tokyo?
        *   **Result:** ~14.38ms (Localhost).
*   **Market (Community):**
    *   **The "Founding Node" Program:** Hand-pick 20 diverse engineers (universities, data centers, crypto-natives) to run nodes. Give them direct access to the dev team.
    *   **Discord:** Open a Discord, but keep it technical.
*   **Refine:**
    *   [x] The installation experience. If it takes a PhD to install `nild`, you will fail. It must be `curl | bash`.

## Phase 2.5: The Pivot (Performance Market & System Placement)
**Status:** Spec Updated, Implementation Pending.

We have moved away from "Physics-Policed" constraints (strict 1.1s deadlines) to a **Market-Incentivized** model.

*   **Architecture Change 1: System-Defined Placement.**
    *   *Old:* User selects SPs. (Vulnerable to Sybil).
    *   *New:* Chain selects SPs deterministically (`Hash(Deal + Block)`).
    *   *Goal:* Anti-Sybil. Forced Diversity.
*   **Architecture Change 2: Performance Market.**
    *   *Old:* 1.1s Deadline or Slash.
    *   *New:* Block-Tiered Rewards (example windows). H+1 (Platinum), H+5 (Gold), H+20 (Fail). Exact tier windows are protocol parameters.
    *   *Goal:* Incentivize speed without punishing honest jitter. Implicitly filters S3 Glacier.
*   **Architecture Change 3: Explicit Deal State.**
    *   *Old:* Stateless proofs.
    *   *New:* `MsgCreateDeal` creates a `Deal` object. Proofs must match Deal ID.

**Immediate Tasks:**
1.  [x] Implement `MsgCreateDeal` in `nilchain`.
2.  [x] Implement `ActiveProviderList` Keeper.
3.  [x] Implement Deterministic Slotting Logic.

---

## Phase 3: "Store Wars" (Incentivized Testnet) (Months 6-12)
**Goal:** Stress test the system with adversarial behavior. This is your biggest marketing event before launch.

*   **Build (Tech):**
    *   **The L2 Bridge:** [x] Contract implemented & verified. Relayer pending.
    *   **Incentives:** [x] L1 Proof Verification (Rust FFI) & Rewards (Minting) active.
    *   **Block Explorer:** [x] "Lattice" Visualizer & Interactive Playground live.
    *   **System Upgrade:** [x] 8 MiB Mega-Data Units (Optimized for Throughput).
*   **Validate:**
    *   **Game Theory:** [x] Slashing implemented for invalid proofs (Anti-spam/Anti-fraud).
    *   **Economics:** [x] Token Minting (Rewards) and Burning (Slashing) active.
*   **Market (Hype):**
    *   **"Race to 1 Petabyte":** [x] Leaderboard UI implemented.
    *   **Design Partners:** Onboard *one* real data client.

## Phase 4: Mainnet Beta (Launch)
**Goal:** Real money, real data, "Training Wheels" on.

*   **Build:**
    *   **S3 Adapter:** [x] `nil_gateway` Go service implemented (PUT/GET -> Shard -> Chain).
    *   **Governance:** [x] Emergency Council setup (`x/group`) & Mainnet Params configured.
    *   **Adversarial Simulation:** [x] End-to-End attack simulation & visualization.
    *   Production-grade Audits (Security).
*   **Validate:**
    *   Slow rollout of the "Lattice" (limit the number of nodes initially).
*   **Market:**
    *   **Re-branding:** [ ] Update copy to "Nilmanifold" & "Homogeneity".
    *   Announce the "Genesis Block."
    *   **Web2 Wrapper:** [ ] Documentation for S3 Adapter.
    *   **Governance:** [ ] Documentation for DAO & Council.
    *   Focus on the "Web2 Wrapper" (S3 compatibility) to attract actual users, not just crypto speculators.

---

## Phase 5: EVM Integration (Ethermint) - "The Bi-Lingual Chain"
**Goal:** Make `nilchain` compatible with MetaMask and Solidity to serve as a robust Testnet and simplify onboarding.

### Step 1: Dependencies & Configuration
*   [x] **Update `go.mod`:** Add `github.com/cosmos/evm` (v0.5.1) and `github.com/cosmos/go-ethereum`.
*   [x] **Configure App (`app.go`):**
    *   Register `EVMKeeper` and `FeeMarketKeeper`.
    *   Add EVM modules to `AppConfig` (using `depinject` overrides).
    *   *Note:* EVM Modules are temporarily disabled in `app.go` manual wiring for simulation tests due to a `MsgEthereumTx` signer panic in the Cosmos SDK runtime. They must be re-enabled for production binaries.
*   [x] **AnteHandler:** Implement a hybrid AnteHandler to support both Cosmos (Keplr) and Ethereum (MetaMask) signatures.
*   [x] **Genesis:** Update `genesis.json` generation to include EVM parameters (ChainID, Gas Limits). (Auto-generated usually).

### Step 2: Smart Contract Deployment
*   [ ] **Deploy `NilBridge.sol`:** Deploy the bridge contract directly to the internal EVM.
*   [ ] **Test Interaction:** Verify that calling the contract from MetaMask works.

### Step 3: Frontend Integration
*   [ ] **Wallet Connection:** Add `wagmi` / `viem` to `nil-website`.
*   [ ] **"Connect MetaMask" Button:** Allow users to see their balance and interact with the bridge contract.

---

### Recommended Work Stream Categories (Organizational)

To manage this, it is recommended to organize development efforts into these three ongoing streams:

**1. The "Engine Room" (Core Protocol)**
*   *Focus:* Rust/Go code, Cryptography, Consensus.
*   *Metric:* Block time, Verification speed (ms).
*   *Output:* `nil-core` repo.

**2. The "Experience" (Product & Tooling)**
*   *Focus:* CLI, JS SDK, Explorer, Documentation.
*   *Metric:* "Time to First File" (How fast can a new user store "hello.txt"?).
*   *Output:* NPM packages, Docs site.

**3. The "Lab" (Research & Simulation)**

*   *Focus:* Python/Jupyter Notebooks. Validating the economics and lattice distribution.

*   *Metric:* "Nakamoto Coefficient" (How decentralized is the lattice?).

*   *Output:* Research papers, Simulation reports.

## Spring Roadmap (Executed)

### 1. Work Stream: Strict Data Granularity & Deal Decoupling
*   [x] **Specs:** Adopted `rfc-data-granularity` (DealSize Tiers).
*   [x] **Types:** Added `DealSize` enum and updated `Deal` struct (Container).
*   [x] **Chain:** Refactored `MsgCreateDeal` (Capacity) and `MsgUpdateDealContent` (Commitment).
*   [x] **CLI/Gateway:** Updated tools to support the 2-step flow.
*   [x] **Verification:** Added Unit Tests and E2E Gateway Test (`e2e_gateway_spring.sh`).

### 2. Work Stream: Heat & Traffic Observability (Phase A)
*   [x] **State:** Added `DealHeatState` to types.
*   [x] **Keeper:** Added `DealHeatStates` collection and `IncrementHeat` logic.
*   [x] **Hook:** Instrumented `ProveLiveness` to track bytes served.

### 3. Work Stream: The Deputy System (Phase 1)
*   [x] **P2P:** Added `AskForProxy` message structure and handler stub in `nil_p2p`.
*   [x] **CLI:** Added `proxy` command to `nil-p2p` REPL.

---

## Spring Roadmap - Phase 2: The Triple Proof & Web Modernization

This phase focuses on implementing the scalable "Triple Proof" architecture and exposing the new features in the Web UI.

### 1. Work Stream: Triple Proof Architecture (Core & Chain)
**Goal:** Implement the 3-Hop Verification to allow dealing with large datasets using a single 48-byte Manifest Root.

*   **Step A: Protobuf Definitions (Executed)**
    *   [x] **File:** `nilchain/proto/nilchain/nilchain/v1/types.proto`
    *   [x] **Task:** Update `Deal` struct: replace `string cid` with `bytes manifest_root` (48-byte) and add `uint64 total_mdus`.
    *   [x] **Task:** Define `message ChainedProof`: `mdu_index`, `mdu_root_fr`, `manifest_opening` (Hop 1), `blob_commitment`, `merkle_path` (Hop 2), `z`, `y`, `kzg_opening` (Hop 3).
*   **Step B: Core Cryptography (`nil_core`) (Executed)**
    *   [x] **Task:** Implement `ManifestMDU` generation:
        *   Input: List of MDU Roots (hashes).
        *   Process: Map hashes to Scalars -> Blob -> KZG Commitment.
        *   Output: `ManifestRoot` (G1) and `ManifestBlob` data.
*   **Step C: Chain Verification Logic**
    *   [x] **Task (Core):** Implement `verify_manifest_inclusion` in `nil_core` (Need to handle Roots of Unity coordinate mapping).
    *   [x] **Task (FFI):** Expose `nil_verify_chained_proof` (Hop 1 + 3) and `nil_compute_manifest_commitment`.
    *   [x] **File:** `nilchain/x/nilchain/keeper/msg_server.go` (or dedicated verifier).
    *   [x] **Task:** Implement `VerifyChainedProof` algorithm using FFI:
        *   Hop 1 (KZG): Verify MDU Root is in Manifest.
        *   Hop 2 (Merkle): Verify Blob is in MDU.
        *   Hop 3 (KZG): Verify Data is in Blob.
*   **Step D: CLI Tooling**
    *   [x] **Task:** Update `nil-cli shard` to produce `ManifestMDU` and the final `ManifestRoot` for the Deal.

### 2. Work Stream: Web UI Modernization
**Goal:** Update the frontend to reflect the "Container vs Content" model and visualize the new architecture.

*   **Step A: Dashboard Updates (`src/components/Dashboard.tsx`)**
    *   [x] **Task:** Refactor "Create Storage Deal" into a multi-step component:
        *   **Tab 1 (Alloc):** "Allocate Capacity". Inputs: Size Tier, Duration, Escrow. Calls `create-deal`.
        *   **Tab 2 (Content):** "Commit Content". Inputs: Deal ID (Select), File (Upload). Calls `update-deal-content`.
    *   [x] **Task:** Update Deal List to distinguish between "Empty" (Capacity only) and "Active" (Content Committed) deals.
    *   [x] **Task:** Add "Bytes Served" column (Heat) to the Deal List using `DealHeatState` (via `proofs` aggregation for now, pending full HeatState exposure).
*   **Step B: Deal Explorer (New Component/Page)**
    *   [x] **Task:** Create `src/components/DealDetail.tsx`.
    *   [x] **Task:** Visualize the "Manifest" (List of MDUs) if available (fetched from gateway).
    *   [x] **Task:** Show "Liveness History" (Heatmap of proofs) and "Heat" stats.
*   **Step C: Integration Hooks (`src/hooks/`)**
    *   [x] **Task:** Update `useCreateDeal.ts` to call the new `GatewayCreateDeal` (with tiers).
    *   [x] **Task:** Create `useUpdateDealContent.ts` to call `GatewayUpdateDealContentFromEvm`.

### 4. Work Stream: Visualizations & Marketing
*   [x] **Task:** Implement interactive Performance Market visualization in `nil-website` (The Latency Racer).
*   [x] **Task:** Visualize `DealHeatState` in Deal Explorer (Added `GetDealHeat` query and UI integration).

### 5. Work Stream: Protocol Cleanup (Dynamic Sizing)
*   [ ] **Proto:** Remove `DealSize` enum and `deal_size` field from `types.proto`.
*   [ ] **Logic:** Update `MsgCreateDeal` to ignore tier, defaulting to a "Thin Provisioned" state (0 bytes).
*   [ ] **CLI:** Remove `tier` argument from `nil-cli create-deal`.
*   [ ] **Web:** Remove Tier selection from Dashboard UI (`Dashboard.tsx`).
*   [ ] **Web:** Remove Tier display from `DealDetail.tsx`.

### 6. Work Stream: UI Polish
*   [ ] **DealDetail:** Refactor `DealDetail.tsx` to use semantic Tailwind classes (support Light Mode).
*   [ ] **Visualization:** Update Deal Explorer to visualize "Stripe Layout" (12 columns) instead of just linear blobs.

## Winter Roadmap: StripeReplica & Thick Client (Phase 3)

**Goal:** Enable client-side encryption, erasure coding, and KZG commitment generation in the browser (Thick Client) to support the Mode 2 (StripeReplica) architecture.

### 1. WASM Foundation (Rust)
*   [x] **Build:** Configure `nil_core` to compile to `wasm32-unknown-unknown` (replaced `c-kzg` with `bls12_381` manual impl).
*   [x] **Trusted Setup:** Implement `KzgContext::load_from_reader` in `nil_core` to accept raw setup data from JS.
*   [x] **Bindgen:** Expose `expand_file` to JS via `wasm-bindgen`.

### 2. Mode 2 Logic (Rust)
*   [x] **Erasure Coding:** Integrate `reed-solomon-erasure` crate (RS 12,8).
*   [x] **Expansion:** Implement `expand_mdu(data: &[u8]) -> (WitnessMdu, Vec<Shard>)` following the "Blob Alignment" spec (§ 8).
*   [x] **Exposure:** Bind `expand_mdu` to JS, returning a structured object with Shards and Witness.

### 3. Frontend Integration (React)
*   [x] **Worker:** Create `src/workers/mduWorker.ts` to run `expand_mdu` off the main thread.
*   [x] **Asset:** Serve `trusted_setup.txt` (or bin) as a static asset.
*   [x] **UI:** Replace `FileSharder.tsx` mock with `WasmWorker` integration.
*   [x] **Validation:** Verified WASM compilation and basic logic flow.

### 4. Protocol Cleanup & UI Polish
*   [x] **UI:** Remove Tier selection from Dashboard UI (`Dashboard.tsx`).
*   [x] **UI:** Remove Tier display from `DealDetail.tsx`.
*   [x] **Style:** Refactor `DealDetail.tsx` to use semantic Tailwind classes (support Light Mode).

## Future Phases
*   **Web2 Wrapper:** S3 Adapter documentation and further integration (Updated S3AdapterDocs page).
*   **Governance:** DAO & Council setup visualization (Updated GovernanceDocs page with dashboard).
*   **Adversarial Simulation:** End-to-End attack simulation & visualization (P&L model - *Completed*).
*   **Unified Liveness:** Integrate user traffic directly into consensus via `RetrievalReceipt` aggregation (partially implemented in Phase 2).

## 8. Gap Analysis: Frontend vs. Protocol Spec

Future agents utilizing this documentation must be aware of the following architectural divergence detected during the review of `@spec.md` and `@nil-website/**`:

- **Triple Proof Model:** The frontend **does not** currently implement the Triple Proof verification logic described in `@notes/triple-proof.md`. It relies on the Gateway (`nil_gateway` / `nil_gateway`) to perform these checks.
- **MDU Packing:** The frontend **does not** pack files into MDUs (as defined in `@spec.md`). It streams raw bytes to the Gateway via `useUpload`.
- **Simulation vs. Reality:** The `FileSharder.tsx` component is a visual simulation using SHA-256 and is **not** part of the actual transaction pipeline.
- **Action Item:** Future work involves compiling the Rust `nil_core` crate to Wasm to enable true "Thick Client" functionality (Local KZG generation, MDU packing, and autonomous SP negotiation) directly in the browser.

## 9. Current Architecture State: Mode 2 & NilFS (As of Dec 2025)

**Status:** Specs Aligned. Implementation Pending.

We have finalized the design for **Mode 2 (StripeReplica)** and the **NilFS Layout**.

### 9.1 Mode 2 Alignment
*   **Atomic Unit:** 128 KiB Blob (KZG atom).
*   **SP‑MDU Unit:** 8 MiB (64 Blobs).
*   **Per‑Slot Bytes:** `8 MiB / K` (default `K=8` → 1 MiB).
*   **Configuration:** RS(K, K+M) with default `K=8`, `M=4` (`N=12`), with constraint `K | 64`.
*   **Verification:** Uses **Replicated Metadata** (Witness MDUs) to enable Shared-Nothing Verification.
*   **Source of Truth:** `rfcs/rfc-blob-alignment-and-striping.md`.

### 9.2 NilFS Layout (Spec Status)
*   **Current Target (V1):** Fixed 6MB Table. Simple, Robust, but limited capacity (98k files).
    *   **Decision:** We are implementing **V1** for the current Devnet.
*   **Future Upgrade (V2):** Detached Paths / Inode #1.
    *   **Decision:** Deferred to Mainnet.
    *   **Reference:** `notes/triple-proof-review.md`.

## 10. `nil_gateway` Refactor: Implementing Filesystem on Slab (TDD Plan)

This section outlines the Test-Driven Development (TDD) plan for refactoring the `nil_gateway` Gateway to implement the "Filesystem on Slab" architecture. Each step includes specific tests to pass before considering the task complete.

### 10.1 Task 1: Define Go Structs for MDU #0 Layout (V1 Schema)

**Status:** [x] COMPLETED

**Description:** Define Go structs (`FileTableHeader`, `FileRecordV1`) for the MDU #0 Super-Manifest layout in a new package `nil_gateway/pkg/layout`. This includes bit-packing logic for `length_and_flags`.

**TDD Plan:** Create `nil_gateway/pkg/layout/layout_test.go` first.

1.  **`TestBitPacking`**:
    *   **Input:** A `length` value (e.g., 100), and specific `flags` (e.g., `Encrypted | Gzip`).
    *   **Expected Output:** A `u64` representing `length_and_flags` with the correct bit-packing.
    *   **Verification:** Decode the `u64` back into `length` and `flags`, asserting they match the input.
2.  **`TestStructAlignment`**:
    *   Use `unsafe.Sizeof` to assert that `FileRecordV1` is exactly 64 bytes.
    *   Assert that `FileTableHeader` is exactly 128 bytes.
3.  **`TestSerialization`**:
    *   Create an instance of `FileRecordV1` with sample data.
    *   Serialize it to a `[]byte`.
    *   Deserialize the `[]byte` back into a new `FileRecordV1` instance.
    *   Assert that the deserialized instance is deep-equal to the original.
    *   Repeat for `FileTableHeader`.

**Definition of Done:** `go test ./pkg/layout` passes with 100% coverage of struct definition and serialization/deserialization logic. All bit-packing and size assertions are correct.

### 10.2 Task 2: Implement `Mdu0Builder` Logic

**Status:** [x] COMPLETED

**Description:** Develop a `Mdu0Builder` module responsible for initializing, modifying, and serializing the 8MB MDU #0 buffer. This builder must account for the Root Table containing roots for MDU #0 itself, **Witness MDUs**, and User Data MDUs.

**TDD Plan:** Create `nil_gateway/pkg/builder/builder_test.go` first.

1.  **`TestInitEmptyMdu0`**:
    *   Create a new `Mdu0Builder` instance with `max_user_mdus` (e.g., 65536).
    *   Assert that the internal 8MB buffer is initialized correctly:
        *   The `FileTableHeader` has `magic="NILF"`, `version=1`, `record_size=64`, `record_count=0`.
        *   The Root Table region (Blobs 0-15) is zeroed.
        *   The File Table region (Blobs 16-63) is mostly zeroed (except header).
        *   **Verify `W` calculation**: Ensure `W` (Witness MDUs count) is correctly derived based on `max_user_mdus`.
2.  **`TestAppendFileRecord`**:
    *   Initialize an `Mdu0Builder`.
    *   Add a `FileRecordV1` for "file1.txt" (1KB at logical offset 0).
    *   Assert that `FileTableHeader.record_count` increments.
    *   Assert that `FileTable` entry at index 0 matches the input record.
    *   Add a second `FileRecordV1` for "file2.txt". Assert `record_count` is 2 and the second entry is correct.
3.  **`TestAddRoot`**:
    *   Initialize an `Mdu0Builder`.
    *   Add a dummy 32-byte root (e.g., all `0xAA`) for `MDU #1` (index 0).
    *   Assert that the Root Table region at the correct offset (Blob 0, Offset 0) contains this root.
    *   **Crucial:** This root corresponds to `MDU #1` (first Witness MDU).
4.  **`TestLoadAndModify`**:
    *   Initialize an `Mdu0Builder`, add a file record and a root.
    *   Serialize the builder's buffer to a `[]byte`.
    *   Create a *new* `Mdu0Builder` and `Load()` it from the `[]byte`.
    *   Add another file record and root.
    *   Assert that `record_count` and new root are correctly applied to the loaded state.
5.  **`TestFindFreeSpace_TombstoneSplitting`**: (Covers deletion/reuse logic)
    *   Initialize builder. Add a 100KB file. Delete it (mark as tombstone).
    *   Add a 30KB file. Assert that the 100KB tombstone is reused (partially), and a new 70KB tombstone is appended.
    *   Assert File Table count is correct.

**Definition of Done:** `go test ./pkg/builder` passes, creating valid 8MB binary images, and correctly handling the Root Table indexing for Witness and User Data MDUs.

### 10.3 Task 3: Refactor `GatewayUpload` (Service Layer)

**Status:** [x] COMPLETED

**Description:** Modify the `GatewayUpload` handler (`nil_gateway/main.go`) to utilize the `Mdu0Builder` and the new "Filesystem on Slab" logic, including the generation and storage of **Witness MDUs**.

**TDD Plan:** Create `nil_gateway/main_test.go` (or a dedicated integration test package for handlers).

1.  **`TestUploadNewDealLifecycle`**:
    *   Mock `nil_cli` `shardFile` call to return dummy MDUs and roots for user data.
    *   Call `GatewayUpload` for "file_A.txt" (no `deal_id` provided, `max_user_mdus` specified).
    *   **Assert:** The response includes a *newly generated* `deal_id` (simulated) and the initial `manifest_root` for MDU #0.
    *   **Crucial:** `nil_gateway` must now:
        *   Generate the actual content for MDU #0 (empty FAT, roots for Witness and User Data MDUs set to zeros/dummies).
        *   Generate **Witness MDUs** (filled with zeros initially).
        *   Store these `(1 + W)` initial MDUs to disk.
    *   Simulate subsequent `GatewayUpdateDealContent` call to commit this.
2.  **`TestUploadAppendToExistingDeal`**:
    *   Pre-populate deal state: an existing `deal_id` on chain, and on-disk representations for MDU #0, Witness MDUs, and existing User Data MDUs.
    *   Call `GatewayUpload` for "file_B.txt", providing the `deal_id`.
    *   **Assert:** The response contains the `manifest_root` reflecting "file_B.txt" appended to the File Table, and the new `allocated_length`.
    *   **Verification:** `nil_gateway` must:
        *   Read the existing MDU #0 and Witness MDUs.
        *   Pack "file_B.txt" into new User Data MDUs.
        *   Generate/update corresponding roots in MDU #0.
        *   Generate/update corresponding Blob Commitments in Witness MDUs.
        *   Store updated MDU #0, Witness MDUs, and new User Data MDUs.
3.  **`TestUploadTombstoneReuse`**:
    *   Pre-populate deal with a deleted file.
    *   Call `GatewayUpload` for a new file that fits the deleted slot.
    *   **Assert:** `MDU #0` (and Witness MDUs) are updated reflecting reuse (and splitting if necessary).
4.  **`TestUploadLargeFileExpansion`**:
    *   Upload a file spanning multiple User Data MDUs.
    *   **Assert:** `Mdu0Builder` correctly adds multiple roots to the Root Table and `allocated_length` is updated correctly.
    *   **Verification:** Ensure Witness MDUs are correctly updated for all new User Data MDUs.

**Definition of Done:** The `GatewayUpload` handler correctly processes new file uploads, managing the MDU #0 and Witness MDUs states locally, and returning the necessary information for `MsgUpdateDealContent` (new `ManifestRoot`, `allocated_length`).

### 10.4 Task 4: Refactor `GatewayFetch` (Filesystem Resolution)

**Status:** [x] COMPLETED

**Description:** Update the `GatewayFetch` handler to resolve files by their path within a Deal, rather than requiring a direct CID for a single file. This involves reading MDU #0 and retrieving Blob Commitments from Witness MDUs for proof generation.

**TDD Plan:** Extend `nil_gateway/main_test.go` (or a dedicated integration test package for handlers).

1.  **`TestFetchByExistingPath`**:
    *   Setup deal state (MDU #0, Witness MDUs, User Data MDUs) with "video.mp4" via `Mdu0Builder`.
    *   Call `GatewayFetch(deal_id, path="video.mp4")`.
    *   **Assert:** `MDU #0` is correctly read and parsed to locate the `FileRecord`.
    *   **Crucial:** Assert Blob Commitments are correctly retrieved from **Witness MDUs** for the relevant User Data MDUs.
    *   Mock retrieval of the actual User Data MDUs. Assert the correct bytes are streamed back (e.g., via `httptest.ResponseRecorder`).
2.  **`TestFetchPathNotFound`**:
    *   Call `GatewayFetch` for non-existent path. Assert 404.
3.  **`TestFetchFromDeletedFile`**:
    *   Setup deal state with a file marked as a Tombstone.
    *   Call `GatewayFetch` for that path. Assert a 404.
4.  **`TestFetchOffsetMapping`**:
    *   Upload a file spanning multiple User Data MDUs.
    *   Request specific byte ranges within the file.
    *   **Assert:** Internal logic correctly maps `Logical_Offset` to `User_Data_MDU_Index` and `Offset_within_MDU`, and correctly retrieves commitments from Witness MDUs.

**Definition of Done:** `GatewayFetch` correctly resolves file paths, retrieves `FileRecord`s, reads Blob Commitments from Witness MDUs, and streams the correct byte ranges from the User Data MDUs.

### 10.5 Task 5: Implement `GatewayUpdateDealContent` Refactor (Chain Interaction)

**Status:** [x] COMPLETED

**Description:** Modify `GatewayUpdateDealContentFromEvm` (and potentially `GatewayUpdateDealContent`) to properly handle the `allocated_length` field and ensure the on-chain representation matches the `nil_gateway`'s understanding of the Deal's state.

**TDD Plan:** Create an integration test script (`test_lifecycle.sh`) that orchestrates chain operations.

1.  **`TestFullDealLifecycle_E2E`**:
    *   **Phase 1: Setup:** Start local `nilchaind` and `nil_gateway`.
    *   **Phase 2: Create Deal:** Use `GatewayCreateDealFromEvm` to establish a **thin‑provisioned** container Deal (`manifest_root` empty, `size = 0`).
        *   **Assertion:** Verify on-chain `manifest_root` is empty and `total_mdus`/`allocated_length` is `0` until the first `GatewayUpdateDealContent*` commit (no implicit “metadata preallocation” during `CreateDeal*`).
        *   **Note:** `max_user_mdus` is a devnet sizing hint used by the gateway for local slab/Witness layout; it MUST NOT change `Deal.total_mdus` before a content commit.
    *   **Phase 3: Upload File 1 (Expansion):**
        *   Call `GatewayUpload` for "first.txt" (e.g., 100KB).
        *   Capture the returned `manifest_root` and `new_allocated_length`.
        *   Call `GatewayUpdateDealContentFromEvm` with this data.
        *   **Assertion:** Query `nilchaind` to verify that the Deal on-chain now has the correct `manifest_root` and `allocated_length`.
    *   **Phase 4: Upload File 2 (Append):**
        *   Call `GatewayUpload` for "second.txt".
        *   Capture new `manifest_root` and `new_allocated_length`.
        *   Call `GatewayUpdateDealContentFromEvm`.
        *   **Assertion:** Query `nilchaind` to verify that the Deal on-chain has updated again.
    *   **Phase 5: Fetch & Verify:** Call `GatewayFetch` for "first.txt" and "second.txt". Assert content is correct.
    *   **Phase 6: Deletion & Reupload:** Simulate deletion, then re-upload a file to reuse space. Assert `manifest_root` updates correctly and `allocated_length` remains stable (if no new User Data MDUs were needed).

**Definition of Done:** The end-to-end chain interaction correctly updates the `Deal.manifest_root` and `Deal.allocated_length` on-chain, and these changes are reflected accurately when querying the chain.

## 11. Active Agent Work Queue (Current)

This section tracks the currently active TODOs for the AI agent working in this repo. Items here should be updated, checked off, and committed as work is completed.

### 11.0 Immediate Goals (Retrieval Separation & NilGateway)

This is the **canonical execution checklist** for the "NilGateway Refactor" sprint. The goal is to separate the "User Daemon" (Gateway) from the "Storage Provider" (SP) logic, enabling true client-side signing of retrieval receipts.

- [x] **Goal 1: Define Architecture & Specs (Phase 1).**
    - **Steps:** Create `nil_gateway/gateway-provider-split.md`; update `AGENTS.md`.
    - **Deliverable:** Clear separation of roles (`nil_gateway` vs `nil_provider`) and the Interactive Retrieval Protocol flow.

- [x] **Goal 2: Implement Storage Provider Receipt Logic (`nil_provider`).**
    - **Steps:**
        1.  Add `POST /sp/receipt` endpoint to `nil_gateway` (acting as SP).
        2.  Implement validation logic: Verify `user_signature` matches on-chain Deal Owner.
        3.  Implement submission logic: Batch or direct submit `MsgProveLiveness` using Provider Key.
    - **Pass gate:** `curl POST /sp/receipt` with a valid signed payload results in a successful on-chain transaction.
    - **Test gate:** Unit tests in `nil_gateway` + Manual curl test.

- [x] **Goal 3: Refactor Gateway Fetch for Interactive Flow (`nil_gateway`).**
    - **Steps:**
        1.  Update `GatewayFetch` to **stop** calling `submitRetrievalProof`.
        2.  Update `GatewayFetch` to set response headers: `X-Nil-Deal-ID`, `X-Nil-Epoch`, `X-Nil-Provider`, `X-Nil-Bytes-Served`.
    - **Pass gate:** `curl -I /gateway/fetch/...` returns the correct headers; no new `MsgProveLiveness` tx is seen on chain.
    - **Test gate:** Integration test ensuring headers are present.

- [x] **Goal 4: Implement Client-Side Signing (Frontend & Chain).**
    - **Steps:**
        1.  **Chain:** Update `nilchain` EIP-712 types to include `RetrievalReceipt` (excluding complex proof details from the signature).
        2.  **Chain:** Update `MsgProveLiveness` to verify EIP-712 signatures.
        3.  **Frontend:** Update `useFetch` (or download logic) to inspect headers.
        4.  **Frontend:** Trigger EIP-712 signature request (MetaMask) for `RetrievalReceipt`.
        5.  **Frontend:** POST the signed receipt to `/gateway/receipt` (which proxies to `/sp/receipt`).
    - **Pass gate:** "Download" button triggers wallet signature -> File downloads -> Receipt is submitted on-chain.
    - **Test gate:** Browser E2E smoke test (`scripts/e2e_browser_smoke.sh` updated).

### 11.1 Sprint 2 (Bundled Receipts, Batching, Nonce Scoping)

This is the **canonical execution checklist** for the next sprint, focused on reducing wallet prompts, improving auditability, and improving throughput.

- [x] **Goal 1: Bundle receipts into a Download Session.**
    - **Design:** Sign one `DownloadSessionReceipt` committing to `{deal_id, file_path, total_bytes, chunk_count, chunk_leaf_root, nonce, expires_at}` and submit all chunk proofs under that root in a single on-chain message.
    - **Key file:** `notes/retrieval-session-receipts.md`
    - **Pass gate:** Download of a multi-blob file triggers ~2 wallet signatures (open session + finalize receipt) and results in exactly 1 on-chain submission for the download.

- [x] **Goal 2: Server-side proof batching.**
    - **Change:** Add Provider endpoint to accept an array of receipts and submit a single on-chain message carrying multiple receipts/proofs.
    - **Pass gate:** `curl POST /sp/receipts` with N valid receipts results in 1 successful tx and N heat increments.

- [x] **Goal 3: Receipt nonce redesign (parallel downloads).**
    - **Change:** Move from “global per-owner strictly increasing” to per `(deal_id, file_path)` nonce tracking on-chain.
    - **Pass gate:** Two concurrent downloads of different files in the same deal do not nonce-collide.

- [x] **Goal 4: On-chain range binding.**
    - **Change:** Extend retrieval receipts (and/or session leaf commitment) to bind `(range_start, range_len)` and enforce `bytes_served == range_len`.
    - **Pass gate:** Attempts to submit a receipt with mismatched `bytes_served` and `range_len` must fail.

- [ ] **Goal 5: UI controls and progress.**
    - **Change:** Add “Download range (start/len)”, chunk progress, “receipts submitted N/M”, and prominently show `bytes_served_total` + escrow remaining.
    - **Pass gate:** Deal Explorer clearly shows download progress and the post-download heat/escrow changes.

- [x] **Goal 6: Chain ID correctness (keep 31337 default).**
    - **Change:** Remove hardcoded `31337` assumptions in chain-side EIP-712 verification; bind to a chain/module parameter with default `31337` for localhost MetaMask.
    - **Pass gate:** Local dev continues to work with chain id `31337`; non-dev networks can set a different value and verification still works.

- [x] **Goal 7: Gateway session durability.**
    - **Change:** Persist `fetch_session` state + replay cache to disk (BoltDB or sqlite) so restarts do not break receipt submission and replays remain prevented.
    - **Pass gate:** Restart gateway mid-download and still successfully finalize + submit the receipt (no replay bypass).

- [x] **Goal 8: Provider separation hardening.**
    - **Change:** Make `/gateway/receipt` a real forwarder to `/sp/receipt` with authn, and add negative tests (wrong provider, wrong proof hash, replayed session).
    - **Pass gate:** Direct calls to `/sp/receipt` without gateway auth fail; forwarded calls succeed; negative tests pass.

### 11.1.1 Devnet Alpha (Multi-SP, Mode 1 Single-Replica)

This sprint turns the current “single-machine” gateway/provider implementation into a **multi-provider devnet** with **low expectations**:
* Deals are Mode 1 but **single-replica** (`replicas=1`), so we do not need protocol-level replication yet.
* Providers are discoverable via **on-chain Multiaddr endpoints** (HTTP first, libp2p later).
* Providers serve bytes+proof material and own session state; the gateway routes/proxies.

#### Goal 1: On-chain provider endpoint discovery (Multiaddr)
- [ ] **Chain:** Extend `Provider` with `endpoints[]` (Multiaddr strings) and extend `MsgRegisterProvider` to accept endpoints.
- [ ] **Chain:** Validate endpoints (parseable Multiaddr; basic length/limit protections).
- [ ] **Chain:** Ensure `Query/GetProvider` and `Query/ListProviders` expose endpoints.
- [ ] **CLI:** Update `register-provider` to accept `--endpoint` (repeatable).
- **Pass gate:** `nilchaind q nilchain providers` returns endpoints for each registered provider.
- **Test gate:** `cd nilchain && go test ./...`

#### Goal 2: Gateway becomes a router/proxy (no local proving)
- [ ] **Gateway:** Add “router mode” (env-gated) where `GatewayFetch`, `GatewayListFiles`, `GatewaySlab`, `GatewayUpload`, and session/receipt endpoints route to the assigned provider.
- [ ] **Gateway:** Implement provider selection using `Deal.providers[]` and provider endpoints from chain; pick an HTTP Multiaddr and convert to URL.
- [ ] **Gateway:** Forward streaming fetch responses without buffering; preserve receipt headers (`X-Nil-*`).
- **Pass gate:** UI fetch/download works when gateway has no deal bytes on disk.
- **Test gate:** `cd nil_gateway && go test ./...`

#### Goal 3: Provider is the serving/proving party (source of bytes + proof headers)
- [ ] **Provider:** Ensure provider-side `GatewayFetch` is the only place that generates `X-Nil-Proof-*` headers and session IDs.
- [ ] **Provider:** Ensure download session chunks are recorded on the provider (not the gateway) in router mode.
- **Pass gate:** Receipts/session receipts verify and submit even if the gateway restarts mid-download (provider session survives).

#### Goal 4: Ingest directed to assigned provider (Mode 1 single replica)
- [ ] **Upload:** Require `deal_id` for devnet-alpha upload flows (or route initial ingest based on deal assignment); ensure “first content commit” works for thin deals.
- [ ] **UI:** Default deal creation to `replicas=1` and ensure upload/commit uses deal_id consistently.
- **Pass gate:** Create deal → upload → commit results in the assigned provider having the slab bytes and being able to serve + submit receipts.

#### Goal 5: Devnet orchestration
- [ ] Add docker-compose / scripts to start 1 gateway-router + N providers with distinct keys/ports/storage roots.
- [ ] Add a smoke script: register providers (with Multiaddrs) → create deal (replicas=1) → upload/commit → fetch → submit session receipt.
- **Pass gate:** single command stands up a 3-provider devnet and runs the smoke.

### 11.0.1 Completed Goals (Previous Sprint)

This is the **canonical execution checklist** for the next development sprint. Each item below must be completed in small, testable commits; after passing the listed test gates, commit and push to both remotes.

- [x] **Goal 1: Close NilFS “single source of truth” (restart-safe slab).**
    - **Steps:** `11.6.A3.0` restart safety E2E; `11.6.A3.1` require `file_path` in `GatewayFetch`; `11.6.A3.2` require `file_path` in `GatewayProveRetrieval`; `11.6.A3.3` delete `uploads/index.json` legacy flows.
    - **Key files:** `nil_gateway/main.go`, `nil_gateway/resolve.go`, `scripts/e2e_lifecycle.sh`, `e2e_gateway_retrieval.sh`
    - **API changes (target end state):**
        - `GET /gateway/fetch/{manifest_root}` **MUST** require query params: `deal_id`, `owner`, `file_path`.
            - Missing/empty `file_path` returns `400` with a remediation message (no CID/index fallback, no “default to only file” behavior).
            - Invalid/unsafe `file_path` returns `400` (reject traversal `..`, absolute `/` prefix, `\\` separators, and whitespace-only).
            - Unknown `file_path` (or tombstone record) returns `404`.
            - Missing/invalid `deal_id` returns `400`; unknown `deal_id` returns `404`.
            - `owner` must be the deal owner’s NilChain bech32 address; mismatch returns a clear non-200 (prefer `403`).
            - `manifest_root` parsing is strict: 48-byte compressed G1 (96 hex chars), allowing optional `0x` prefix (reject invalid compressed points / invalid subgroup encodings).
            - `manifest_root` normalization:
                - Canonical string form for logs/responses: `0x` + lowercase hex (96 chars).
                - Canonical on-disk directory key `manifest_root_key`: lowercase hex **without** `0x` (96 chars), derived by decoding then re-encoding (not by string trimming alone).
            - If `manifest_root` does not match the on-chain deal state for `deal_id`, return a clear non-200 (prefer `409`) to surface stale roots.
                - Includes the thin-provisioned case where the chain `Deal.manifest_root` is empty (not yet committed): return `409` with a hint to `update-deal-content`.
            - The gateway MUST canonicalize the on-disk deal directory key (`manifest_root_key`) to avoid duplicate directories and “same root, different path” bugs.
            - Error responses MUST be JSON (even though the success path is a byte stream) and set `Content-Type: application/json`: `{ "error": "...", "hint": "..." }`.
        - `GET /gateway/list-files/{manifest_root}` **MUST** require query params: `deal_id`, `owner`.
            - Returns NilFS file table entries parsed from `uploads/<manifest_root_key>/mdu_0.bin` (authoritative; no index fallback).
            - Response shape (target): `{ "manifest_root": "0x...", "total_size_bytes": 123, "files": [{ "path": "dir/file.txt", "size_bytes": 123, "start_offset": 0, "flags": 0 }] }`.
            - Missing/invalid params return `400`; owner mismatch returns `403`; stale `manifest_root` should return a clear non-200 (prefer `409`).
        - `POST /gateway/prove-retrieval` **MUST** require: `deal_id`, `manifest_root`, `file_path` (and any proof-specific knobs like `epoch_id`).
            - Proof inputs are resolved only from NilFS: `uploads/<manifest_root_key>/mdu_0.bin` + `uploads/<manifest_root_key>/mdu_*.bin` (+ on-chain deal state).
            - Missing/invalid params return `400`; owner mismatch (if enforced) returns `403`; unknown `file_path` returns `404`; stale `manifest_root` returns a clear non-200 (prefer `409`).
        - Any endpoint that still accepts a `cid` string treats it as an alias for `manifest_root` only — **not** a file-level CID and never a lookup key into `uploads/index.json`.
        - `POST /gateway/upload` SHOULD accept optional `file_path` (default: sanitized `filename`) and MUST return the resolved `file_path` so clients can later fetch/prove deterministically.
    - **Invariants:**
        - `uploads/<manifest_root_key>/` is the canonical, restart-safe state.
            - Required on-disk artifacts: `mdu_0.bin` and `mdu_*.bin`.
            - Sufficient for: list-files, fetch-by-path, and proof generation (given chain deal state).
        - NilFS `file_path` is the authoritative identifier for a file within a deal.
            - No hidden dependency on `uploads/index.json`, the original upload filename, or in-memory state.
            - “CID” is never treated as a file identifier (it is a deal-level commitment only).
            - `file_path` MUST be unique within a deal. If a new upload targets an existing `file_path`, the gateway must overwrite deterministically (update-in-place or tombstone + replace) so fetch/prove cannot return stale data.
                - `GET /gateway/list-files/...` should return a *deduplicated* view (latest non-tombstone record per `file_path`). If the on-disk File Table contains ambiguous duplicates, fail fast with a clear non-200 (prefer `409`) until repaired.
        - `file_path` is a URL value and MUST be handled deterministically:
            - Decode at most once (URL query params are decoded by the HTTP stack; JSON bodies must be treated as already-decoded strings). Never double-unescape.
            - Beware `+` vs `%20`: Go’s query parser treats `+` as space. Clients MUST use `%20` for spaces (JS `encodeURIComponent`) and servers should treat decoded strings as canonical.
            - Reject empty/whitespace-only, traversal (`..`), absolute paths (`/` prefix), `\\` separators, NUL bytes, and control characters.
            - Treat it as case-sensitive bytes for matching against the NilFS File Table entries.
        - Error contract must be stable and actionable:
            - Return JSON errors (with a short remediation hint) for non-200 responses from these endpoints (even if success path is a byte stream).
    - **Migration / backwards-compat:**
        - Break legacy CID-only fetch/prove flows explicitly (non-200 with remediation).
        - If legacy support is needed for local dev, keep it behind an explicit opt-in flag or dedicated endpoint (no silent fallback, no “best-effort” behavior).
        - Stop writing `uploads/index.json`; treat existing copies as deprecated/ignored state.
        - Deprecate `/gateway/manifest/{cid}` as a debug-only endpoint; it must not be on the critical path for fetch/prove.
        - Canonicalize existing on-disk deal directories:
            - If `uploads/<manifest_root_key>/` does not exist but a legacy `uploads/<raw_manifest_root>/` does (e.g., `0x` prefix or mixed case), rename it to the canonical key on first access/startup.
            - If both exist, return a clear non-200 and require manual cleanup (avoid serving from the wrong directory).
        - Remediation message should instruct clients to call `GET /gateway/list-files/{manifest_root}?deal_id=...&owner=...` to discover valid `file_path` values.
    - **Risk hotspots:**
        - Fetch compatibility: legacy clients that relied on “single-file deal” defaults or `uploads/index.json` will now hard-fail; coordinate the web + scripts change before flipping the default.
        - Path normalization: URL encoding/decoding differences (spaces, `+`, `%2F`, double-encoding like `%252F`) can cause silent mismatches; add unit tests for tricky paths and ensure we decode exactly once.
        - Duplicate paths: if upload/append allows multiple File Table entries with the same `file_path`, a naive resolver might return the *wrong* record (stale bytes). Enforce uniqueness or implement last-write-wins semantics explicitly (and test it).
        - Root normalization: accepting both `0x` + mixed-case inputs but writing a single canonical directory key can surface duplicate-directory bugs; enforce canonicalization + explicit conflict errors.
        - Security: reject traversal/absolute paths to avoid accidentally serving data outside the slab directory.
        - Streaming contract: validate params + chain state **before** writing any bytes so errors remain JSON; if an error occurs mid-stream, abort the connection (do not try to append JSON).
    - **Expected test coverage:**
        - Unit: missing/invalid `file_path` returns `400` + remediation; tombstone/not-found returns `404`; stale `manifest_root` returns non-200.
        - Unit: duplicate `file_path` handling is deterministic (prefer last-write-wins) or rejected with a clear `409` until repaired.
        - Unit: `manifest_root` parsing (length/hex/`0x`/invalid compressed G1) and `manifest_root_key` canonicalization are strict and deterministic.
        - Unit: missing/invalid `deal_id` returns `400`; unknown deal returns `404`; owner mismatch returns `403`; stale root returns `409`.
        - E2E: restart in the middle (no in-memory/index state), then list-files + fetch-by-path + prove-retrieval all succeed.
    - **Pass gate:** Upload → commit → fetch works after a restart using only on-disk slab state; missing `file_path` returns a clear non-200 (no hidden legacy behavior).
    - **Test gate:** `cd nil_gateway && go test ./...` and `./scripts/e2e_lifecycle.sh` and `./e2e_gateway_retrieval.sh`

- [x] **Goal 2: Finish “dynamic sizing / no capacity tiers” cleanup (end-to-end).**
    - **Steps:** `11.2.1` thin-provision deals; `11.2.2` remove `size_tier` from EIP-712 intents; `11.2.3` sweep scripts/docs/debug; `11.2.4` (optional) remove deprecated `size_tier` from proto.
    - **Key files:** `nilchain/x/nilchain/keeper/msg_server.go`, `nilchain/x/nilchain/types/eip712.go`, `nil-website/src/lib/eip712.ts`, `scripts/e2e_lifecycle.sh`, `e2e_create_deal_from_evm.sh`
    - **Semantics (target end state):**
        - Deals are **thin-provisioned**: `CreateDeal*` writes `manifest_root = empty`, `size = 0` (and leaves any “capacity” fields unset/ignored) until `UpdateDealContent*`.
        - Tier fields (`DealSize` / `deal_size` / `size_tier`) are **non-normative**: ignored by chain logic and removed from all client payloads.
    - **EIP-712 breaking change (plan + mitigation):**
        - Remove `size_tier` from the signed `CreateDeal(...)` typed-data definition.
        - Prevent hash collisions by bumping **either** the EIP-712 domain `version` **or** the message type name (recommended: `CreateDealV2`).
        - Transition window: the chain may accept **both** the legacy and v2 typed-data hashes to avoid a flag-day across web/scripts.
    - **Risk hotspots:**
        - Typed-data field order + domain/version drift between `viem`/MetaMask and the chain verifier; treat as high-risk/high-coordination.
        - JSON intent encoding drift (string vs number for `uint64`, `0x` prefixing, address checksum); add explicit test vectors shared between web/scripts and chain.
    - **Expected test coverage:**
        - Unit: shared EIP-712 golden vectors (CreateDealV2 + UpdateContent) match between the chain verifier and the web signer.
        - Integration: `create-deal-from-evm` succeeds with an intent that omits `size_tier` (and legacy intent support is explicit if kept during transition).
    - **Pass gate:** No `DealSize`/`deal_size`/`size_tier` remnants; CreateDeal is thin-provisioned until `UpdateDealContent*`.
    - **Test gate:** `cd nilchain && go test ./...` and `cd nil-website && npm run test:unit` and `./e2e_create_deal_from_evm.sh` and `./scripts/e2e_lifecycle.sh` and `rg -n "size_tier|SIZE_TIER|SizeTier|DealSize|deal_size" -S nil-website nilchain nil_gateway nil_cli scripts tests e2e_*.sh`

- [x] **Goal 3: Add a real browser smoke E2E suite (runs against `./scripts/run_local_stack.sh start`).**
    - **Steps:** `11.4.1` deterministic E2E wallet; `11.4.2` stable selectors; `11.4.3` dashboard lifecycle smoke; `11.4.4` deal explorer smoke; `11.4.5` one-command runner.
    - **Key files:** `nil-website/tests/*.spec.ts`, `nil-website/src/context/Web3Provider.tsx`, `scripts/run_local_stack.sh`, `scripts/e2e_browser_smoke.sh`
    - **Wallet strategy (recommended):**
        - Prefer an **injected EIP-1193 shim / deterministic test connector** (env-gated, e.g. `NIL_E2E=1`) over automating a real MetaMask extension in CI.
        - The E2E wallet MUST support `eth_signTypedData_v4` for CreateDeal + UpdateContent and send txs against the local EVM (chain id `31337`).
        - Implementation sketch (recommended):
            - In `NIL_E2E=1`, `Web3Provider` uses a custom Wagmi connector backed by a fixed dev private key (env: `NIL_E2E_PK`).
            - For Playwright, inject `window.ethereum` early (or rely on the connector only) so app code never needs MetaMask.
            - Provider API (minimum): `request({ method, params })` supports `eth_requestAccounts`, `eth_accounts`, `eth_chainId`, `eth_signTypedData_v4`, and `eth_sendTransaction` (plus `wallet_switchEthereumChain` as a no-op or deterministic error).
    - **Risk hotspots:**
        - Wallet automation is inherently flaky; keep the suite as a true smoke test with stable selectors + bounded timeouts, and avoid brittle UI interactions.
        - If we ever add “real MetaMask” automation, keep it opt-in (separate job/flag) and do not block the main CI signal on it.
    - **Pass gate:** A clean headless run can execute the happy-path flow end-to-end and exits 0.
    - **Test gate:** `./scripts/e2e_browser_smoke.sh`

**Backlog (demo-ready, non-blocking):**
- The Dashboard MDU #0 inspector + commit-content flow is **good enough for this demo**; further polish can iterate later.

**Deprioritized:**
- Native↔WASM parity tests (see **11.6.B2**) are not a priority right now.

### 11.1 EVM Integration UX (Phase 5 Step 2–3)
- [x] Implement and stabilize `NilBridge.sol` deployment to the internal EVM (Foundry), including fixing funding for the deploy key so `scripts/deploy_bridge_local.sh` succeeds by default under `./scripts/run_local_stack.sh start`.
- [x] Ensure `NIL_DEPLOY_BRIDGE=1` remains the default behavior and that a successful deploy writes `_artifacts/bridge_address.txt`, which is then wired into the web app via `VITE_BRIDGE_ADDRESS`.
- [x] Verify and, if needed, finish the Wagmi/Viem Web3 provider wiring in `nil-website` (Connect MetaMask, chain config, RPC URL).
- [x] Add a “Connect MetaMask” flow that shows the user’s NIL balance and exposes at least one happy-path NilBridge interaction (e.g., a simple `ping`/view or demo call) from the dashboard.

### 11.2 Protocol Cleanup (Dynamic Sizing)
- [x] **11.2.0 Remove capacity-tier proto fields (`DealSize` / `deal_size`).**
    - **Files:** `nilchain/proto/nilchain/nilchain/v1/types.proto`, `nilchain/proto/nilchain/nilchain/v1/tx.proto`, generated `nilchain/x/nilchain/types/*.pb.go`
    - **Pass gate:** `nilchaind` builds; LCD JSON has no `deal_size`/`DealSize` fields.
    - **Test gate:** `cd nilchain && make proto-gen && go test ./...`

- [x] **11.2.1 Chain: ensure deals are thin-provisioned (no implicit tier sizing).**
    - **Files:** `nilchain/x/nilchain/keeper/msg_server.go`, `nilchain/x/nilchain/keeper/msg_server_test.go`, `nilchain/x/nilchain/keeper/genesis_test.go`
    - **Pass gate:** `CreateDeal` + `CreateDealFromEvm` create deals with `Deal.size == 0` + empty `Deal.manifest_root` until `UpdateDealContent*` is executed; any legacy tier fields are ignored for state.
    - **Test gate:** `cd nilchain && go test ./x/nilchain/keeper -run CreateDeal`
    - **Commit gate:** After pass, commit `fix(nilchain): thin-provision CreateDeal` and push to both remotes.

- [x] **11.2.2 Remove `size_tier` from EIP-712 CreateDeal intent end-to-end.**
    - **Files (chain):** `nilchain/x/nilchain/types/eip712.go`, `nilchain/x/nilchain/keeper/msg_server.go`
    - **Files (web/tools):** `nil-website/src/lib/eip712.ts`, `nil-website/src/lib/eip712.test.ts`, `nil-website/src/hooks/useCreateDeal.ts`, `nil-website/scripts/sign_intent.ts`
    - **Pass gate:** A CreateDeal signature produced by the web (MetaMask or viem) verifies on-chain and `create-deal-from-evm` succeeds with an intent JSON that does **not** include `size_tier`.
    - **Test gate:** `cd nil-website && npm run test:unit` and `cd nilchain && go test ./...` and `./e2e_create_deal_from_evm.sh`
    - **Commit gate:** After pass, commit `refactor(eip712): remove size_tier from CreateDeal intent` and push to both remotes.

- [x] **11.2.3 Sweep + delete tier remnants in scripts/docs/debug.**
    - **Files:** `scripts/e2e_lifecycle.sh`, `e2e_create_deal_from_evm.sh`, `tests/e2e_full_stack.py`, `nil-website/website-spec.md`, `nil-website/debug/*`
    - **Pass gate:** `./scripts/e2e_lifecycle.sh` passes without `SIZE_TIER`/`size_tier` anywhere in the payloads; docs no longer instruct “tiers”.
    - **Test gate:** `./scripts/e2e_lifecycle.sh` and `rg -n "size_tier|SIZE_TIER|SizeTier|DealSize|deal_size" -S nil-website nilchain nil_gateway nil_cli scripts tests e2e_*.sh`
    - **Commit gate:** After pass, commit `chore: remove tier remnants` and push to both remotes.

- [x] **11.2.4 (Optional but preferred) Remove deprecated `size_tier` from `EvmCreateDealIntent` proto.**
    - **Files:** `nilchain/proto/nilchain/nilchain/v1/tx.proto` (reserve field 10), generated `nilchain/x/nilchain/types/tx.pb.go`, `nil-website/src/lib/eip712.ts`, `nilchain/x/nilchain/types/eip712.go`
    - **Pass gate:** `create-deal-from-evm` still works (intent JSON omits `size_tier`; default semantics unchanged); no code references `SizeTier`.
    - **Test gate:** `cd nilchain && make proto-gen && go test ./...` and `./scripts/e2e_lifecycle.sh`
    - **Commit gate:** After pass, commit `refactor(proto): remove EvmCreateDealIntent.size_tier` and push to both remotes.

### 11.3 Gateway & File Lifecycle E2E
- [x] Stabilize `/gateway/upload`, `/gateway/create-deal-evm`, and `/gateway/update-deal-content-evm` so that a full “allocate capacity → upload file → commit content → fetch file” flow works reliably via both curl and the web UI.
- [x] Ensure errors like “failed to parse tx response” and “deal creation failed: deal_id not found in transaction events” are surfaced as non-200 responses from the gateway (no silent success).
- [x] Expand shell-based e2e scripts (`scripts/e2e_lifecycle.sh`) to cover: deal creation (EVM), upload, update-deal-content, LCD verification of `manifest_root` and size, and fetch verification.
    - *Status:* **COMPLETED**.
    - *Note:* Fixed syntax errors in `msg_server.go` and verified the full lifecycle (Create -> Upload -> Update -> Fetch) works with EIP-712 signatures using ChainID 31337.
- [x] Fix `/gateway/upload` “hangs” (very slow canonical ingest):
    - **Fixed:** Speed up KZG commitments in `nil_core` and ensure gateway ingest propagates cancellation/timeouts into `nil_cli` subprocesses.
    - **Tests:** Go unit tests for `nil_gateway` (timeout/cancel + MDU #0 `--raw`) and JS unit tests in `nil-website` (AbortController timeout).
    - **E2E:** `scripts/e2e_lifecycle.sh` upload timeout reduced to `<=60s`.

### 11.4 Frontend Browser E2E (Cypress/Playwright)
- [x] **11.4.0 Playwright harness exists (baseline smoke).**
    - **Files:** `nil-website/playwright.config.ts`, `nil-website/tests/smoke.spec.ts`, `nil-website/package.json`
    - **Pass gate:** With the stack running, Playwright can load `/#/dashboard` and render the wallet prompt.
    - **Test gate:** `./scripts/run_local_stack.sh start` then `cd nil-website && npm run test:e2e`

- [x] **11.4.1 Add a deterministic E2E wallet (test account) for headless runs.**
    - **Files:** `nil-website/src/context/Web3Provider.tsx`, `scripts/run_local_stack.sh`, (new) `nil-website/src/lib/e2eWallet.ts`
    - **Pass gate:** In E2E mode, “Connect Wallet” works without the MetaMask extension and supports `eth_signTypedData_v4` for create-deal + update-content.
    - **Test gate:** `CHAIN_ID=test-1 VITE_E2E=1 ./scripts/run_local_stack.sh start` then `cd nil-website && npm run test:e2e`
    - **Commit gate:** After pass, commit `test(nil-website): deterministic E2E wallet` and push to both remotes.

- [x] **11.4.2 Add stable selectors for the demo flow (no UI polish).**
    - **Files:** `nil-website/src/components/Dashboard.tsx`, `nil-website/src/components/DealDetail.tsx`, `nil-website/src/components/ConnectWallet.tsx`
    - **Pass gate:** Playwright tests use `data-testid` selectors (not brittle text matching); UX polish remains backlog.
    - **Test gate:** `cd nil-website && npm run test:e2e`
    - **Commit gate:** After pass, commit `test(nil-website): add stable e2e selectors` and push to both remotes.

- [x] **11.4.3 Browser smoke: dashboard lifecycle (connect → create → upload → commit).**
    - **Files:** `nil-website/tests/deal-smoke.spec.ts`, `nil-website/src/hooks/useCreateDeal.ts`, `nil-website/src/hooks/useUpload.ts`, `nil-website/src/hooks/useUpdateDealContent.ts`
    - **Pass gate:** Test creates a deal, uploads a small file, commits content, and asserts the deal row shows a non-zero size + a manifest root.
    - **Test gate:** `CHAIN_ID=test-1 VITE_E2E=1 ./scripts/run_local_stack.sh start` then `cd nil-website && npm run test:e2e`
    - **Commit gate:** After pass, commit `test(nil-website): dashboard lifecycle smoke e2e` and push to both remotes.

- [x] **11.4.4 Browser smoke: deal explorer shows file + fetch works.**
    - **Files:** `nil-website/tests/deal-smoke.spec.ts`, `nil-website/src/components/DealDetail.tsx`
    - **Pass gate:** Uploaded file appears in the NilFS file list and can be downloaded via `/gateway/fetch/...&file_path=...` (HTTP 200).
    - **Test gate:** `CHAIN_ID=test-1 VITE_E2E=1 ./scripts/run_local_stack.sh start` then `cd nil-website && npm run test:e2e`
    - **Commit gate:** After pass, commit `test(nil-website): deal explorer smoke e2e` and push to both remotes.

- [x] **11.4.5 One-command runner script (start stack → run tests → stop).**
    - **Files:** (new) `scripts/e2e_browser_smoke.sh`
    - **Pass gate:** Script is idempotent and leaves no running processes on success/failure.
    - **Test gate:** `./scripts/e2e_browser_smoke.sh`
    - **Commit gate:** After pass, commit `test(scripts): browser smoke runner` and push to both remotes.

### 11.4.6 Frontend Observables & Node-Testable Logic (Dashboard/Explorer)
**Goal:** Make the web UI’s deal lifecycle observable and testable end-to-end (create → upload → commit → slab/files), using the same TypeScript model/controller code the UI consumes.

- [x] Extract LCD/Gateway normalization into pure TS “domain” modules (`nil-website/src/domain/*`) with Node unit tests.
- [x] Introduce a centralized “deal content observables” controller/hook used by both `Dashboard.tsx` and `DealDetail.tsx` to fetch:
  - `GET /gateway/slab/{manifest_root}` (MDU #0 + Witness + User segment ranges)
  - `GET /gateway/list-files/{manifest_root}` (NilFS file table)
- [x] Keep per-deal “last upload” stats visible after commit (avoid the “Allocated MDUs disappears” UX regression).
- [x] Add an opt-in Node e2e test that runs the lifecycle against a running local stack and asserts LCD + gateway observables match.

### 11.5 Core & WASM Health
- [ ] Keep `nil_core` and `nil_cli` warning-free across `cargo build` and `cargo test`, and expand unit/integration tests as new KZG/coding functionality is added.
- [ ] Ensure the WASM Mode 2 path (`expand_mdu` / `expand_file`) is exercised by tests (Rust integration tests and, where feasible, frontend tests) so “Invalid scalar”/encoding issues are caught automatically.

### 11.6 Canonical NilFS Upload + Thick Client Parity (Option D)
**Goal:** Make the devnet demo fully spec‑aligned for Mode 1 today (Gateway‑first), while stabilizing the Mode 2 Thick‑Client WASM path in parallel.

#### 11.6.A Gateway‑First Canonicalization (V1 NilFS + Triple Proof)
- [x] **A1. Make `/gateway/upload` canonical by default.**
    - **Change:** Replace `fastShardQuick` / `IngestNewDealFast` as the default with `IngestNewDeal` (full NilFS slab build: MDU #0 + Witness MDUs + User MDUs + ManifestRoot).
    - **Keep fake modes only behind explicit env:** e.g. `NIL_FAKE_INGEST=1` for simulations.
    - **Pass gate:** `./scripts/e2e_lifecycle.sh` passes with *no* ingest env flags set, and the returned `manifest_root` matches the on‑chain `Deal.manifest_root` after commit.
    - **Commit gate:** After pass, commit `feat(nil_gateway): default to canonical ingest` and push to both remotes.

- [x] **A2. Implement “append to existing deal” in `/gateway/upload` using `deal_id`.**
    - **Change:** If `deal_id` is supplied, load existing slab (`uploads/<manifest_root_key>/mdu_0.bin` + Witness MDUs), append/overwrite a `FileRecord`, update Root Table + Witness MDUs, and recompute a new ManifestRoot.
    - **Pass gate:** New e2e scenario uploads 2 files into the same deal (no new deal created) and:
        1. `allocated_length` only grows if new User MDUs are needed,
        2. `FileTableHeader.record_count` increases,
        3. both files fetch correctly by path.
    - **Commit gate:** After pass, commit `feat(nil_gateway): NilFS append upload` and push.

- [x] **A3.0 Add “restart safety” coverage to E2E (prove NilFS is the source of truth).**
    - **Files:** `scripts/e2e_lifecycle.sh`, `scripts/run_local_stack.sh`
    - **Change:** Restart `nil_gateway` (or the full stack) between upload/commit and fetch, asserting the gateway derives file state from the on-disk slab (MDU #0 + Witness/User MDUs).
    - **Pass gate:** E2E flow passes with a restart in the middle; no dependency on `uploads/index.json`.
    - **Test gate:** `./scripts/e2e_lifecycle.sh`
    - **Commit gate:** After pass, commit `test(scripts): restart coverage for NilFS SSoT` and push.

- [x] **A3.1 GatewayFetch: make `file_path` mandatory (no CID/index fallback).**
    - **Files:** `nil_gateway/main.go` (`GatewayFetch`), `nil_gateway/resolve.go`, `nil_gateway/fetch_test.go`
    - **Change:** Remove `uploads/index.json`-backed fallback branches; only resolve via NilFS (`MDU #0` File Table + slab roots).
    - **Pass gate:** Fetch by `file_path` works after restart (state derived from slab on disk); requesting fetch without `file_path` returns a clear non-200 (no hidden legacy behavior).
    - **Test gate:** `cd nil_gateway && go test ./...` and `./scripts/e2e_lifecycle.sh`
    - **Commit gate:** After pass, commit `refactor(nil_gateway): NilFS-only fetch (require file_path)` and push.

- [x] **A3.2 GatewayProveRetrieval: stop looking up file paths in `uploads/index.json`.**
    - **Files:** `nil_gateway/main.go` (`GatewayProveRetrieval`), `nil_gateway/resolve.go`, `e2e_gateway_retrieval.sh`
    - **Change:** Accept/require `file_path` (and/or slab indices) and derive all proof inputs from the slab + chain state; remove `lookupFileInIndex` usage.
    - **Pass gate:** Retrieval proof submission works using only `(deal_id, manifest_root, file_path)` and still succeeds after a gateway restart.
    - **Test gate:** `cd nil_gateway && go test ./...` and `./e2e_gateway_retrieval.sh` (updated to use `file_path`)
    - **Commit gate:** After pass, commit `refactor(nil_gateway): NilFS-only retrieval proof (no index)` and push.

- [x] **A3.3 Delete legacy `index.json` helpers (and deprecate `/gateway/manifest`).**
    - **Files:** `nil_gateway/main.go` (`lookupFileInIndex` + helpers, `GatewayManifest`), `nil_gateway/nil-gateway-spec.md`
    - **Change:** Remove the index file format and any handlers that depend on it (or refactor them to serve slab-derived data only).
    - **Pass gate:** A clean `nil_gateway` data dir without `uploads/index.json` still supports upload → commit → fetch by `file_path`; legacy CID-only flows return a clear non-200 error.
    - **Test gate:** `cd nil_gateway && go test ./...` and `./scripts/e2e_lifecycle.sh`
    - **Commit gate:** After pass, commit `refactor(nil_gateway): delete index.json legacy flows` and push.

- [x] **A4. Update Commit‑Content UI to be NilFS‑aware.**
    - **Change:** “Commit Content” tab shows a per‑deal file list from NilFS, supports multiple uploads into one deal, and uses returned `manifest_root` + `allocated_length` for `update-deal-content-evm`.
    - **Pass gate:** Manual happy‑path in browser:
        1. Create deal,
        2. Upload file → returns canonical ManifestRoot,
        3. Commit content → deal becomes Active with correct size,
        4. Fetch from Deal Explorer succeeds.
    - **Backlog:** UX/UI polish (non-blocking) can iterate after the protocol + e2e work is finished.
    - **Commit gate:** After pass, commit `feat(nil-website): NilFS commit-content UX` and push.

#### 11.6.B Thick‑Client WASM Stabilization (Parallel Track)
- [x] **B1. Fix WASM “Invalid scalar” in `expand_mdu/expand_file`.**
    - **Change:** Repair scalar field mapping / roots‑of‑unity coordinate logic in `nil_core` WASM so browser outputs match native.
    - **Pass gate:** `cargo test -p nil_core` + WASM unit/integration tests pass, and `Local MDU (WASM)` tab can expand a sample file without errors.
    - **Commit gate:** After pass, commit `fix(nil_core): WASM expand_mdu scalar mapping` and push.

- [ ] **B2. (Back burner) Add native↔WASM parity tests for MDU expansion.**
    - **Change:** For a fixed fixture file, assert:
        1. WASM `expand_file` MDUs/roots/commitments equal `nil_cli shard` output,
        2. resulting ManifestRoot equals canonical gateway ingest ManifestRoot.
    - **Pass gate:** Parity tests run in CI/local (Rust + JS) and fail on drift.
    - **Commit gate:** After pass, commit `test: WASM/native expansion parity` and push.

- [ ] **B3. (Deferred) Integrate client‑side pre‑sharding into gateway.**
    - **Change:** Add an optional gateway endpoint to accept pre‑expanded MDUs + Witness data from browser (Mode 2), but keep Gateway‑first flow as default until stable.
    - **Pass gate:** Feature flag works end‑to‑end on localhost without breaking Mode 1.
    - **Commit gate:** After pass, commit `feat(nil_gateway,nil-website): pre-sharded upload path` and push.
